============================================================
 Found issues in 7 files
============================================================

File: .\src\config\config.cpp
109676 warnings and 23 errors generated.
Error while processing C:\Dev\CiviWave-FEM\src\config\config.cpp.
error: too many errors emitted, stopping now [clang-diagnostic-error]
error: unknown argument: '-fdeps-format=p1689r5' [clang-diagnostic-error]
error: unknown argument: '-fmodule-mapper=src\CMakeFiles\cwf_core.dir\config\config.cpp.obj.modmap' [clang-diagnostic-error]
error: unknown argument: '-fmodules-ts' [clang-diagnostic-error]
    7 | #pragma once
      | ^
   16 | YAML_CPP_API std::string EncodeBase64(const unsigned char *data,
      |              ~~~~~~~~~~~ ^
      |              auto
   17 |                                       std::size_t size);
      |                                                        
      |                                                         -> std::string
   16 | YAML_CPP_API std::string EncodeBase64(const unsigned char *data,
      |                          ^~~~~~~~~~~~
      |                          encodeBase64
   18 | YAML_CPP_API std::vector<unsigned char> DecodeBase64(const std::string &input);
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^                                     
      |              auto                                                              -> std::vector<unsigned char>
   18 | YAML_CPP_API std::vector<unsigned char> DecodeBase64(const std::string &input);
      |                                         ^~~~~~~~~~~~
      |                                         decodeBase64
   20 | class YAML_CPP_API Binary {
      |                    ^
   23 |       : m_data{}, m_unownedData(data_), m_unownedSize(size_) {}
      |         ^~~~~~~~
   27 |   Binary &operator=(const Binary &) = default;
      |   ~~~~~~~~^
      |   auto                              -> Binary &
   28 |   Binary &operator=(Binary &&) = default;
      |   ~~~~~~~~^
      |   auto                         -> Binary &
   30 |   bool owned() const { return !m_unownedData; }
      |   ^
      |   [[nodiscard]] 
   30 |   bool owned() const { return !m_unownedData; }
      |   ~~~~ ^
      |   auto               -> bool
   30 |   bool owned() const { return !m_unownedData; }
      |                               ~^            
      |                                              == nullptr
   31 |   std::size_t size() const { return owned() ? m_data.size() : m_unownedSize; }
      |   ^
      |   [[nodiscard]] 
   31 |   std::size_t size() const { return owned() ? m_data.size() : m_unownedSize; }
      |   ~~~~~~~~~~~ ^
      |   auto                     -> std::size_t
   32 |   const unsigned char *data() const {
      |   ^
      |   [[nodiscard]] 
   32 |   const unsigned char *data() const {
      |   ~~~~~~~~~~~~~~~~~~~~~^
      |   auto                              -> const unsigned char *
   33 |     return owned() ? &m_data[0] : m_unownedData;
      |                      ^~~~~~~~~~
      |                      m_data.data()
   37 |     if (m_unownedData) {
      |         ^            
      |                       != nullptr
   41 |       std::copy(m_unownedData, m_unownedData + m_unownedSize, rhs.begin());
      |                                              ^
   49 |   bool operator==(const Binary &rhs) const {
      |   ~~~~ ^
      |   auto                                     -> bool
   50 |     const std::size_t s = size();
      |                       ^
   51 |     if (s != rhs.size())
      |                         ^
      |                          {
   52 |       return false;
      |                    
   53 |     const unsigned char *d1 = data();
      |                          ^
   54 |     const unsigned char *d2 = rhs.data();
      |                          ^
   55 |     for (std::size_t i = 0; i < s; i++) {
      |     ^
   56 |       if (*d1++ != *d2++)
      |              ^
   56 |       if (*d1++ != *d2++)
      |                       ^
   56 |       if (*d1++ != *d2++)
      |                          ^
      |                           {
   57 |         return false;
      |                      
   62 |   bool operator!=(const Binary &rhs) const { return !(*this == rhs); }
      |   ~~~~ ^
      |   auto                                     -> bool
   65 |   std::vector<unsigned char> m_data;
      |                              ^
note: this fix will not be applied because it overlaps with another fix
   23 |   const unsigned char *m_unownedData;
      |                        ^~~~~~~~~~~~~
      |                        m_unownedData_
   23 |   std::size_t m_unownedSize;
      |               ^~~~~~~~~~~~~
      |               m_unownedSize_
    7 | #pragma once
      | ^
   33 | class YAML_CPP_API Emitter {
      |                    ^
   38 |   Emitter& operator=(const Emitter&) = delete;
      |   ~~~~~~~~ ^
      |   auto                               -> Emitter&
   42 |   const char* c_str() const;
      |   ~~~~~~~~~~~ ^            
      |   auto                      -> const char*
   42 |   const char* c_str() const;
      |               ^~~~~
      |               cStr
   43 |   std::size_t size() const;
      |   ~~~~~~~~~~~ ^           
      |   auto                     -> std::size_t
   46 |   bool good() const;
      |   ~~~~ ^           
      |   auto              -> bool
   47 |   const std::string GetLastError() const;
      |   ~~~~~~~~~~~~~~~~~ ^                   
      |   auto                                   -> const std::string
   47 |   const std::string GetLastError() const;
      |                     ^~~~~~~~~~~~
      |                     getLastError
   50 |   bool SetOutputCharset(EMITTER_MANIP value);
      |   ~~~~ ^                                    
      |   auto                                       -> bool
   50 |   bool SetOutputCharset(EMITTER_MANIP value);
      |        ^~~~~~~~~~~~~~~~
      |        setOutputCharset
   51 |   bool SetStringFormat(EMITTER_MANIP value);
      |   ~~~~ ^                                   
      |   auto                                      -> bool
   51 |   bool SetStringFormat(EMITTER_MANIP value);
      |        ^~~~~~~~~~~~~~~
      |        setStringFormat
   52 |   bool SetBoolFormat(EMITTER_MANIP value);
      |   ~~~~ ^                                 
      |   auto                                    -> bool
   52 |   bool SetBoolFormat(EMITTER_MANIP value);
      |        ^~~~~~~~~~~~~
      |        setBoolFormat
   53 |   bool SetNullFormat(EMITTER_MANIP value);
      |   ~~~~ ^                                 
      |   auto                                    -> bool
   53 |   bool SetNullFormat(EMITTER_MANIP value);
      |        ^~~~~~~~~~~~~
      |        setNullFormat
   54 |   bool SetIntBase(EMITTER_MANIP value);
      |   ~~~~ ^                              
      |   auto                                 -> bool
   54 |   bool SetIntBase(EMITTER_MANIP value);
      |        ^~~~~~~~~~
      |        setIntBase
   55 |   bool SetSeqFormat(EMITTER_MANIP value);
      |   ~~~~ ^                                
      |   auto                                   -> bool
   55 |   bool SetSeqFormat(EMITTER_MANIP value);
      |        ^~~~~~~~~~~~
      |        setSeqFormat
   56 |   bool SetMapFormat(EMITTER_MANIP value);
      |   ~~~~ ^                                
      |   auto                                   -> bool
   56 |   bool SetMapFormat(EMITTER_MANIP value);
      |        ^~~~~~~~~~~~
      |        setMapFormat
   57 |   bool SetIndent(std::size_t n);
      |   ~~~~ ^                       
      |   auto                          -> bool
   57 |   bool SetIndent(std::size_t n);
      |        ^~~~~~~~~
      |        setIndent
   58 |   bool SetPreCommentIndent(std::size_t n);
      |   ~~~~ ^                                 
      |   auto                                    -> bool
   58 |   bool SetPreCommentIndent(std::size_t n);
      |        ^~~~~~~~~~~~~~~~~~~
      |        setPreCommentIndent
   59 |   bool SetPostCommentIndent(std::size_t n);
      |   ~~~~ ^                                  
      |   auto                                     -> bool
   59 |   bool SetPostCommentIndent(std::size_t n);
      |        ^~~~~~~~~~~~~~~~~~~~
      |        setPostCommentIndent
   60 |   bool SetFloatPrecision(std::size_t n);
      |   ~~~~ ^                               
      |   auto                                  -> bool
   60 |   bool SetFloatPrecision(std::size_t n);
      |        ^~~~~~~~~~~~~~~~~
      |        setFloatPrecision
   61 |   bool SetDoublePrecision(std::size_t n);
      |   ~~~~ ^                                
      |   auto                                   -> bool
   61 |   bool SetDoublePrecision(std::size_t n);
      |        ^~~~~~~~~~~~~~~~~~
      |        setDoublePrecision
   62 |   void RestoreGlobalModifiedSettings();
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |        restoreGlobalModifiedSettings
   65 |   Emitter& SetLocalValue(EMITTER_MANIP value);
      |   ~~~~~~~~ ^                                 
      |   auto                                        -> Emitter&
   65 |   Emitter& SetLocalValue(EMITTER_MANIP value);
      |            ^~~~~~~~~~~~~
      |            setLocalValue
   66 |   Emitter& SetLocalIndent(const _Indent& indent);
      |   ~~~~~~~~ ^                                    
      |   auto                                           -> Emitter&
   66 |   Emitter& SetLocalIndent(const _Indent& indent);
      |            ^~~~~~~~~~~~~~
      |            setLocalIndent
   67 |   Emitter& SetLocalPrecision(const _Precision& precision);
      |   ~~~~~~~~ ^                                             
      |   auto                                                    -> Emitter&
   67 |   Emitter& SetLocalPrecision(const _Precision& precision);
      |            ^~~~~~~~~~~~~~~~~
      |            setLocalPrecision
   70 |   Emitter& Write(const std::string& str);
      |   ~~~~~~~~ ^                            
      |   auto                                   -> Emitter&
   70 |   Emitter& Write(const std::string& str);
      |            ^~~~~
      |            write
   71 |   Emitter& Write(bool b);
      |   ~~~~~~~~ ^            
      |   auto                   -> Emitter&
   71 |   Emitter& Write(bool b);
      |            ^~~~~
      |            write
   71 |   Emitter& Write(bool b);
      |                       ^
   72 |   Emitter& Write(char ch);
      |   ~~~~~~~~ ^             
      |   auto                    -> Emitter&
   72 |   Emitter& Write(char ch);
      |            ^~~~~
      |            write
   72 |   Emitter& Write(char ch);
      |                       ^
   73 |   Emitter& Write(const _Alias& alias);
      |   ~~~~~~~~ ^                         
      |   auto                                -> Emitter&
   73 |   Emitter& Write(const _Alias& alias);
      |            ^~~~~
      |            write
   74 |   Emitter& Write(const _Anchor& anchor);
      |   ~~~~~~~~ ^                           
      |   auto                                  -> Emitter&
   74 |   Emitter& Write(const _Anchor& anchor);
      |            ^~~~~
      |            write
   75 |   Emitter& Write(const _Tag& tag);
      |   ~~~~~~~~ ^                     
      |   auto                            -> Emitter&
   75 |   Emitter& Write(const _Tag& tag);
      |            ^~~~~
      |            write
   76 |   Emitter& Write(const _Comment& comment);
      |   ~~~~~~~~ ^                             
      |   auto                                    -> Emitter&
   76 |   Emitter& Write(const _Comment& comment);
      |            ^~~~~
      |            write
   77 |   Emitter& Write(const _Null& n);
      |   ~~~~~~~~ ^                    
      |   auto                           -> Emitter&
   77 |   Emitter& Write(const _Null& n);
      |            ^~~~~
      |            write
   78 |   Emitter& Write(const Binary& binary);
      |   ~~~~~~~~ ^                          
      |   auto                                 -> Emitter&
   78 |   Emitter& Write(const Binary& binary);
      |            ^~~~~
      |            write
   81 |   Emitter& WriteIntegralType(T value);
      |   ~~~~~~~~ ^                         
      |   auto                                -> Emitter&
   81 |   Emitter& WriteIntegralType(T value);
      |            ^~~~~~~~~~~~~~~~~
      |            writeIntegralType
   84 |   Emitter& WriteStreamable(T value);
      |   ~~~~~~~~ ^                       
      |   auto                              -> Emitter&
   84 |   Emitter& WriteStreamable(T value);
      |            ^~~~~~~~~~~~~~~
      |            writeStreamable
   88 |   void SetStreamablePrecision(std::stringstream&) {}
      |        ^~~~~~~~~~~~~~~~~~~~~~
      |        setStreamablePrecision
   88 |   void SetStreamablePrecision(std::stringstream&) {}
      |                                                 ^
      |                                                  /*unused*/
   89 |   std::size_t GetFloatPrecision() const;
      |   ~~~~~~~~~~~ ^                        
      |   auto                                  -> std::size_t
   89 |   std::size_t GetFloatPrecision() const;
      |               ^~~~~~~~~~~~~~~~~
      |               getFloatPrecision
   90 |   std::size_t GetDoublePrecision() const;
      |   ~~~~~~~~~~~ ^                         
      |   auto                                   -> std::size_t
   90 |   std::size_t GetDoublePrecision() const;
      |               ^~~~~~~~~~~~~~~~~~
      |               getDoublePrecision
   92 |   void PrepareIntegralStream(std::stringstream& stream) const;
      |        ^~~~~~~~~~~~~~~~~~~~~
      |        prepareIntegralStream
   93 |   void StartedScalar();
      |        ^~~~~~~~~~~~~
      |        startedScalar
   95 |  private:
      |  ^~~~~~~~
   86 |  private:
      |  ^
   96 |   void EmitBeginDoc();
      |        ^~~~~~~~~~~~
      |        emitBeginDoc
   97 |   void EmitEndDoc();
      |        ^~~~~~~~~~
      |        emitEndDoc
   98 |   void EmitBeginSeq();
      |        ^~~~~~~~~~~~
      |        emitBeginSeq
   99 |   void EmitEndSeq();
      |        ^~~~~~~~~~
      |        emitEndSeq
  100 |   void EmitBeginMap();
      |        ^~~~~~~~~~~~
      |        emitBeginMap
  101 |   void EmitEndMap();
      |        ^~~~~~~~~~
      |        emitEndMap
  102 |   void EmitNewline();
      |        ^~~~~~~~~~~
      |        emitNewline
  103 |   void EmitKindTag();
      |        ^~~~~~~~~~~
      |        emitKindTag
  104 |   void EmitTag(bool verbatim, const _Tag& tag);
      |        ^~~~~~~
      |        emitTag
  106 |   void PrepareNode(EmitterNodeType::value child);
      |        ^~~~~~~~~~~
      |        prepareNode
  107 |   void PrepareTopNode(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~
      |        prepareTopNode
  108 |   void FlowSeqPrepareNode(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~
      |        flowSeqPrepareNode
  109 |   void BlockSeqPrepareNode(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~
      |        blockSeqPrepareNode
  111 |   void FlowMapPrepareNode(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~
      |        flowMapPrepareNode
  113 |   void FlowMapPrepareLongKey(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~~~
      |        flowMapPrepareLongKey
  114 |   void FlowMapPrepareLongKeyValue(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~
      |        flowMapPrepareLongKeyValue
  115 |   void FlowMapPrepareSimpleKey(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~~~~~
      |        flowMapPrepareSimpleKey
  116 |   void FlowMapPrepareSimpleKeyValue(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |        flowMapPrepareSimpleKeyValue
  118 |   void BlockMapPrepareNode(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~
      |        blockMapPrepareNode
  120 |   void BlockMapPrepareLongKey(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~~~~
      |        blockMapPrepareLongKey
  121 |   void BlockMapPrepareLongKeyValue(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
      |        blockMapPrepareLongKeyValue
  122 |   void BlockMapPrepareSimpleKey(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~
      |        blockMapPrepareSimpleKey
  123 |   void BlockMapPrepareSimpleKeyValue(EmitterNodeType::value child);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |        blockMapPrepareSimpleKeyValue
  125 |   void SpaceOrIndentTo(bool requireSpace, std::size_t indent);
      |        ^~~~~~~~~~~~~~~
      |        spaceOrIndentTo
  127 |   const char* ComputeFullBoolName(bool b) const;
      |   ~~~~~~~~~~~ ^                                
      |   auto                                          -> const char*
  127 |   const char* ComputeFullBoolName(bool b) const;
      |               ^~~~~~~~~~~~~~~~~~~
      |               computeFullBoolName
  127 |   const char* ComputeFullBoolName(bool b) const;
      |                                        ^
  128 |   const char* ComputeNullName() const;
      |   ~~~~~~~~~~~ ^                      
      |   auto                                -> const char*
  128 |   const char* ComputeNullName() const;
      |               ^~~~~~~~~~~~~~~
      |               computeNullName
  129 |   bool CanEmitNewline() const;
      |   ~~~~ ^                     
      |   auto                        -> bool
  129 |   bool CanEmitNewline() const;
      |        ^~~~~~~~~~~~~~
      |        canEmitNewline
  131 |  private:
      |  ^~~~~~~~
   86 |  private:
      |  ^
  132 |   std::unique_ptr<EmitterState> m_pState;
      |                                 ^~~~~~~~
      |                                 m_pState_
  133 |   ostream_wrapper m_stream;
      |                   ^~~~~~~~
      |                   m_stream_
  134 | };
  135 | 
  136 | template <typename T>
  137 | inline Emitter& Emitter::WriteIntegralType(T value) {
  138 |   if (!good())
  139 |     return *this;
  140 | 
  141 |   PrepareNode(EmitterNodeType::Scalar);
  142 | 
  143 |   std::stringstream stream;
  144 |   PrepareIntegralStream(stream);
  145 |   stream << value;
  146 |   m_stream << stream.str();
      |   ~~~~~~~~
      |   m_stream_
  137 | inline Emitter& Emitter::WriteIntegralType(T value) {
      |        ~~~~~~~~          ^
      |        auto                                         -> Emitter&
  138 |   if (!good())
      |               ^
      |                {
  139 |     return *this;
      |                  
  154 | inline Emitter& Emitter::WriteStreamable(T value) {
      |        ~~~~~~~~          ^
      |        auto                                       -> Emitter&
  155 |   if (!good())
      |               ^
      |                {
  156 |     return *this;
      |                  
  164 |   if (std::is_floating_point<T>::value) {
      |       ^                        ~~~~~~~
      |                             _v
  191 | inline void Emitter::SetStreamablePrecision<float>(std::stringstream& stream) {
      |                      ^~~~~~~~~~~~~~~~~~~~~~
      |                      setStreamablePrecision
  196 | inline void Emitter::SetStreamablePrecision<double>(std::stringstream& stream) {
      |                      ^~~~~~~~~~~~~~~~~~~~~~
      |                      setStreamablePrecision
  201 | inline Emitter& operator<<(Emitter& emitter, const std::string& v) {
      |        ~~~~~~~~ ^
      |        auto                                                        -> Emitter&
  201 | inline Emitter& operator<<(Emitter& emitter, const std::string& v) {
      |                                                                 ^
  204 | inline Emitter& operator<<(Emitter& emitter, bool v) {
      |        ~~~~~~~~ ^
      |        auto                                          -> Emitter&
  204 | inline Emitter& operator<<(Emitter& emitter, bool v) {
      |                                                   ^
  207 | inline Emitter& operator<<(Emitter& emitter, char v) {
      |        ~~~~~~~~ ^
      |        auto                                          -> Emitter&
  207 | inline Emitter& operator<<(Emitter& emitter, char v) {
      |                                                   ^
  210 | inline Emitter& operator<<(Emitter& emitter, unsigned char v) {
      |        ~~~~~~~~ ^
      |        auto                                                   -> Emitter&
  210 | inline Emitter& operator<<(Emitter& emitter, unsigned char v) {
      |                                                            ^
  213 | inline Emitter& operator<<(Emitter& emitter, const _Alias& v) {
      |        ~~~~~~~~ ^
      |        auto                                                   -> Emitter&
  213 | inline Emitter& operator<<(Emitter& emitter, const _Alias& v) {
      |                                                            ^
  216 | inline Emitter& operator<<(Emitter& emitter, const _Anchor& v) {
      |        ~~~~~~~~ ^
      |        auto                                                    -> Emitter&
  216 | inline Emitter& operator<<(Emitter& emitter, const _Anchor& v) {
      |                                                             ^
  219 | inline Emitter& operator<<(Emitter& emitter, const _Tag& v) {
      |        ~~~~~~~~ ^
      |        auto                                                 -> Emitter&
  219 | inline Emitter& operator<<(Emitter& emitter, const _Tag& v) {
      |                                                          ^
  222 | inline Emitter& operator<<(Emitter& emitter, const _Comment& v) {
      |        ~~~~~~~~ ^
      |        auto                                                     -> Emitter&
  222 | inline Emitter& operator<<(Emitter& emitter, const _Comment& v) {
      |                                                              ^
  225 | inline Emitter& operator<<(Emitter& emitter, const _Null& v) {
      |        ~~~~~~~~ ^
      |        auto                                                  -> Emitter&
  225 | inline Emitter& operator<<(Emitter& emitter, const _Null& v) {
      |                                                           ^
  228 | inline Emitter& operator<<(Emitter& emitter, const Binary& b) {
      |        ~~~~~~~~ ^
      |        auto                                                   -> Emitter&
  228 | inline Emitter& operator<<(Emitter& emitter, const Binary& b) {
      |                                                            ^
  232 | inline Emitter& operator<<(Emitter& emitter, const char* v) {
      |        ~~~~~~~~ ^
      |        auto                                                 -> Emitter&
  232 | inline Emitter& operator<<(Emitter& emitter, const char* v) {
      |                                                          ^
  236 | inline Emitter& operator<<(Emitter& emitter, int v) {
      |        ~~~~~~~~ ^
      |        auto                                         -> Emitter&
  236 | inline Emitter& operator<<(Emitter& emitter, int v) {
      |                                                  ^
  239 | inline Emitter& operator<<(Emitter& emitter, unsigned int v) {
      |        ~~~~~~~~ ^
      |        auto                                                  -> Emitter&
  239 | inline Emitter& operator<<(Emitter& emitter, unsigned int v) {
      |                                                           ^
  242 | inline Emitter& operator<<(Emitter& emitter, short v) {
      |        ~~~~~~~~ ^
      |        auto                                           -> Emitter&
  242 | inline Emitter& operator<<(Emitter& emitter, short v) {
      |                                                    ^
  245 | inline Emitter& operator<<(Emitter& emitter, unsigned short v) {
      |        ~~~~~~~~ ^
      |        auto                                                    -> Emitter&
  245 | inline Emitter& operator<<(Emitter& emitter, unsigned short v) {
      |                                                             ^
  248 | inline Emitter& operator<<(Emitter& emitter, long v) {
      |        ~~~~~~~~ ^
      |        auto                                          -> Emitter&
  248 | inline Emitter& operator<<(Emitter& emitter, long v) {
      |                                                   ^
  251 | inline Emitter& operator<<(Emitter& emitter, unsigned long v) {
      |        ~~~~~~~~ ^
      |        auto                                                   -> Emitter&
  251 | inline Emitter& operator<<(Emitter& emitter, unsigned long v) {
      |                                                            ^
  254 | inline Emitter& operator<<(Emitter& emitter, long long v) {
      |        ~~~~~~~~ ^
      |        auto                                               -> Emitter&
  254 | inline Emitter& operator<<(Emitter& emitter, long long v) {
      |                                                        ^
  257 | inline Emitter& operator<<(Emitter& emitter, unsigned long long v) {
      |        ~~~~~~~~ ^
      |        auto                                                        -> Emitter&
  257 | inline Emitter& operator<<(Emitter& emitter, unsigned long long v) {
      |                                                                 ^
  261 | inline Emitter& operator<<(Emitter& emitter, float v) {
      |        ~~~~~~~~ ^
      |        auto                                           -> Emitter&
  261 | inline Emitter& operator<<(Emitter& emitter, float v) {
      |                                                    ^
  264 | inline Emitter& operator<<(Emitter& emitter, double v) {
      |        ~~~~~~~~ ^
      |        auto                                            -> Emitter&
  264 | inline Emitter& operator<<(Emitter& emitter, double v) {
      |                                                     ^
  268 | inline Emitter& operator<<(Emitter& emitter, EMITTER_MANIP value) {
      |        ~~~~~~~~ ^
      |        auto                                                       -> Emitter&
  272 | inline Emitter& operator<<(Emitter& emitter, _Indent indent) {
      |        ~~~~~~~~ ^
      |        auto                                                  -> Emitter&
  276 | inline Emitter& operator<<(Emitter& emitter, _Precision precision) {
      |        ~~~~~~~~ ^
      |        auto                                                        -> Emitter&
    7 | #pragma once
      | ^
   12 |   enum value { NoType, Property, Scalar, FlowSeq, BlockSeq, FlowMap, BlockMap };
      |        ^
   14 | }
      | ^
      |   // namespace YAML
   10 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   13 | enum EMITTER_MANIP {
      |      ^
   72 | struct _Indent {
      |        ^
note: this fix will not be applied because it overlaps with another fix
note: this fix will not be applied because it overlaps with another fix
   73 |   _Indent(int value_) : value(value_) {}
      |   ^
      |   explicit 
   74 |   int value;
      |       ^
   77 | inline _Indent Indent(int value) { return _Indent(value); }
      |                ^
note: this fix will not be applied because it overlaps with another fix
   77 | inline _Indent Indent(int value) { return _Indent(value); }
      |                ^~~~~~
      |                indent
   77 | inline _Indent Indent(int value) { return _Indent(value); }
      |                                           ^~~~~~~~     ~
      |                                           {            }
   79 | struct _Alias {
      |        ^
   80 |   _Alias(const std::string& content_) : content(content_) {}
   81 |   std::string content;
   82 | };
      |  
      |   __attribute__((aligned(32)))
   79 | struct _Alias {
      |        ^
note: this fix will not be applied because it overlaps with another fix
note: this fix will not be applied because it overlaps with another fix
   80 |   _Alias(const std::string& content_) : content(content_) {}
      |   ^
      |   explicit 
   11 |   _Alias(const std::string& content_) : content(content_) {}
      |          ^~~~~~~~~~~~~~~~~~                             
      |          std::string                            std::move( )
   81 |   std::string content;
      |               ^
   84 | inline _Alias Alias(const std::string& content) { return _Alias(content); }
      |               ^
note: this fix will not be applied because it overlaps with another fix
   84 | inline _Alias Alias(const std::string& content) { return _Alias(content); }
      |               ^~~~~
      |               alias
   84 | inline _Alias Alias(const std::string& content) { return _Alias(content); }
      |                                                          ^
   86 | struct _Anchor {
      |        ^
   87 |   _Anchor(const std::string& content_) : content(content_) {}
   88 |   std::string content;
   89 | };
      |  
      |   __attribute__((aligned(32)))
   86 | struct _Anchor {
      |        ^
note: this fix will not be applied because it overlaps with another fix
note: this fix will not be applied because it overlaps with another fix
   87 |   _Anchor(const std::string& content_) : content(content_) {}
      |   ^
      |   explicit 
   87 |   _Anchor(const std::string& content_) : content(content_) {}
      |           ^~~~~~~~~~~~~~~~~~                             
      |           std::string                            std::move( )
   88 |   std::string content;
      |               ^
   91 | inline _Anchor Anchor(const std::string& content) { return _Anchor(content); }
      |                ^
note: this fix will not be applied because it overlaps with another fix
   91 | inline _Anchor Anchor(const std::string& content) { return _Anchor(content); }
      |                ^~~~~~
      |                anchor
   91 | inline _Anchor Anchor(const std::string& content) { return _Anchor(content); }
      |                                                            ^
   93 | struct _Tag {
      |        ^
   94 |   struct Type {
   95 |     enum value { Verbatim, PrimaryHandle, NamedHandle };
   96 |   };
   97 | 
   98 |   explicit _Tag(const std::string& prefix_, const std::string& content_,
   99 |                 Type::value type_)
  100 |       : prefix(prefix_), content(content_), type(type_) {}
  101 |   std::string prefix;
  102 |   std::string content;
  103 |   Type::value type;
  104 | };
      |  
      |   __attribute__((packed))
   93 | struct _Tag {
      |        ^
   94 |   struct Type {
   95 |     enum value { Verbatim, PrimaryHandle, NamedHandle };
   96 |   };
   97 | 
   98 |   explicit _Tag(const std::string& prefix_, const std::string& content_,
   99 |                 Type::value type_)
  100 |       : prefix(prefix_), content(content_), type(type_) {}
  101 |   std::string prefix;
  102 |   std::string content;
  103 |   Type::value type;
  104 | };
      |  
      |   __attribute__((aligned(128)))
   93 | struct _Tag {
      |        ^
note: this fix will not be applied because it overlaps with another fix
note: this fix will not be applied because it overlaps with another fix
   95 |     enum value { Verbatim, PrimaryHandle, NamedHandle };
      |          ^
   98 |   explicit _Tag(const std::string& prefix_, const std::string& content_,
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   98 |   explicit _Tag(const std::string& prefix_, const std::string& content_,
      |                                    ^~~~~~~
   98 |   explicit _Tag(const std::string& prefix_, const std::string& content_,
      |                                                                ^~~~~~~~
   98 |   explicit _Tag(const std::string& prefix_, const std::string& content_,
      |                 ^~~~~~~~~~~~~~~~~~
      |                 std::string 
   99 |                 Type::value type_)
  100 |       : prefix(prefix_), content(content_), type(type_) {}
      |                       
      |                std::move( )
   98 |   explicit _Tag(const std::string& prefix_, const std::string& content_,
      |                                             ^~~~~~~~~~~~~~~~~~
      |                                             std::string 
   99 |                 Type::value type_)
  100 |       : prefix(prefix_), content(content_), type(type_) {}
      |                                          
      |                                  std::move( )
  101 |   std::string prefix;
      |               ^
  102 |   std::string content;
      |               ^
  103 |   Type::value type;
      |               ^
  106 | inline _Tag VerbatimTag(const std::string& content) {
      |             ^
note: this fix will not be applied because it overlaps with another fix
  106 | inline _Tag VerbatimTag(const std::string& content) {
      |             ^~~~~~~~~~~
      |             verbatimTag
  110 | inline _Tag LocalTag(const std::string& content) {
      |             ^
note: this fix will not be applied because it overlaps with another fix
  110 | inline _Tag LocalTag(const std::string& content) {
      |             ^~~~~~~~
      |             localTag
  114 | inline _Tag LocalTag(const std::string& prefix, const std::string content) {
      |             ^
note: this fix will not be applied because it overlaps with another fix
  114 | inline _Tag LocalTag(const std::string& prefix, const std::string content) {
      |             ^~~~~~~~
      |             localTag
  114 | inline _Tag LocalTag(const std::string& prefix, const std::string content) {
      |                                                                   ^
      |                                                                  &
  118 | inline _Tag SecondaryTag(const std::string& content) {
      |             ^
note: this fix will not be applied because it overlaps with another fix
  118 | inline _Tag SecondaryTag(const std::string& content) {
      |             ^~~~~~~~~~~~
      |             secondaryTag
  122 | struct _Comment {
      |        ^
  123 |   _Comment(const std::string& content_) : content(content_) {}
  124 |   std::string content;
  125 | };
      |  
      |   __attribute__((aligned(32)))
  122 | struct _Comment {
      |        ^
note: this fix will not be applied because it overlaps with another fix
note: this fix will not be applied because it overlaps with another fix
  123 |   _Comment(const std::string& content_) : content(content_) {}
      |   ^
      |   explicit 
  123 |   _Comment(const std::string& content_) : content(content_) {}
      |            ^~~~~~~~~~~~~~~~~~                             
      |            std::string                            std::move( )
  124 |   std::string content;
      |               ^
  127 | inline _Comment Comment(const std::string& content) { return _Comment(content); }
      |                 ^
note: this fix will not be applied because it overlaps with another fix
  127 | inline _Comment Comment(const std::string& content) { return _Comment(content); }
      |                 ^~~~~~~
      |                 comment
  127 | inline _Comment Comment(const std::string& content) { return _Comment(content); }
      |                                                              ^
  129 | struct _Precision {
      |        ^
  130 |   _Precision(int floatPrecision_, int doublePrecision_)
  131 |       : floatPrecision(floatPrecision_), doublePrecision(doublePrecision_) {}
  132 | 
  133 |   int floatPrecision;
  134 |   int doublePrecision;
  135 | };
      |  
      |   __attribute__((aligned(8)))
  129 | struct _Precision {
      |        ^
note: this fix will not be applied because it overlaps with another fix
note: this fix will not be applied because it overlaps with another fix
  130 |   _Precision(int floatPrecision_, int doublePrecision_)
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  130 |   _Precision(int floatPrecision_, int doublePrecision_)
      |                  ^~~~~~~~~~~~~~~
  130 |   _Precision(int floatPrecision_, int doublePrecision_)
      |                                       ^~~~~~~~~~~~~~~~
  133 |   int floatPrecision;
      |       ^
  131 |       : floatPrecision(floatPrecision_), doublePrecision(doublePrecision_) {}
      |         ~~~~~~~~~~~~~~
      |         float_precision
  132 | 
  133 |   int floatPrecision;
      |       ^~~~~~~~~~~~~~
      |       float_precision
  134 |   int doublePrecision;
      |       ^
  131 |       : floatPrecision(floatPrecision_), doublePrecision(doublePrecision_) {}
      |                                          ~~~~~~~~~~~~~~~
      |                                          double_precision
  132 | 
  133 |   int floatPrecision;
  134 |   int doublePrecision;
      |       ^~~~~~~~~~~~~~~
      |       double_precision
  137 | inline _Precision FloatPrecision(int n) { return _Precision(n, -1); }
      |                   ^
note: this fix will not be applied because it overlaps with another fix
  137 | inline _Precision FloatPrecision(int n) { return _Precision(n, -1); }
      |                   ^~~~~~~~~~~~~~
      |                   floatPrecision
  137 | inline _Precision FloatPrecision(int n) { return _Precision(n, -1); }
      |                                                  ^~~~~~~~~~~     ~
      |                                                  {               }
  139 | inline _Precision DoublePrecision(int n) { return _Precision(-1, n); }
      |                   ^
note: this fix will not be applied because it overlaps with another fix
  139 | inline _Precision DoublePrecision(int n) { return _Precision(-1, n); }
      |                   ^~~~~~~~~~~~~~~
      |                   doublePrecision
  139 | inline _Precision DoublePrecision(int n) { return _Precision(-1, n); }
      |                                                   ^~~~~~~~~~~     ~
      |                                                   {               }
  141 | inline _Precision Precision(int n) { return _Precision(n, n); }
      |                   ^
note: this fix will not be applied because it overlaps with another fix
  141 | inline _Precision Precision(int n) { return _Precision(n, n); }
      |                   ^~~~~~~~~
      |                   precision
  141 | inline _Precision Precision(int n) { return _Precision(n, n); }
      |                                             ^~~~~~~~~~~    ~
      |                                             {              }
  142 | }
      | ^
      |   // namespace YAML
   12 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   12 |   enum value { Default, Block, Flow };
      |        ^
   14 | }
      | ^
      |   // namespace YAML
   10 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   20 | const char* const YAML_DIRECTIVE_ARGS =
      |                   ^~~~~~~~~~~~~~~~~~~
      |                   yaml_directive_args
   22 | const char* const YAML_VERSION = "bad YAML version: ";
      |                   ^~~~~~~~~~~~
      |                   yaml_version
   23 | const char* const YAML_MAJOR_VERSION = "YAML major version too large";
      |                   ^~~~~~~~~~~~~~~~~~
      |                   yaml_major_version
   24 | const char* const REPEATED_YAML_DIRECTIVE = "repeated YAML directive";
      |                   ^~~~~~~~~~~~~~~~~~~~~~~
      |                   repeated_yaml_directive
   25 | const char* const TAG_DIRECTIVE_ARGS =
      |                   ^~~~~~~~~~~~~~~~~~
      |                   tag_directive_args
   27 | const char* const REPEATED_TAG_DIRECTIVE = "repeated TAG directive";
      |                   ^~~~~~~~~~~~~~~~~~~~~~
      |                   repeated_tag_directive
   28 | const char* const CHAR_IN_TAG_HANDLE =
      |                   ^~~~~~~~~~~~~~~~~~
      |                   char_in_tag_handle
   30 | const char* const TAG_WITH_NO_SUFFIX = "tag handle with no suffix";
      |                   ^~~~~~~~~~~~~~~~~~
      |                   tag_with_no_suffix
   31 | const char* const END_OF_VERBATIM_TAG = "end of verbatim tag not found";
      |                   ^~~~~~~~~~~~~~~~~~~
      |                   end_of_verbatim_tag
   32 | const char* const END_OF_MAP = "end of map not found";
      |                   ^~~~~~~~~~
      |                   end_of_map
   33 | const char* const END_OF_MAP_FLOW = "end of map flow not found";
      |                   ^~~~~~~~~~~~~~~
      |                   end_of_map_flow
   34 | const char* const END_OF_SEQ = "end of sequence not found";
      |                   ^~~~~~~~~~
      |                   end_of_seq
   35 | const char* const END_OF_SEQ_FLOW = "end of sequence flow not found";
      |                   ^~~~~~~~~~~~~~~
      |                   end_of_seq_flow
   36 | const char* const MULTIPLE_TAGS =
      |                   ^~~~~~~~~~~~~
      |                   multiple_tags
   38 | const char* const MULTIPLE_ANCHORS =
      |                   ^~~~~~~~~~~~~~~~
      |                   multiple_anchors
   40 | const char* const MULTIPLE_ALIASES =
      |                   ^~~~~~~~~~~~~~~~
      |                   multiple_aliases
   42 | const char* const ALIAS_CONTENT =
      |                   ^~~~~~~~~~~~~
      |                   alias_content
   44 | const char* const INVALID_HEX = "bad character found while scanning hex number";
      |                   ^~~~~~~~~~~
      |                   invalid_hex
   45 | const char* const INVALID_UNICODE = "invalid unicode: ";
      |                   ^~~~~~~~~~~~~~~
      |                   invalid_unicode
   46 | const char* const INVALID_ESCAPE = "unknown escape character: ";
      |                   ^~~~~~~~~~~~~~
      |                   invalid_escape
   47 | const char* const UNKNOWN_TOKEN = "unknown token";
      |                   ^~~~~~~~~~~~~
      |                   unknown_token
   48 | const char* const DOC_IN_SCALAR = "illegal document indicator in scalar";
      |                   ^~~~~~~~~~~~~
      |                   doc_in_scalar
   49 | const char* const EOF_IN_SCALAR = "illegal EOF in scalar";
      |                   ^~~~~~~~~~~~~
      |                   eof_in_scalar
   50 | const char* const CHAR_IN_SCALAR = "illegal character in scalar";
      |                   ^~~~~~~~~~~~~~
      |                   char_in_scalar
   51 | const char* const TAB_IN_INDENTATION =
      |                   ^~~~~~~~~~~~~~~~~~
      |                   tab_in_indentation
   53 | const char* const FLOW_END = "illegal flow end";
      |                   ^~~~~~~~
      |                   flow_end
   54 | const char* const BLOCK_ENTRY = "illegal block entry";
      |                   ^~~~~~~~~~~
      |                   block_entry
   55 | const char* const MAP_KEY = "illegal map key";
      |                   ^~~~~~~
      |                   map_key
   56 | const char* const MAP_VALUE = "illegal map value";
      |                   ^~~~~~~~~
      |                   map_value
   57 | const char* const ALIAS_NOT_FOUND = "alias not found after *";
      |                   ^~~~~~~~~~~~~~~
      |                   alias_not_found
   58 | const char* const ANCHOR_NOT_FOUND = "anchor not found after &";
      |                   ^~~~~~~~~~~~~~~~
      |                   anchor_not_found
   59 | const char* const CHAR_IN_ALIAS =
      |                   ^~~~~~~~~~~~~
      |                   char_in_alias
   61 | const char* const CHAR_IN_ANCHOR =
      |                   ^~~~~~~~~~~~~~
      |                   char_in_anchor
   63 | const char* const ZERO_INDENT_IN_BLOCK =
      |                   ^~~~~~~~~~~~~~~~~~~~
      |                   zero_indent_in_block
   65 | const char* const CHAR_IN_BLOCK = "unexpected character in block scalar";
      |                   ^~~~~~~~~~~~~
      |                   char_in_block
   66 | const char* const AMBIGUOUS_ANCHOR =
      |                   ^~~~~~~~~~~~~~~~
      |                   ambiguous_anchor
   68 | const char* const UNKNOWN_ANCHOR = "the referenced anchor is not defined: ";
      |                   ^~~~~~~~~~~~~~
      |                   unknown_anchor
   70 | const char* const INVALID_NODE =
      |                   ^~~~~~~~~~~~
      |                   invalid_node
   73 | const char* const INVALID_SCALAR = "invalid scalar";
      |                   ^~~~~~~~~~~~~~
      |                   invalid_scalar
   74 | const char* const KEY_NOT_FOUND = "key not found";
      |                   ^~~~~~~~~~~~~
      |                   key_not_found
   75 | const char* const BAD_CONVERSION = "bad conversion";
      |                   ^~~~~~~~~~~~~~
      |                   bad_conversion
   76 | const char* const BAD_DEREFERENCE = "bad dereference";
      |                   ^~~~~~~~~~~~~~~
      |                   bad_dereference
   77 | const char* const BAD_SUBSCRIPT = "operator[] call on a scalar";
      |                   ^~~~~~~~~~~~~
      |                   bad_subscript
   78 | const char* const BAD_PUSHBACK = "appending to a non-sequence";
      |                   ^~~~~~~~~~~~
      |                   bad_pushback
   79 | const char* const BAD_INSERT = "inserting in a non-convertible-to-map";
      |                   ^~~~~~~~~~
      |                   bad_insert
   81 | const char* const UNMATCHED_GROUP_TAG = "unmatched group tag";
      |                   ^~~~~~~~~~~~~~~~~~~
      |                   unmatched_group_tag
   82 | const char* const UNEXPECTED_END_SEQ = "unexpected end sequence token";
      |                   ^~~~~~~~~~~~~~~~~~
      |                   unexpected_end_seq
   83 | const char* const UNEXPECTED_END_MAP = "unexpected end map token";
      |                   ^~~~~~~~~~~~~~~~~~
      |                   unexpected_end_map
   84 | const char* const SINGLE_QUOTED_CHAR =
      |                   ^~~~~~~~~~~~~~~~~~
      |                   single_quoted_char
   86 | const char* const INVALID_ANCHOR = "invalid anchor";
      |                   ^~~~~~~~~~~~~~
      |                   invalid_anchor
   87 | const char* const INVALID_ALIAS = "invalid alias";
      |                   ^~~~~~~~~~~~~
      |                   invalid_alias
   88 | const char* const INVALID_TAG = "invalid tag";
      |                   ^~~~~~~~~~~
      |                   invalid_tag
   89 | const char* const BAD_FILE = "bad file";
      |                   ^~~~~~~~
      |                   bad_file
   92 | inline const std::string KEY_NOT_FOUND_WITH_KEY(
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
   92 | inline const std::string KEY_NOT_FOUND_WITH_KEY(
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto
   93 |     const T&, typename disable_if<is_numeric<T>>::type* = 0) {
      |                                                              -> const std::string
   92 | inline const std::string KEY_NOT_FOUND_WITH_KEY(
      |                          ^~~~~~~~~~~~~~~~~~~~~~
      |                          keyNotFoundWithKey
   93 |     const T&, typename disable_if<is_numeric<T>>::type* = 0) {
      |             ^
      |              /*unused*/                                  /*unused*/
   97 | inline const std::string KEY_NOT_FOUND_WITH_KEY(const std::string& key) {
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
   97 | inline const std::string KEY_NOT_FOUND_WITH_KEY(const std::string& key) {
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto                                                             -> const std::string
   97 | inline const std::string KEY_NOT_FOUND_WITH_KEY(const std::string& key) {
      |                          ^~~~~~~~~~~~~~~~~~~~~~
      |                          keyNotFoundWithKey
  103 | inline const std::string KEY_NOT_FOUND_WITH_KEY(const char* key) {
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  103 | inline const std::string KEY_NOT_FOUND_WITH_KEY(const char* key) {
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto                                                      -> const std::string
  103 | inline const std::string KEY_NOT_FOUND_WITH_KEY(const char* key) {
      |                          ^~~~~~~~~~~~~~~~~~~~~~
      |                          keyNotFoundWithKey
  110 | inline const std::string KEY_NOT_FOUND_WITH_KEY(
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  110 | inline const std::string KEY_NOT_FOUND_WITH_KEY(
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto
  111 |     const T& key, typename enable_if<is_numeric<T>>::type* = 0) {
      |                                                                 -> const std::string
  110 | inline const std::string KEY_NOT_FOUND_WITH_KEY(
      |                          ^~~~~~~~~~~~~~~~~~~~~~
      |                          keyNotFoundWithKey
  111 |     const T& key, typename enable_if<is_numeric<T>>::type* = 0) {
      |                                                            ^
      |                                                             /*unused*/
  118 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  118 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto
  119 |     const T&, typename disable_if<is_numeric<T>>::type* = nullptr) {
      |                                                                    -> const std::string
  118 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(
      |                          ^~~~~~~~~~~~~~~~~~~~~~
      |                          badSubscriptWithKey
  119 |     const T&, typename disable_if<is_numeric<T>>::type* = nullptr) {
      |             ^
      |              /*unused*/                                  /*unused*/
  123 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(const std::string& key) {
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  123 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(const std::string& key) {
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto                                                             -> const std::string
  123 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(const std::string& key) {
      |                          ^~~~~~~~~~~~~~~~~~~~~~
      |                          badSubscriptWithKey
  129 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(const char* key) {
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  129 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(const char* key) {
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto                                                      -> const std::string
  129 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(const char* key) {
      |                          ^~~~~~~~~~~~~~~~~~~~~~
      |                          badSubscriptWithKey
  136 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  136 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto
  137 |     const T& key, typename enable_if<is_numeric<T>>::type* = nullptr) {
      |                                                                       -> const std::string
  136 | inline const std::string BAD_SUBSCRIPT_WITH_KEY(
      |                          ^~~~~~~~~~~~~~~~~~~~~~
      |                          badSubscriptWithKey
  137 |     const T& key, typename enable_if<is_numeric<T>>::type* = nullptr) {
      |                                                            ^
      |                                                             /*unused*/
  143 | inline const std::string INVALID_NODE_WITH_KEY(const std::string& key) {
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  143 | inline const std::string INVALID_NODE_WITH_KEY(const std::string& key) {
      |        ~~~~~~~~~~~~~~~~~ ^
      |        auto                                                            -> const std::string
  143 | inline const std::string INVALID_NODE_WITH_KEY(const std::string& key) {
      |                          ^~~~~~~~~~~~~~~~~~~~~
      |                          invalidNodeWithKey
  153 | class YAML_CPP_API Exception : public std::runtime_error {
      |                    ^
  161 |   Mark mark;
      |        ^
  162 |   std::string msg;
      |               ^
  165 |   static const std::string build_what(const Mark& mark,
      |   ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  165 |   static const std::string build_what(const Mark& mark,
      |          ~~~~~~~~~~~~~~~~~ ^
      |          auto
  166 |                                       const std::string& msg) {
      |                                                               -> const std::string
  156 |       : std::runtime_error(build_what(mark_, msg_)), mark(mark_), msg(msg_) {}
      |                            ~~~~~~~~~~
      |                            buildWhat
  157 |   ~Exception() YAML_CPP_NOEXCEPT override;
  158 | 
  159 |   Exception(const Exception&) = default;
  160 | 
  161 |   Mark mark;
  162 |   std::string msg;
  163 | 
  164 |  private:
  165 |   static const std::string build_what(const Mark& mark,
      |                            ^~~~~~~~~~
      |                            buildWhat
  178 | class YAML_CPP_API ParserException : public Exception {
      |                    ^
  186 | class YAML_CPP_API RepresentationException : public Exception {
      |                    ^
  195 | class YAML_CPP_API InvalidScalar : public RepresentationException {
      |                    ^
  197 |   InvalidScalar(const Mark& mark_)
      |   ^
      |   explicit 
  203 | class YAML_CPP_API KeyNotFound : public RepresentationException {
      |                    ^
  214 | class YAML_CPP_API TypedKeyNotFound : public KeyNotFound {
      |                    ^
  220 |   T key;
      |     ^
  224 | inline TypedKeyNotFound<T> MakeTypedKeyNotFound(const Mark& mark,
      |        ~~~~~~~~~~~~~~~~~~~ ^
      |        auto
  225 |                                                 const T& key) {
      |                                                               -> TypedKeyNotFound<T>
  224 | inline TypedKeyNotFound<T> MakeTypedKeyNotFound(const Mark& mark,
      |                            ^~~~~~~~~~~~~~~~~~~~
      |                            makeTypedKeyNotFound
  229 | class YAML_CPP_API InvalidNode : public RepresentationException {
      |                    ^
  231 |   InvalidNode(const std::string& key)
      |   ^
      |   explicit 
  238 | class YAML_CPP_API BadConversion : public RepresentationException {
      |                    ^
  252 | class YAML_CPP_API BadDereference : public RepresentationException {
      |                    ^
  260 | class YAML_CPP_API BadSubscript : public RepresentationException {
      |                    ^
  269 | class YAML_CPP_API BadPushback : public RepresentationException {
      |                    ^
  277 | class YAML_CPP_API BadInsert : public RepresentationException {
      |                    ^
  285 | class YAML_CPP_API EmitterException : public Exception {
      |                    ^
  287 |   EmitterException(const std::string& msg_)
      |   ^
      |   explicit 
  293 | class YAML_CPP_API BadFile : public Exception {
      |                    ^
    7 | #pragma once
      | ^
   13 | struct YAML_CPP_API Mark {
      |                     ^
   14 |   Mark() : pos(0), line(0), column(0) {}
   15 | 
   16 |   static const Mark null_mark() { return Mark(-1, -1, -1); }
   17 | 
   18 |   bool is_null() const { return pos == -1 && line == -1 && column == -1; }
   19 | 
   20 |   int pos;
   21 |   int line, column;
   22 | 
   23 |  private:
   24 |   Mark(int pos_, int line_, int column_)
   25 |       : pos(pos_), line(line_), column(column_) {}
   26 | };
      |  
      |   __attribute__((aligned(16)))
   16 |   static const Mark null_mark() { return Mark(-1, -1, -1); }
      |   ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
   16 |   static const Mark null_mark() { return Mark(-1, -1, -1); }
      |          ~~~~~~~~~~ ^
      |          auto                   -> const Mark
   16 |   static const Mark null_mark() { return Mark(-1, -1, -1); }
      |                     ^~~~~~~~~
      |                     nullMark
   18 |   bool is_null() const { return pos == -1 && line == -1 && column == -1; }
      |   ^
      |   [[nodiscard]] 
   18 |   bool is_null() const { return pos == -1 && line == -1 && column == -1; }
      |   ~~~~ ^
      |   auto                 -> bool
   18 |   bool is_null() const { return pos == -1 && line == -1 && column == -1; }
      |        ^~~~~~~
      |        isNull
   20 |   int pos;
      |       ^
   21 |   int line, column;
      |       ^
   21 |   int line, column;
      |             ^
   24 |   Mark(int pos_, int line_, int column_)
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   24 |   Mark(int pos_, int line_, int column_)
      |            ^~~~
   24 |   Mark(int pos_, int line_, int column_)
      |                                 ^~~~~~~
   27 | }
      | ^
      |   // namespace YAML
   12 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   15 | #include <unordered_map>
      | ^        ~~~~~~~~~~~~~~~
   16 | #include <sstream>
      |          ~~~~~~~~~
   17 | #include <type_traits>
      |          ~~~~~~~~~~~~~
   42 | inline bool IsInfinity(const std::string& input) {
      |        ~~~~ ^
      |        auto                                      -> bool
   47 | inline bool IsNegativeInfinity(const std::string& input) {
      |        ~~~~ ^
      |        auto                                              -> bool
   51 | inline bool IsNaN(const std::string& input) {
      |        ~~~~ ^
      |        auto                                 -> bool
   54 | }
      | ^
      |   // namespace conversion
   41 | namespace conversion {
      |           ^
   59 |   static Node encode(const Node& rhs) { return rhs; }
      |          ~~~~ ^
      |          auto                         -> Node
   61 |   static bool decode(const Node& node, Node& rhs) {
      |          ~~~~ ^
      |          auto                                     -> bool
   70 |   static Node encode(const std::string& rhs) { return Node(rhs); }
      |          ~~~~ ^
      |          auto                                -> Node
   72 |   static bool decode(const Node& node, std::string& rhs) {
      |          ~~~~ ^
      |          auto                                            -> bool
   73 |     if (!node.IsScalar())
      |                          ^
      |                           {
   74 |       return false;
      |                    
   83 |   static Node encode(const char* rhs) { return Node(rhs); }
      |          ~~~~ ^
      |          auto                         -> Node
   88 |   static Node encode(const char* rhs) { return Node(rhs); }
      |          ~~~~ ^
      |          auto                         -> Node
   92 | struct convert<char[N]> {
      |                ^
   93 |   static Node encode(const char* rhs) { return Node(rhs); }
      |          ~~~~ ^
      |          auto                         -> Node
   99 |   static Node encode(std::string_view rhs) { return Node(std::string(rhs)); }
      |          ~~~~ ^
      |          auto                              -> Node
  101 |   static bool decode(const Node& node, std::string_view& rhs) {
      |          ~~~~ ^
      |          auto                                                 -> bool
  102 |     if (!node.IsScalar())
      |                          ^
      |                           {
  103 |       return false;
      |                    
  112 |   static Node encode(const _Null& /* rhs */) { return Node(); }
      |          ~~~~ ^
      |          auto                                -> Node
  112 |   static Node encode(const _Null& /* rhs */) { return Node(); }
      |                                                       ^~~~~~
      |                                                       {}
  114 |   static bool decode(const Node& node, _Null& /* rhs */) {
      |          ~~~~ ^
      |          auto                                            -> bool
  121 | typename std::enable_if< std::is_floating_point<T>::value, void>::type
      | ^
note: this fix will not be applied because it overlaps with another fix
  121 | typename std::enable_if< std::is_floating_point<T>::value, void>::type
      |          ^
note: this fix will not be applied because it overlaps with another fix
  121 | typename std::enable_if< std::is_floating_point<T>::value, void>::type
      |                          ^
note: this fix will not be applied because it overlaps with another fix
  122 | inner_encode(const T& rhs, std::stringstream& stream){
      | ^
note: this fix will not be applied because it overlaps with another fix
  137 | typename std::enable_if<!std::is_floating_point<T>::value, void>::type
      | ^
note: this fix will not be applied because it overlaps with another fix
  137 | typename std::enable_if<!std::is_floating_point<T>::value, void>::type
      |          ^
note: this fix will not be applied because it overlaps with another fix
  137 | typename std::enable_if<!std::is_floating_point<T>::value, void>::type
      |                          ^
note: this fix will not be applied because it overlaps with another fix
  138 | inner_encode(const T& rhs, std::stringstream& stream){
      | ^
note: this fix will not be applied because it overlaps with another fix
  143 | typename std::enable_if<(std::is_same<T, unsigned char>::value ||
      | ^
note: this fix will not be applied because it overlaps with another fix
  143 | typename std::enable_if<(std::is_same<T, unsigned char>::value ||
      |          ^
note: this fix will not be applied because it overlaps with another fix
  143 | typename std::enable_if<(std::is_same<T, unsigned char>::value ||
      |                          ^
note: this fix will not be applied because it overlaps with another fix
  144 |                          std::is_same<T, signed char>::value), bool>::type
      |                          ^
note: this fix will not be applied because it overlaps with another fix
  145 | ConvertStreamTo(std::stringstream& stream, T& rhs) {
      | ^
note: this fix will not be applied because it overlaps with another fix
  146 |   int num;
      |       ^  
      |           = 0
  158 | typename std::enable_if<!(std::is_same<T, unsigned char>::value ||
      | ^
note: this fix will not be applied because it overlaps with another fix
  158 | typename std::enable_if<!(std::is_same<T, unsigned char>::value ||
      |          ^
note: this fix will not be applied because it overlaps with another fix
  158 | typename std::enable_if<!(std::is_same<T, unsigned char>::value ||
      |                           ^
note: this fix will not be applied because it overlaps with another fix
  159 |                           std::is_same<T, signed char>::value), bool>::type
      |                           ^
note: this fix will not be applied because it overlaps with another fix
  160 | ConvertStreamTo(std::stringstream& stream, T& rhs) {
      | ^
note: this fix will not be applied because it overlaps with another fix
  161 |   if ((stream >> std::noskipws >> rhs) && (stream >> std::ws).eof()) {
      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |   return static_cast<bool>((stream >> std::noskipws >> rhs) && (stream >> std::ws).eof())
  162 |     return true;
      |     ~~~~~~~^~~~~
  163 |   }
      |   ~
  164 |   return false;
      |   ~~~~~~~~~~~~
  166 | }
      | ^
      |   // namespace conversion
  119 | namespace conversion {
      |           ^
  168 | #define YAML_DEFINE_CONVERT_STREAMABLE(type, negative_op)                  \
      |         ^
  179 |     static bool decode(const Node& node, type& rhs) {                      \
      |                                          ^   
      |                                          (   )
  213 | #define YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(type) \
      |         ^
  216 | #define YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(type) \
      |         ^
  219 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(int);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  219 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(int);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  219 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(int);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  220 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(short);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  220 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(short);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  220 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(short);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  221 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  221 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  221 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  222 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long long);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  222 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long long);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  222 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long long);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  223 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  223 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  223 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  224 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned short);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  224 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned short);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  224 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned short);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  225 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  225 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  225 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  226 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long long);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  226 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long long);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  226 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long long);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  228 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(char);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  228 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(char);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  228 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(char);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  229 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(signed char);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  229 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(signed char);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  229 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(signed char);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  230 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned char);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  230 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned char);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  230 | YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned char);
      | ^
  217 |   YAML_DEFINE_CONVERT_STREAMABLE(type, +)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  232 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(float);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  232 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(float);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  232 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(float);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  233 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(double);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  233 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(double);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  233 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(double);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  234 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long double);
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  196 |         } else if (conversion::IsNegativeInfinity(input)) {                \
      |           ^~~~
  234 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long double);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  186 |       if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
      |                                     ^
  234 | YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long double);
      | ^
  214 |   YAML_DEFINE_CONVERT_STREAMABLE(type, -)
      |   ^
  172 |     static Node encode(const type& rhs) {                                  \
      |                 ^
  243 |   static Node encode(bool rhs) { return rhs ? Node("true") : Node("false"); }
      |          ~~~~ ^
      |          auto                  -> Node
  245 |   YAML_CPP_API static bool decode(const Node& node, bool& rhs);
      |                       ~~~~ ^                                  
      |                       auto                                     -> bool
  251 |   static Node encode(const std::map<K, V, C, A>& rhs) {
      |          ~~~~ ^
      |          auto                                         -> Node
  253 |     for (const auto& element : rhs)
      |     ^
  253 |     for (const auto& element : rhs)
      |                                    ^
      |                                     {
  254 |       node.force_insert(element.first, element.second);
      |                                                        
  258 |   static bool decode(const Node& node, std::map<K, V, C, A>& rhs) {
      |          ~~~~ ^
      |          auto                                                     -> bool
  259 |     if (!node.IsMap())
      |                       ^
      |                        {
  260 |       return false;
      |                    
  263 |     for (const auto& element : node)
      |     ^
  263 |     for (const auto& element : node)
      |                                     ^
      |                                      {
  264 | #if defined(__GNUC__) && __GNUC__ < 4
  265 |       // workaround for GCC 3:
  266 |       rhs[element.first.template as<K>()] = element.second.template as<V>();
  267 | #else
  268 |       rhs[element.first.as<K>()] = element.second.as<V>();
      |                                                           
  277 |   static Node encode(const std::unordered_map<K, V, H, P, A>& rhs) {
      |          ~~~~ ^
      |          auto                                                      -> Node
  279 |     for (const auto& element : rhs)
      |     ^
  279 |     for (const auto& element : rhs)
      |                                    ^
      |                                     {
  280 |       node.force_insert(element.first, element.second);
      |                                                        
  284 |   static bool decode(const Node& node, std::unordered_map<K, V, H, P, A>& rhs) {
      |          ~~~~ ^
      |          auto                                                                  -> bool
  285 |     if (!node.IsMap())
      |                       ^
      |                        {
  286 |       return false;
      |                    
  289 |     for (const auto& element : node)
      |     ^
  289 |     for (const auto& element : node)
      |                                     ^
      |                                      {
  290 | #if defined(__GNUC__) && __GNUC__ < 4
  291 |       // workaround for GCC 3:
  292 |       rhs[element.first.template as<K>()] = element.second.template as<V>();
  293 | #else
  294 |       rhs[element.first.as<K>()] = element.second.as<V>();
      |                                                           
  303 |   static Node encode(const std::vector<T, A>& rhs) {
      |          ~~~~ ^
      |          auto                                      -> Node
  305 |     for (const auto& element : rhs)
      |     ^
  305 |     for (const auto& element : rhs)
      |                                    ^
      |                                     {
  306 |       node.push_back(element);
      |                               
  310 |   static bool decode(const Node& node, std::vector<T, A>& rhs) {
      |          ~~~~ ^
      |          auto                                                  -> bool
  311 |     if (!node.IsSequence())
      |                            ^
      |                             {
  312 |       return false;
      |                    
  315 |     for (const auto& element : node)
      |     ^
  315 |     for (const auto& element : node)
      |                                     ^
      |                                      {
  316 | #if defined(__GNUC__) && __GNUC__ < 4
  317 |       // workaround for GCC 3:
  318 |       rhs.push_back(element.template as<T>());
  319 | #else
  320 |       rhs.push_back(element.as<T>());
      |                                      
  329 |   static Node encode(const std::list<T,A>& rhs) {
      |          ~~~~ ^
      |          auto                                   -> Node
  331 |     for (const auto& element : rhs)
      |     ^
  331 |     for (const auto& element : rhs)
      |                                    ^
      |                                     {
  332 |       node.push_back(element);
      |                               
  336 |   static bool decode(const Node& node, std::list<T,A>& rhs) {
      |          ~~~~ ^
      |          auto                                               -> bool
  337 |     if (!node.IsSequence())
      |                            ^
      |                             {
  338 |       return false;
      |                    
  341 |     for (const auto& element : node)
      |     ^
  341 |     for (const auto& element : node)
      |                                     ^
      |                                      {
  342 | #if defined(__GNUC__) && __GNUC__ < 4
  343 |       // workaround for GCC 3:
  344 |       rhs.push_back(element.template as<T>());
  345 | #else
  346 |       rhs.push_back(element.as<T>());
      |                                      
  355 |   static Node encode(const std::array<T, N>& rhs) {
      |          ~~~~ ^
      |          auto                                     -> Node
  357 |     for (const auto& element : rhs) {
      |     ^
  363 |   static bool decode(const Node& node, std::array<T, N>& rhs) {
      |          ~~~~ ^
      |          auto                                                 -> bool
  368 |     for (auto i = 0u; i < node.size(); ++i) {
      |     ^
  368 |     for (auto i = 0u; i < node.size(); ++i) {
      |                   ^~
      |                    U
  380 |   static bool isNodeValid(const Node& node) {
      |          ~~~~ ^
      |          auto                               -> bool
  389 |   static Node encode(const std::valarray<T>& rhs) {
      |          ~~~~ ^
      |          auto                                     -> Node
  391 |     for (const auto& element : rhs) {
      |     ^
  397 |   static bool decode(const Node& node, std::valarray<T>& rhs) {
      |          ~~~~ ^
      |          auto                                                 -> bool
  403 |     for (auto i = 0u; i < node.size(); ++i) {
      |     ^
  403 |     for (auto i = 0u; i < node.size(); ++i) {
      |                   ^~
      |                    U
  419 |   static Node encode(const std::pair<T, U>& rhs) {
      |          ~~~~ ^
      |          auto                                    -> Node
  426 |   static bool decode(const Node& node, std::pair<T, U>& rhs) {
      |          ~~~~ ^
      |          auto                                                -> bool
  427 |     if (!node.IsSequence())
      |                            ^
      |                             {
  428 |       return false;
      |                    
  429 |     if (node.size() != 2)
      |                          ^
      |                           {
  430 |       return false;
      |                    
  451 |   static Node encode(const Binary& rhs) {
      |          ~~~~ ^
      |          auto                           -> Node
  455 |   static bool decode(const Node& node, Binary& rhs) {
      |          ~~~~ ^
      |          auto                                       -> bool
  456 |     if (!node.IsScalar())
      |                          ^
      |                           {
  457 |       return false;
      |                    
  460 |     if (data.empty() && !node.Scalar().empty())
      |                                                ^
      |                                                 {
  461 |       return false;
      |                    
  467 | }
      | ^
      |   // namespace YAML
   40 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   16 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   17 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   19 | struct get_idx {
      |        ^~~~~~~
      |        GetIdx
   20 |   static node* get(const std::vector<node*>& /* sequence */,
      |          ~~~~~ ^
      |          auto
   21 |                    const Key& /* key */, shared_memory_holder /* pMemory */) {
      |                                                                              -> node*
   21 |                    const Key& /* key */, shared_memory_holder /* pMemory */) {
      |                                                                            ^
      |                                          const               &
   28 |                typename std::enable_if<std::is_unsigned<Key>::value &&
      |                ~~~~~~~~ ^             
      |                                       _t
   29 |                                        !std::is_same<Key, bool>::value>::type> {
      |                                                                        ~~~~~~
   28 |                typename std::enable_if<std::is_unsigned<Key>::value &&
      |                                        ^                    ~~~~~~~
      |                                                        _v
   29 |                                        !std::is_same<Key, bool>::value>::type> {
      |                                         ^                      ~~~~~~~
      |                                                     _v
   30 |   static node* get(const std::vector<node*>& sequence, const Key& key,
      |          ~~~~~ ^
      |          auto
   31 |                    shared_memory_holder /* pMemory */) {
      |                                                        -> node*
   31 |                    shared_memory_holder /* pMemory */) {
      |                                                      ^
      |                    const               &
   35 |   static node* get(std::vector<node*>& sequence, const Key& key,
      |          ~~~~~ ^
      |          auto
   36 |                    shared_memory_holder pMemory) {
      |                                                  -> node*
   36 |                    shared_memory_holder pMemory) {
      |                                         ^
      |                    const               &
   37 |     if (key > sequence.size() || (key > 0 && !sequence[key - 1]->is_defined()))
      |                                                                                ^
      |                                                                                 {
   38 |       return nullptr;
      |                      
   39 |     if (key == sequence.size())
      |                                ^
      |                                 {
   40 |       sequence.push_back(&pMemory->create_node());
      |                                                   
   46 | struct get_idx<Key, typename std::enable_if<std::is_signed<Key>::value>::type> {
      |                     ~~~~~~~~ ^                                         ~~~~~~
      |                                            _t
   46 | struct get_idx<Key, typename std::enable_if<std::is_signed<Key>::value>::type> {
      |                                             ^                  ~~~~~~~
      |                                                           _v
   47 |   static node* get(const std::vector<node*>& sequence, const Key& key,
      |          ~~~~~ ^
      |          auto
   48 |                    shared_memory_holder pMemory) {
      |                                                  -> node*
   15 |                           sequence, static_cast<std::size_t>(key), pMemory)
      |                                                                    ^      
      |                                                                    std::move( )
   53 |   static node* get(std::vector<node*>& sequence, const Key& key,
      |          ~~~~~ ^
      |          auto
   54 |                    shared_memory_holder pMemory) {
      |                                                  -> node*
   56 |                           sequence, static_cast<std::size_t>(key), pMemory)
      |                                                                    ^      
      |                                                                    std::move( )
   62 | struct remove_idx {
      |        ^~~~~~~~~~
      |        RemoveIdx
   63 |   static bool remove(std::vector<node*>&, const Key&, std::size_t&) {
      |          ~~~~ ^
      |          auto                                                       -> bool
   63 |   static bool remove(std::vector<node*>&, const Key&, std::size_t&) {
      |                                         ^                         
      |                                          /*unused*/  /*unused*/    /*unused*/
   70 |     Key, typename std::enable_if<std::is_unsigned<Key>::value &&
      |          ~~~~~~~~ ^             
      |                                 _t
   71 |                                  !std::is_same<Key, bool>::value>::type> {
      |                                                                  ~~~~~~
   70 |     Key, typename std::enable_if<std::is_unsigned<Key>::value &&
      |                                  ^                    ~~~~~~~
      |                                                  _v
   71 |                                  !std::is_same<Key, bool>::value>::type> {
      |                                   ^                      ~~~~~~~
      |                                               _v
   73 |   static bool remove(std::vector<node*>& sequence, const Key& key,
      |          ~~~~ ^
      |          auto
   74 |                      std::size_t& seqSize) {
      |                                            -> bool
   77 |     } else {
      |       ^~~~~~
   78 |       sequence.erase(sequence.begin() + key);
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   79 |       if (seqSize > key) {
      |       ~~~~~~~~~~~~~~~~~~~~
   80 |           --seqSize;
      |           ~~~~~~~~~~
   81 |       }
      |       ~
   82 |       return true;
      |       ~~~~~~~~~~~~
   83 |     }
      |     ~
   89 |                   typename std::enable_if<std::is_signed<Key>::value>::type> {
      |                   ~~~~~~~~ ^                                         ~~~~~~
      |                                          _t
   89 |                   typename std::enable_if<std::is_signed<Key>::value>::type> {
      |                                           ^                  ~~~~~~~
      |                                                         _v
   91 |   static bool remove(std::vector<node*>& sequence, const Key& key,
      |          ~~~~ ^
      |          auto
   92 |                      std::size_t& seqSize) {
      |                                            -> bool
  100 | inline bool node::equals(const T& rhs, shared_memory_holder pMemory) {
      |        ~~~~       ^
      |        auto                                                          -> bool
  102 |   if (convert<T>::decode(Node(*this, pMemory), lhs)) {
      |                                      ^      
      |                                      std::move( )
  108 | inline bool node::equals(const char* rhs, shared_memory_holder pMemory) {
      |        ~~~~       ^
      |        auto                                                             -> bool
  118 | inline node* node_data::get(const Key& key,
      |        ~~~~~            ^
      |        auto
  119 |                             shared_memory_holder pMemory) const {
      |                                                                 -> node*
  127 |       if (node* pNode = get_idx<Key>::get(m_sequence, key, pMemory))
      |                 ^~~~~
      |                 p_node
  128 |         return pNode;
      |                ~~~~~
      |                p_node
  127 |       if (node* pNode = get_idx<Key>::get(m_sequence, key, pMemory))
      |                                                                     ^
      |                                                                      {
  128 |         return pNode;
      |                      
  134 |   auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      |        ^
  134 |   auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      |                                                      ^
      |                                                                           -> auto
  134 |   auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      |                                                                        ^
  142 | inline node& node_data::get(const Key& key, shared_memory_holder pMemory) {
      |        ~~~~~            ^
      |        auto                                                               -> node&
  149 |       if (node* pNode = get_idx<Key>::get(m_sequence, key, pMemory)) {
      |                 ^~~~~
      |                 p_node
  150 |         m_type = NodeType::Sequence;
  151 |         return *pNode;
      |                 ~~~~~
      |                 p_node
  160 |   auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      |        ^
  160 |   auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      |                                                      ^
      |                                                                           -> auto
  160 |   auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      |                                                                        ^
  168 |   node& k = convert_to_node(key, pMemory);
      |         ^
  169 |   node& v = pMemory->create_node();
      |         ^
  175 | inline bool node_data::remove(const Key& key, shared_memory_holder pMemory) {
      |        ~~~~            ^
      |        auto                                                                 -> bool
  181 |     kv_pairs::iterator it = m_undefinedPairs.begin();
      |     ^~~~~~~~~~~~~~~~~~
      |     auto
  181 |     kv_pairs::iterator it = m_undefinedPairs.begin();
      |                        ^
  182 |     while (it != m_undefinedPairs.end()) {
      |     ^
  182 |     while (it != m_undefinedPairs.end()) {
      |            ^
  181 |     kv_pairs::iterator it = m_undefinedPairs.begin();
      |     ^
  183 |       kv_pairs::iterator jt = std::next(it);
      |       ^~~~~~~~~~~~~~~~~~
      |       auto
  183 |       kv_pairs::iterator jt = std::next(it);
      |       ^
      |                          const 
  183 |       kv_pairs::iterator jt = std::next(it);
      |                          ^
  190 |     auto iter = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      |                                                          ^
      |                                                                               -> auto
  190 |     auto iter = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      |                                                                            ^
  219 |   node& k = convert_to_node(key, pMemory);
      |         ^
  220 |   node& v = convert_to_node(value, pMemory);
      |         ^
  225 | inline node& node_data::convert_to_node(const T& rhs,
      |        ~~~~~            ^
      |        auto
  226 |                                         shared_memory_holder pMemory) {
      |                                                                       -> node&
  226 |                                         shared_memory_holder pMemory) {
      |                                                              ^
      |                                         const               &
  232 | }
      | ^
      |   // namespace detail
   17 | namespace detail {
      |           ^
  233 | }
      | ^
      |   // namespace YAML
   16 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   18 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   19 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   28 |   struct enabler {};
      |          ^~~~~~~
      |          Enabler
   31 |   struct proxy {
      |          ^~~~~
      |          Proxy
   32 |     explicit proxy(const V& x) : m_ref(x) {}
      |              ~~~~~
      |              Proxy
   32 |     explicit proxy(const V& x) : m_ref(x) {}
      |                             ^
   33 |     V* operator->() { return std::addressof(m_ref); }
      |     ~~ ^
      |     auto            -> V*
   34 |     operator V*() { return std::addressof(m_ref); }
      |     ^
      |     explicit 
   36 |     V m_ref;
      |       ^
   46 |  public:
      |  ^~~~~~~
   39 |  public:
      |  ^
   47 |   iterator_base() : m_iterator(), m_pMemory() {}
      |                     ^~~~~~~~~~~~
   47 |   iterator_base() : m_iterator(), m_pMemory() {}
      |                                   ^~~~~~~~~~~
   16 |   explicit iterator_base(base_type rhs, shared_memory_holder pMemory)
      |                                         ^
   17 |       : m_iterator(rhs), m_pMemory(pMemory) {}
      |                                           
      |                                    std::move( )
   16 |       : m_iterator(rhs), m_pMemory(pMemory) {}
      |                                    ^      
      |                                    std::move( )
   52 |   iterator_base(const iterator_base<W>& rhs,
      |   ^
      |   explicit 
   53 |                 typename std::enable_if<std::is_convertible<W*, V*>::value,
      |                 ~~~~~~~~ ^             
      |                                        _t
   54 |                                         enabler>::type = enabler())
      |                                                 ~~~~~~
   53 |                 typename std::enable_if<std::is_convertible<W*, V*>::value,
      |                                         ^                          ~~~~~~~
      |                                                            _v
   54 |                                         enabler>::type = enabler())
      |                                                        ^
      |                                                         /*unused*/
   57 |   iterator_base<V>& operator++() {
      |   ~~~~~~~~~~~~~~~~~ ^
      |   auto                           -> iterator_base<V>&
   62 |   iterator_base<V> operator++(int) {
      |   ~~~~~~~~~~~~~~~~ ^
      |   auto                             -> iterator_base<V>
   69 |   bool operator==(const iterator_base<W>& rhs) const {
      |   ~~~~ ^
      |   auto                                               -> bool
   74 |   bool operator!=(const iterator_base<W>& rhs) const {
      |   ~~~~ ^
      |   auto                                               -> bool
   78 |   value_type operator*() const {
      |   ~~~~~~~~~~ ^
      |   auto                         -> value_type
   79 |     const typename base_type::value_type& v = *m_iterator;
      |                                           ^
   80 |     if (v.pNode)
      |         ^      
      |                 != nullptr
   80 |     if (v.pNode)
      |                 ^
      |                  {
   81 |       return value_type(Node(*v, m_pMemory));
      |                                              
   82 |     if (v.first && v.second)
      |         ^
      |         (       != nullptr)
   82 |     if (v.first && v.second)
      |                    ^       
      |                    (        != nullptr)
   82 |     if (v.first && v.second)
      |                             ^
      |                              {
   83 |       return value_type(Node(*v.first, m_pMemory), Node(*v.second, m_pMemory));
      |                                                                                
   87 |   proxy operator->() const { return proxy(**this); }
      |         ^
note: this fix will not be applied because it overlaps with another fix
   90 |   base_type m_iterator;
      |             ^
note: this fix will not be applied because it overlaps with another fix
   91 |   shared_memory_holder m_pMemory;
      |                        ^
note: this fix will not be applied because it overlaps with another fix
    7 | #pragma once
      | ^
   17 | namespace detail {
      |           ^
note: this fix will not be applied because it overlaps with another fix
   18 | struct iterator_value;
      |        ^~~~~~~~~~~~~~
      |        IteratorValue
   19 | template <typename V>
   20 | class iterator_base;
   21 | }
   22 | 
   23 | using iterator = detail::iterator_base<detail::iterator_value>;
      |                                                ~~~~~~~~~~~~~~
      |                                                IteratorValue
   24 | using const_iterator = detail::iterator_base<const detail::iterator_value>;
      |                                                            ~~~~~~~~~~~~~~
      |                                                            IteratorValue
   20 | class iterator_base;
      |       ^
note: this fix will not be applied because it overlaps with another fix
   21 | }
      | ^
      |   // namespace detail
   17 | namespace detail {
      |           ^
   25 | }
      | ^
      |   // namespace YAML
   15 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   15 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   16 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   17 | class node;
   18 | }  // namespace detail
      | ~~~~~~~~~~~~~~~~~~~~~~
      | } // namespace YAML::detail
   19 | }  // namespace YAML
      | ~~~~~~~~~~~~~~~~~~~~
   21 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   22 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   25 |   memory() : m_nodes{} {}
      |              ^~~~~~~~~
   26 |   node& create_node();
      |   ~~~~~ ^            
      |   auto                -> node&
   26 |   node& create_node();
      |         ^~~~~~~~~~~
      |         createNode
   27 |   void merge(const memory& rhs);
   28 | 
   29 |  private:
   30 |   using Nodes = std::set<shared_node>;
   31 |   Nodes m_nodes;
   32 | };
   33 | 
   34 | class YAML_CPP_API memory_holder {
   35 |  public:
   36 |   memory_holder() : m_pMemory(new memory) {}
   37 | 
   38 |   node& create_node() { return m_pMemory->create_node(); }
      |                                           ~~~~~~~~~~~
      |                                           createNode
   31 |   Nodes m_nodes;
      |         ^
note: this fix will not be applied because it overlaps with another fix
   38 |   node& create_node() { return m_pMemory->create_node(); }
      |   ~~~~~ ^
      |   auto                -> node&
   38 |   node& create_node() { return m_pMemory->create_node(); }
      |         ^~~~~~~~~~~
      |         createNode
   36 |   memory_holder() : m_pMemory(new memory) {}
      |                     ~~~~~~~~~
      |                     m_pMemory_
   37 | 
   38 |   node& create_node() { return m_pMemory->create_node(); }
      |                                ~~~~~~~~~
      |                                m_pMemory_
   39 |   void merge(memory_holder& rhs);
   40 | 
   41 |  private:
   42 |   shared_memory m_pMemory;
      |                 ^~~~~~~~~
      |                 m_pMemory_
    7 | #pragma once
      | ^
   15 | #include <set>
      | ^        ~~~~~
   16 | #include <atomic>
      |          ~~~~~~~~
   18 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   19 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   20 | class node {
      |       ^
   22 |   struct less {
      |          ^~~~
      |          Less
   23 |     bool operator ()(const node* l, const node* r) const {return l->m_index < r->m_index;}
      |     ~~~~ ^
      |     auto                                                 -> bool
   23 |     bool operator ()(const node* l, const node* r) const {return l->m_index < r->m_index;}
      |                                  ^
   23 |     bool operator ()(const node* l, const node* r) const {return l->m_index < r->m_index;}
      |                                                 ^
   27 |   node() : m_pRef(new node_ref), m_dependencies{}, m_index{} {}
      |                                  ^~~~~~~~~~~~~~~~
   29 |   node& operator=(const node&) = delete;
      |   ~~~~~ ^
      |   auto                         -> node&
   31 |   bool is(const node& rhs) const { return m_pRef == rhs.m_pRef; }
      |   ^
      |   [[nodiscard]] 
   31 |   bool is(const node& rhs) const { return m_pRef == rhs.m_pRef; }
      |   ~~~~ ^
      |   auto                           -> bool
   32 |   const node_ref* ref() const { return m_pRef.get(); }
      |   ^
      |   [[nodiscard]] 
   32 |   const node_ref* ref() const { return m_pRef.get(); }
      |   ~~~~~~~~~~~~~~~ ^
      |   auto                        -> const node_ref*
   34 |   bool is_defined() const { return m_pRef->is_defined(); }
      |   ^
      |   [[nodiscard]] 
   34 |   bool is_defined() const { return m_pRef->is_defined(); }
      |   ~~~~ ^
      |   auto                    -> bool
   34 |   bool is_defined() const { return m_pRef->is_defined(); }
      |        ^~~~~~~~~~
      |        isDefined
   35 |   const Mark& mark() const { return m_pRef->mark(); }
   36 |   NodeType::value type() const { return m_pRef->type(); }
   37 | 
   38 |   const std::string& scalar() const { return m_pRef->scalar(); }
   39 |   const std::string& tag() const { return m_pRef->tag(); }
   40 |   EmitterStyle::value style() const { return m_pRef->style(); }
   41 | 
   42 |   template <typename T>
   43 |   bool equals(const T& rhs, shared_memory_holder pMemory);
   44 |   bool equals(const char* rhs, shared_memory_holder pMemory);
   45 | 
   46 |   void mark_defined() {
   47 |     if (is_defined())
      |         ~~~~~~~~~~
      |         isDefined
   35 |   const Mark& mark() const { return m_pRef->mark(); }
      |   ^
      |   [[nodiscard]] 
   35 |   const Mark& mark() const { return m_pRef->mark(); }
      |   ~~~~~~~~~~~ ^
      |   auto                     -> const Mark&
   36 |   NodeType::value type() const { return m_pRef->type(); }
      |   ^
      |   [[nodiscard]] 
   36 |   NodeType::value type() const { return m_pRef->type(); }
      |   ~~~~~~~~~~~~~~~ ^
      |   auto                         -> NodeType::value
   38 |   const std::string& scalar() const { return m_pRef->scalar(); }
      |   ^
      |   [[nodiscard]] 
   38 |   const std::string& scalar() const { return m_pRef->scalar(); }
      |   ~~~~~~~~~~~~~~~~~~ ^
      |   auto                              -> const std::string&
   39 |   const std::string& tag() const { return m_pRef->tag(); }
      |   ^
      |   [[nodiscard]] 
   39 |   const std::string& tag() const { return m_pRef->tag(); }
      |   ~~~~~~~~~~~~~~~~~~ ^
      |   auto                           -> const std::string&
   40 |   EmitterStyle::value style() const { return m_pRef->style(); }
      |   ^
      |   [[nodiscard]] 
   40 |   EmitterStyle::value style() const { return m_pRef->style(); }
      |   ~~~~~~~~~~~~~~~~~~~ ^
      |   auto                              -> EmitterStyle::value
   43 |   bool equals(const T& rhs, shared_memory_holder pMemory);
      |   ~~~~ ^                                                 
      |   auto                                                    -> bool
   44 |   bool equals(const char* rhs, shared_memory_holder pMemory);
      |   ~~~~ ^                                                    
      |   auto                                                       -> bool
   46 |   void mark_defined() {
      |        ^
   52 |       dependency->mark_defined();
      |       ^
   46 |   void mark_defined() {
      |        ^~~~~~~~~~~~
      |        markDefined
   47 |     if (is_defined())
   48 |       return;
   49 | 
   50 |     m_pRef->mark_defined();
   51 |     for (node* dependency : m_dependencies)
   52 |       dependency->mark_defined();
      |                   ~~~~~~~~~~~~
      |                   markDefined
   53 |     m_dependencies.clear();
   54 |   }
   55 | 
   56 |   void add_dependency(node& rhs) {
   57 |     if (is_defined())
   58 |       rhs.mark_defined();
      |           ~~~~~~~~~~~~
      |           markDefined
   47 |     if (is_defined())
      |                      ^
      |                       {
   48 |       return;
      |              
   51 |     for (node* dependency : m_dependencies)
      |     ^
   51 |     for (node* dependency : m_dependencies)
      |                                            ^
      |                                             {
   52 |       dependency->mark_defined();
      |                                  
   56 |   void add_dependency(node& rhs) {
      |        ^~~~~~~~~~~~~~
      |        addDependency
   57 |     if (is_defined())
      |                      ^
      |                       {
   58 |       rhs.mark_defined();
   59 |     else
      |     } 
   59 |     else
      |         ^
      |          {
   60 |       m_dependencies.insert(&rhs);
      |                                   
   63 |   void set_ref(const node& rhs) {
      |        ^~~~~~~
      |        setRef
   64 |     if (rhs.is_defined())
      |                          ^
      |                           {
   65 |       mark_defined();
      |                      
   68 |   void set_data(const node& rhs) {
      |        ^~~~~~~~
      |        setData
   69 |     if (rhs.is_defined())
      |                          ^
      |                           {
   70 |       mark_defined();
      |                      
   74 |   void set_mark(const Mark& mark) { m_pRef->set_mark(mark); }
      |        ^~~~~~~~
      |        setMark
   76 |   void set_type(NodeType::value type) {
      |        ^~~~~~~~
      |        setType
   77 |     if (type != NodeType::Undefined)
      |                                     ^
      |                                      {
   78 |       mark_defined();
      |                      
   81 |   void set_null() {
      |        ^~~~~~~~
      |        setNull
   85 |   void set_scalar(const std::string& scalar) {
      |        ^~~~~~~~~~
      |        setScalar
   89 |   void set_tag(const std::string& tag) {
      |        ^~~~~~~
      |        setTag
   95 |   void set_style(EmitterStyle::value style) {
      |        ^~~~~~~~~
      |        setStyle
  101 |   std::size_t size() const { return m_pRef->size(); }
      |   ^
      |   [[nodiscard]] 
  101 |   std::size_t size() const { return m_pRef->size(); }
      |   ~~~~~~~~~~~ ^
      |   auto                     -> std::size_t
  103 |   const_node_iterator begin() const {
      |   ^
      |   [[nodiscard]] 
  103 |   const_node_iterator begin() const {
      |   ~~~~~~~~~~~~~~~~~~~ ^
      |   auto                              -> const_node_iterator
  106 |   node_iterator begin() { return m_pRef->begin(); }
      |   ~~~~~~~~~~~~~ ^
      |   auto                  -> node_iterator
  108 |   const_node_iterator end() const {
      |   ^
      |   [[nodiscard]] 
  108 |   const_node_iterator end() const {
      |   ~~~~~~~~~~~~~~~~~~~ ^
      |   auto                            -> const_node_iterator
  111 |   node_iterator end() { return m_pRef->end(); }
      |   ~~~~~~~~~~~~~ ^
      |   auto                -> node_iterator
  114 |   void push_back(node& input, shared_memory_holder pMemory) {
      |        ^~~~~~~~~
      |        pushBack
   17 |     m_pRef->push_back(input, pMemory);
      |                              ^      
      |                              std::move( )
  120 |     m_pRef->insert(key, value, pMemory);
      |                                ^      
      |                                std::move( )
  127 |   node* get(const Key& key, shared_memory_holder pMemory) const {
      |   ~~~~~ ^
      |   auto                                                          -> node*
  134 |   node& get(const Key& key, shared_memory_holder pMemory) {
      |   ~~~~~ ^
      |   auto                                                    -> node&
  140 |   bool remove(const Key& key, shared_memory_holder pMemory) {
      |   ~~~~ ^
      |   auto                                                      -> bool
  144 |   node* get(node& key, shared_memory_holder pMemory) const {
      |   ~~~~~ ^
      |   auto                                                     -> node*
  148 |     return static_cast<const node_ref&>(*m_pRef).get(key, pMemory);
      |                                                           ^      
      |                                                           std::move( )
  150 |   node& get(node& key, shared_memory_holder pMemory) {
      |   ~~~~~ ^
      |   auto                                               -> node&
  151 |     node& value = m_pRef->get(key, pMemory);
      |                                    ^      
      |                                    std::move( )
  156 |   bool remove(node& key, shared_memory_holder pMemory) {
      |   ~~~~ ^
      |   auto                                                 -> bool
  157 |     return m_pRef->remove(key, pMemory);
      |                                ^      
      |                                std::move( )
  162 |   void force_insert(const Key& key, const Value& value,
      |        ^~~~~~~~~~~~
      |        forceInsert
   27 |     return m_pRef->remove(key, pMemory);
      |            ~~~~~~
      |            m_pRef_
   28 |   }
   29 | 
   30 |   // map
   31 |   template <typename Key, typename Value>
   32 |   void force_insert(const Key& key, const Value& value,
   33 |                     shared_memory_holder pMemory) {
   34 |     m_pRef->force_insert(key, value, pMemory);
      |     ~~~~~~
      |     m_pRef_
   35 |   }
   36 | 
   37 |  private:
   38 |   shared_node_ref m_pRef;
      |                   ^~~~~~
      |                   m_pRef_
  170 |   nodes m_dependencies;
      |         ^
note: this fix will not be applied because it overlaps with another fix
   27 |   size_t m_index;
      |          ^      
      |                 {}
note: this fix will not be applied because it overlaps with another fix
    7 | #pragma once
      | ^
   22 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   23 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   24 | class node;
   25 | }  // namespace detail
      | ~~~~~~~~~~~~~~~~~~~~~~
      | } // namespace YAML::detail
   26 | }  // namespace YAML
      | ~~~~~~~~~~~~~~~~~~~~
   28 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   29 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   30 | class YAML_CPP_API node_data {
      |                    ^
   34 |   node_data& operator=(const node_data&) = delete;
      |   ~~~~~~~~~~ ^
      |   auto                                   -> node_data&
   36 |   void mark_defined();
      |        ^~~~~~~~~~~~
      |        markDefined
   37 |   void set_mark(const Mark& mark);
      |        ^~~~~~~~
      |        setMark
   38 |   void set_type(NodeType::value type);
      |        ^~~~~~~~
      |        setType
   39 |   void set_tag(const std::string& tag);
      |        ^~~~~~~
      |        setTag
   40 |   void set_null();
      |        ^~~~~~~~
      |        setNull
   41 |   void set_scalar(const std::string& scalar);
      |        ^~~~~~~~~~
      |        setScalar
   42 |   void set_style(EmitterStyle::value style);
      |        ^~~~~~~~~
      |        setStyle
   44 |   bool is_defined() const { return m_isDefined; }
      |   ~~~~ ^
      |   auto                    -> bool
   44 |   bool is_defined() const { return m_isDefined; }
      |        ^~~~~~~~~~
      |        isDefined
   45 |   const Mark& mark() const { return m_mark; }
      |   ~~~~~~~~~~~ ^
      |   auto                     -> const Mark&
   46 |   NodeType::value type() const {
      |   ~~~~~~~~~~~~~~~ ^
      |   auto                         -> NodeType::value
   49 |   const std::string& scalar() const { return m_scalar; }
      |   ~~~~~~~~~~~~~~~~~~ ^
      |   auto                              -> const std::string&
   50 |   const std::string& tag() const { return m_tag; }
      |   ~~~~~~~~~~~~~~~~~~ ^
      |   auto                           -> const std::string&
   51 |   EmitterStyle::value style() const { return m_style; }
      |   ~~~~~~~~~~~~~~~~~~~ ^
      |   auto                              -> EmitterStyle::value
   54 |   std::size_t size() const;
      |   ~~~~~~~~~~~ ^           
      |   auto                     -> std::size_t
   56 |   const_node_iterator begin() const;
      |   ~~~~~~~~~~~~~~~~~~~ ^            
      |   auto                              -> const_node_iterator
   57 |   node_iterator begin();
      |   ~~~~~~~~~~~~~ ^      
      |   auto                  -> node_iterator
   59 |   const_node_iterator end() const;
      |   ~~~~~~~~~~~~~~~~~~~ ^          
      |   auto                            -> const_node_iterator
   60 |   node_iterator end();
      |   ~~~~~~~~~~~~~ ^    
      |   auto                -> node_iterator
   63 |   void push_back(node& node, const shared_memory_holder& pMemory);
      |        ^~~~~~~~~
      |        pushBack
   68 |   node* get(const Key& key, shared_memory_holder pMemory) const;
      |   ~~~~~ ^                                                      
      |   auto                                                          -> node*
   70 |   node& get(const Key& key, shared_memory_holder pMemory);
      |   ~~~~~ ^                                                
      |   auto                                                    -> node&
   72 |   bool remove(const Key& key, shared_memory_holder pMemory);
      |   ~~~~ ^                                                   
      |   auto                                                      -> bool
   74 |   node* get(node& key, const shared_memory_holder& pMemory) const;
      |   ~~~~~ ^                                                        
      |   auto                                                            -> node*
   75 |   node& get(node& key, const shared_memory_holder& pMemory);
      |   ~~~~~ ^                                                  
      |   auto                                                      -> node&
   76 |   bool remove(node& key, const shared_memory_holder& pMemory);
      |   ~~~~ ^                                                     
      |   auto                                                        -> bool
   80 |   void force_insert(const Key& key, const Value& value,
      |        ^~~~~~~~~~~~
      |        forceInsert
   83 |  public:
      |  ^~~~~~~
   31 |  public:
      |  ^
   84 |   static const std::string& empty_scalar();
      |          ~~~~~~~~~~~~~~~~~~ ^             
      |          auto                              -> const std::string&
   84 |   static const std::string& empty_scalar();
      |                             ^~~~~~~~~~~~
      |                             emptyScalar
   87 |   void compute_seq_size() const;
      |        ^~~~~~~~~~~~~~~~
      |        computeSeqSize
   88 |   void compute_map_size() const;
      |        ^~~~~~~~~~~~~~~~
      |        computeMapSize
   90 |   void reset_sequence();
      |        ^~~~~~~~~~~~~~
      |        resetSequence
   91 |   void reset_map();
      |        ^~~~~~~~~
      |        resetMap
   93 |   void insert_map_pair(node& key, node& value);
      |        ^~~~~~~~~~~~~~~
      |        insertMapPair
   94 |   void convert_to_map(const shared_memory_holder& pMemory);
      |        ^~~~~~~~~~~~~~
      |        convertToMap
   95 |   void convert_sequence_to_map(const shared_memory_holder& pMemory);
      |        ^~~~~~~~~~~~~~~~~~~~~~~
      |        convertSequenceToMap
   98 |   static node& convert_to_node(const T& rhs, shared_memory_holder pMemory);
      |          ~~~~~ ^                                                          
      |          auto                                                              -> node&
   98 |   static node& convert_to_node(const T& rhs, shared_memory_holder pMemory);
      |                ^~~~~~~~~~~~~~~
      |                convertToNode
  100 |  private:
      |  ^~~~~~~~
   86 |  private:
      |  ^
   44 |   bool m_isDefined;
      |        ^~~~~~~~~~~
      |        m_isDefined_
   45 |   Mark m_mark;
      |        ^~~~~~
      |        m_mark_
   47 |   NodeType::value m_type;
      |                   ^~~~~~
      |                   m_type_
   50 |   std::string m_tag;
      |               ^~~~~
      |               m_tag_
   51 |   EmitterStyle::value m_style;
      |                       ^~~~~~~
      |                       m_style_
   49 |   std::string m_scalar;
      |               ^~~~~~~~
      |               m_scalar_
  112 |   node_seq m_sequence;
      |            ^~~~~~~~~~
      |            m_sequence_
  114 |   mutable std::size_t m_seqSize;
      |                       ^~~~~~~~~
      |                       m_seqSize_
  118 |   node_map m_map;
      |            ^~~~~
      |            m_map_
  122 |   mutable kv_pairs m_undefinedPairs;
      |                    ^~~~~~~~~~~~~~~~
      |                    m_undefinedPairs_
  124 | }
      | ^
      |   // namespace detail
   29 | namespace detail {
      |           ^
  125 | }
      | ^
      |   // namespace YAML
   28 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   14 | #include <memory>
      | ^        ~~~~~~~~
   15 | #include <map>
      |          ~~~~~
   19 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   20 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   21 | struct iterator_type {
      |        ^~~~~~~~~~~~~
      |        IteratorType
   22 |   enum value { NoneType, Sequence, Map };
      |        ^
   26 | struct node_iterator_value : public std::pair<V*, V*> {
      |        ^
   27 |   using kv = std::pair<V*, V*>;
   28 | 
   29 |   node_iterator_value() : kv(), pNode(nullptr) {}
   30 |   explicit node_iterator_value(V& rhs) : kv(), pNode(&rhs) {}
   31 |   explicit node_iterator_value(V& key, V& value) : kv(&key, &value), pNode(nullptr) {}
   32 | 
   33 |   V& operator*() const { return *pNode; }
   34 |   V& operator->() const { return *pNode; }
   35 | 
   36 |   V* pNode;
   37 | };
      |  
      |   __attribute__((packed))
   26 | struct node_iterator_value : public std::pair<V*, V*> {
      |        ^
note: this fix will not be applied because it overlaps with another fix
   33 |   V& operator*() const { return *pNode; }
      |   ~~ ^
      |   auto                 -> V&
   34 |   V& operator->() const { return *pNode; }
      |   ~~ ^
      |   auto                  -> V&
   36 |   V* pNode;
      |      ^
   29 |   node_iterator_value() : kv(), pNode(nullptr) {}
      |                                 ~~~~~
      |                                 p_node
   30 |   explicit node_iterator_value(V& rhs) : kv(), pNode(&rhs) {}
      |                                                ~~~~~
      |                                                p_node
   31 |   explicit node_iterator_value(V& key, V& value) : kv(&key, &value), pNode(nullptr) {}
      |                                                                      ~~~~~
      |                                                                      p_node
   32 | 
   33 |   V& operator*() const { return *pNode; }
      |                                  ~~~~~
      |                                  p_node
   34 |   V& operator->() const { return *pNode; }
      |                                   ~~~~~
      |                                   p_node
   35 | 
   36 |   V* pNode;
      |      ^~~~~
      |      p_node
   43 | struct node_iterator_type {
      |        ^~~~~~~~~~~~~~~~~~
      |        NodeIteratorType
   55 | class node_iterator_base {
      |       ^
note: this fix will not be applied because it overlaps with another fix
   57 |   struct enabler {};
      |          ^~~~~~~
      |          Enabler
   59 |   struct proxy {
      |          ^~~~~
      |          Proxy
   60 |     explicit proxy(const node_iterator_value<V>& x) : m_ref(x) {}
      |              ~~~~~
      |              Proxy
   60 |     explicit proxy(const node_iterator_value<V>& x) : m_ref(x) {}
      |                                                  ^
   61 |     node_iterator_value<V>* operator->() { return std::addressof(m_ref); }
      |     ~~~~~~~~~~~~~~~~~~~~~~~ ^
      |     auto                                 -> node_iterator_value<V>*
   62 |     operator node_iterator_value<V>*() { return std::addressof(m_ref); }
      |     ^
      |     explicit 
   64 |     node_iterator_value<V> m_ref;
      |                            ^
   83 |   explicit node_iterator_base(MapIter mapIt, MapIter mapEnd)
      |                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   83 |   explicit node_iterator_base(MapIter mapIt, MapIter mapEnd)
      |                                       ^~~~~
   83 |   explicit node_iterator_base(MapIter mapIt, MapIter mapEnd)
      |                                                      ^~~~~~
   92 |   node_iterator_base(const node_iterator_base<W>& rhs,
      |   ^
      |   explicit 
   93 |                      typename std::enable_if<std::is_convertible<W*, V*>::value,
      |                      ~~~~~~~~ ^             
      |                                             _t
   94 |                                              enabler>::type = enabler())
      |                                                      ~~~~~~
   93 |                      typename std::enable_if<std::is_convertible<W*, V*>::value,
      |                                              ^                          ~~~~~~~
      |                                                                 _v
   94 |                                              enabler>::type = enabler())
      |                                                             ^
      |                                                              /*unused*/
  104 |   bool operator==(const node_iterator_base<W>& rhs) const {
      |   ~~~~ ^
      |   auto                                                    -> bool
  105 |     if (m_type != rhs.m_type)
      |                              ^
      |                               {
  106 |       return false;
      |                    
  120 |   bool operator!=(const node_iterator_base<W>& rhs) const {
      |   ~~~~ ^
      |   auto                                                    -> bool
  124 |   node_iterator_base<V>& operator++() {
      |   ~~~~~~~~~~~~~~~~~~~~~~ ^
      |   auto                                -> node_iterator_base<V>&
  139 |   node_iterator_base<V> operator++(int) {
      |   ~~~~~~~~~~~~~~~~~~~~~ ^
      |   auto                                  -> node_iterator_base<V>
  145 |   value_type operator*() const {
      |   ~~~~~~~~~~ ^
      |   auto                         -> value_type
  157 |   proxy operator->() const { return proxy(**this); }
      |         ^
note: this fix will not be applied because it overlaps with another fix
  159 |   MapIter increment_until_defined(MapIter it) {
      |   ~~~~~~~ ^
      |   auto                                        -> MapIter
   88 |   MapIter increment_until_defined(MapIter it) {
      |           ^~~~~~~~~~~~~~~~~~~~~~~
      |           incrementUntilDefined
  159 |   MapIter increment_until_defined(MapIter it) {
      |                                           ^
  160 |     while (it != m_mapEnd && !is_defined(it))
      |     ^
  160 |     while (it != m_mapEnd && !is_defined(it))
      |                                              ^
      |                                               {
  161 |       ++it;
      |            
  165 |   bool is_defined(MapIter it) const {
      |   ^
      |   [[nodiscard]] 
  165 |   bool is_defined(MapIter it) const {
      |   ~~~~ ^
      |   auto                              -> bool
  160 |     while (it != m_mapEnd && !is_defined(it))
      |                               ~~~~~~~~~~
      |                               isDefined
  161 |       ++it;
  162 |     return it;
  163 |   }
  164 | 
  165 |   bool is_defined(MapIter it) const {
      |        ^~~~~~~~~~
      |        isDefined
  165 |   bool is_defined(MapIter it) const {
      |                           ^
   77 |   typename iterator_type::value m_type;
      |                                 ^~~~~~
      |                                 m_type_
   77 |   SeqIter m_seqIt;
      |           ^~~~~~~
      |           m_seqIt_
   77 |   MapIter m_mapIt, m_mapEnd;
      |           ^~~~~~~
      |           m_mapIt_
   77 |     while (it != m_mapEnd && !is_defined(it))
      |                  ~~~~~~~~
      |                  m_mapEnd_
   78 |       ++it;
   79 |     return it;
   80 |   }
   81 | 
   82 |   bool is_defined(MapIter it) const {
   83 |     return it->first->is_defined() && it->second->is_defined();
   84 |   }
   85 | 
   86 |  private:
   87 |   typename iterator_type::value m_type;
   88 | 
   89 |   SeqIter m_seqIt;
   90 |   MapIter m_mapIt, m_mapEnd;
      |                    ^~~~~~~~
      |                    m_mapEnd_
  178 | }
      | ^
      |   // namespace detail
   20 | namespace detail {
      |           ^
  179 | }
      | ^
      |   // namespace YAML
   19 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   11 | #include "yaml-cpp/node/type.h"
      | ^        ~~~~~~~~~~~~~~~~~~~~~~
   12 | #include "yaml-cpp/node/ptr.h"
   13 | #include "yaml-cpp/node/detail/node_data.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   15 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   16 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   17 | class node_ref {
      |       ^
   21 |   node_ref& operator=(const node_ref&) = delete;
      |   ~~~~~~~~~ ^
      |   auto                                 -> node_ref&
   23 |   bool is_defined() const { return m_pData->is_defined(); }
      |   ^
      |   [[nodiscard]] 
   23 |   bool is_defined() const { return m_pData->is_defined(); }
      |   ~~~~ ^
      |   auto                    -> bool
   23 |   bool is_defined() const { return m_pData->is_defined(); }
      |        ^~~~~~~~~~
      |        isDefined
   24 |   const Mark& mark() const { return m_pData->mark(); }
      |   ^
      |   [[nodiscard]] 
   24 |   const Mark& mark() const { return m_pData->mark(); }
      |   ~~~~~~~~~~~ ^
      |   auto                     -> const Mark&
   25 |   NodeType::value type() const { return m_pData->type(); }
      |   ^
      |   [[nodiscard]] 
   25 |   NodeType::value type() const { return m_pData->type(); }
      |   ~~~~~~~~~~~~~~~ ^
      |   auto                         -> NodeType::value
   26 |   const std::string& scalar() const { return m_pData->scalar(); }
      |   ^
      |   [[nodiscard]] 
   26 |   const std::string& scalar() const { return m_pData->scalar(); }
      |   ~~~~~~~~~~~~~~~~~~ ^
      |   auto                              -> const std::string&
   27 |   const std::string& tag() const { return m_pData->tag(); }
      |   ^
      |   [[nodiscard]] 
   27 |   const std::string& tag() const { return m_pData->tag(); }
      |   ~~~~~~~~~~~~~~~~~~ ^
      |   auto                           -> const std::string&
   28 |   EmitterStyle::value style() const { return m_pData->style(); }
      |   ^
      |   [[nodiscard]] 
   28 |   EmitterStyle::value style() const { return m_pData->style(); }
      |   ~~~~~~~~~~~~~~~~~~~ ^
      |   auto                              -> EmitterStyle::value
   30 |   void mark_defined() { m_pData->mark_defined(); }
      |        ^~~~~~~~~~~~
      |        markDefined
   31 |   void set_data(const node_ref& rhs) { m_pData = rhs.m_pData; }
      |        ^~~~~~~~
      |        setData
   33 |   void set_mark(const Mark& mark) { m_pData->set_mark(mark); }
      |        ^~~~~~~~
      |        setMark
   34 |   void set_type(NodeType::value type) { m_pData->set_type(type); }
      |        ^~~~~~~~
      |        setType
   35 |   void set_tag(const std::string& tag) { m_pData->set_tag(tag); }
      |        ^~~~~~~
      |        setTag
   36 |   void set_null() { m_pData->set_null(); }
      |        ^~~~~~~~
      |        setNull
   37 |   void set_scalar(const std::string& scalar) { m_pData->set_scalar(scalar); }
      |        ^~~~~~~~~~
      |        setScalar
   38 |   void set_style(EmitterStyle::value style) { m_pData->set_style(style); }
      |        ^~~~~~~~~
      |        setStyle
   41 |   std::size_t size() const { return m_pData->size(); }
      |   ^
      |   [[nodiscard]] 
   41 |   std::size_t size() const { return m_pData->size(); }
      |   ~~~~~~~~~~~ ^
      |   auto                     -> std::size_t
   43 |   const_node_iterator begin() const {
      |   ^
      |   [[nodiscard]] 
   43 |   const_node_iterator begin() const {
      |   ~~~~~~~~~~~~~~~~~~~ ^
      |   auto                              -> const_node_iterator
   46 |   node_iterator begin() { return m_pData->begin(); }
      |   ~~~~~~~~~~~~~ ^
      |   auto                  -> node_iterator
   48 |   const_node_iterator end() const {
      |   ^
      |   [[nodiscard]] 
   48 |   const_node_iterator end() const {
      |   ~~~~~~~~~~~~~~~~~~~ ^
      |   auto                            -> const_node_iterator
   51 |   node_iterator end() { return m_pData->end(); }
      |   ~~~~~~~~~~~~~ ^
      |   auto                -> node_iterator
   54 |   void push_back(node& node, shared_memory_holder pMemory) {
      |        ^~~~~~~~~
      |        pushBack
   54 |   void push_back(node& node, shared_memory_holder pMemory) {
      |                                                   ^
      |                              const               &
   57 |   void insert(node& key, node& value, shared_memory_holder pMemory) {
      |                                                            ^
      |                                       const               &
   63 |   node* get(const Key& key, shared_memory_holder pMemory) const {
      |   ~~~~~ ^
      |   auto                                                          -> node*
   67 |   node& get(const Key& key, shared_memory_holder pMemory) {
      |   ~~~~~ ^
      |   auto                                                    -> node&
   71 |   bool remove(const Key& key, shared_memory_holder pMemory) {
      |   ~~~~ ^
      |   auto                                                      -> bool
   75 |   node* get(node& key, shared_memory_holder pMemory) const {
      |   ~~~~~ ^
      |   auto                                                     -> node*
   75 |   node* get(node& key, shared_memory_holder pMemory) const {
      |                                             ^
      |                        const               &
   78 |   node& get(node& key, shared_memory_holder pMemory) {
      |   ~~~~~ ^
      |   auto                                               -> node&
   78 |   node& get(node& key, shared_memory_holder pMemory) {
      |                                             ^
      |                        const               &
   81 |   bool remove(node& key, shared_memory_holder pMemory) {
      |   ~~~~ ^
      |   auto                                                 -> bool
   81 |   bool remove(node& key, shared_memory_holder pMemory) {
      |                                               ^
      |                          const               &
   87 |   void force_insert(const Key& key, const Value& value,
      |        ^~~~~~~~~~~~
      |        forceInsert
   19 |     return m_pData->get(key, pMemory);
      |            ~~~~~~~
      |            m_pData_
   20 |   }
   21 |   bool remove(node& key, shared_memory_holder pMemory) {
   22 |     return m_pData->remove(key, pMemory);
      |            ~~~~~~~
      |            m_pData_
   23 |   }
   24 | 
   25 |   // map
   26 |   template <typename Key, typename Value>
   27 |   void force_insert(const Key& key, const Value& value,
   28 |                     shared_memory_holder pMemory) {
   29 |     m_pData->force_insert(key, value, pMemory);
      |     ~~~~~~~
      |     m_pData_
   30 |   }
   31 | 
   32 |  private:
   33 |   shared_node_data m_pData;
      |                    ^~~~~~~
      |                    m_pData_
   95 | }
      | ^
      |   // namespace detail
   16 | namespace detail {
      |           ^
   96 | }
      | ^
      |   // namespace YAML
   15 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   10 | #include <string>
      | ^        ~~~~~~~~
   11 | #include <iosfwd>
      |          ~~~~~~~~
   23 | YAML_CPP_API Emitter& operator<<(Emitter& out, const Node& node);
      |              ~~~~~~~~ ^                                         
      |              auto                                                -> Emitter&
   26 | YAML_CPP_API std::ostream& operator<<(std::ostream& out, const Node& node);
      |              ~~~~~~~~~~~~~ ^                                              
      |              auto                                                          -> std::ostream&
   29 | YAML_CPP_API std::string Dump(const Node& node);
      |              ~~~~~~~~~~~ ^                     
      |              auto                               -> std::string
   29 | YAML_CPP_API std::string Dump(const Node& node);
      |                          ^~~~
      |                          dump
    7 | #pragma once
      | ^
   20 |     : m_isValid(true), m_invalidKey{}, m_pMemory(nullptr), m_pNode(nullptr) {}
      |                        ^~~~~~~~~~~~~~
   24 |       m_invalidKey{},
      |       ^~~~~~~~~~~~~~
   33 |       m_invalidKey{},
      |       ^~~~~~~~~~~~~~
   47 | inline Node::Node(Zombie)
      |                         ^
      |                          /*unused*/
   48 |     : m_isValid(false), m_invalidKey{}, m_pMemory{}, m_pNode(nullptr) {}
      |                         ^~~~~~~~~~~~~~
   48 |     : m_isValid(false), m_invalidKey{}, m_pMemory{}, m_pNode(nullptr) {}
      |                                         ^~~~~~~~~~~
   50 | inline Node::Node(Zombie, const std::string& key)
      |                         ^
      |                          /*unused*/
   17 | inline Node::Node(Zombie, const std::string& key)
      |                           ^~~~~~~~~~~~~~~~~~
      |                           std::string 
   18 |     : m_isValid(false), m_invalidKey(key), m_pMemory{}, m_pNode(nullptr) {}
      |                                         
      |                                      std::move( )
   51 |     : m_isValid(false), m_invalidKey(key), m_pMemory{}, m_pNode(nullptr) {}
      |                                            ^~~~~~~~~~~
   53 | inline Node::Node(detail::node& node, detail::shared_memory_holder pMemory)
      |                                       ^
   54 |     : m_isValid(true), m_invalidKey{}, m_pMemory(pMemory), m_pNode(&node) {}
      |                                                         
      |                                                  std::move( )
   54 |     : m_isValid(true), m_invalidKey{}, m_pMemory(pMemory), m_pNode(&node) {}
      |                        ^~~~~~~~~~~~~~
   17 |     : m_isValid(true), m_invalidKey{}, m_pMemory(pMemory), m_pNode(&node) {}
      |                                                  ^      
      |                                                  std::move( )
   59 |   if (!m_isValid)
      |                  ^
      |                   {
   60 |     throw InvalidNode(m_invalidKey);
      |                                     
   60 |     throw InvalidNode(m_invalidKey);
      |     ^
   61 |   if (!m_pNode) {
      |       ~^      
      |                == nullptr
   15 |     m_pMemory.reset(new detail::memory_holder);
      |              ~^~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~
      |               = std::make_shared<detail::memory_holder>
   62 |     m_pMemory.reset(new detail::memory_holder);
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~
   68 | inline bool Node::IsDefined() const {
      |        ~~~~       ^
      |        auto                         -> bool
   72 |   return m_pNode ? m_pNode->is_defined() : true;
      |          ^
      |          (       != nullptr)
   75 | inline Mark Node::Mark() const {
      |        ~~~~       ^
      |        auto                    -> Mark
   77 |     throw InvalidNode(m_invalidKey);
      |     ^
   79 |   return m_pNode ? m_pNode->mark() : Mark::null_mark();
      |          ^
      |          (       != nullptr)
   82 | inline NodeType::value Node::Type() const {
      |        ~~~~~~~~~~~~~~~       ^
      |        auto                               -> NodeType::value
   83 |   if (!m_isValid)
      |                  ^
      |                   {
   84 |     throw InvalidNode(m_invalidKey);
      |                                     
   84 |     throw InvalidNode(m_invalidKey);
      |     ^
   85 |   return m_pNode ? m_pNode->type() : NodeType::Null;
      |          ^
      |          (       != nullptr)
   94 |   const Node& node;
      |               ^
   96 |   T operator()(const S& fallback) const {
      |   ~ ^
      |   auto                                  -> T
   97 |     if (!node.m_pNode)
      |         ~^           
      |                       == nullptr
   97 |     if (!node.m_pNode)
      |                       ^
      |                        {
   98 |       return fallback;
      |                       
  100 |     T t;
      |       ^
  101 |     if (convert<T>::decode(node, t))
      |                                     ^
      |                                      {
  102 |       return t;
      |                
  110 |   const Node& node;
      |               ^
  112 |   std::string operator()(const S& fallback) const {
      |   ~~~~~~~~~~~ ^
      |   auto                                            -> std::string
  113 |     if (node.Type() == NodeType::Null)
      |                                       ^
      |                                        {
  114 |       return "null";
      |                     
  115 |     if (node.Type() != NodeType::Scalar)
      |                                         ^
      |                                          {
  116 |       return fallback;
      |                       
  124 |   const Node& node;
      |               ^
  126 |   T operator()() const {
      |   ~ ^
      |   auto                 -> T
  127 |     if (!node.m_pNode)
      |         ~^           
      |                       == nullptr
  127 |     if (!node.m_pNode)
      |                       ^
      |                        {
  128 |       throw TypedBadConversion<T>(node.Mark());
      |                                                
  130 |     T t;
      |       ^
  131 |     if (convert<T>::decode(node, t))
      |                                     ^
      |                                      {
  132 |       return t;
      |                
  140 |   const Node& node;
      |               ^
  142 |   std::string operator()() const {
      |   ~~~~~~~~~~~ ^
      |   auto                           -> std::string
  143 |     if (node.Type() == NodeType::Null)
      |                                       ^
      |                                        {
  144 |       return "null";
      |                     
  145 |     if (node.Type() != NodeType::Scalar)
      |                                         ^
      |                                          {
  146 |       throw TypedBadConversion<std::string>(node.Mark());
      |                                                          
  146 |       throw TypedBadConversion<std::string>(node.Mark());
      |       ^
  153 | inline T Node::as() const {
      |        ~       ^
      |        auto               -> T
  154 |   if (!m_isValid)
      |                  ^
      |                   {
  155 |     throw InvalidNode(m_invalidKey);
      |                                     
  160 | inline T Node::as(const S& fallback) const {
      |        ~       ^
      |        auto                                -> T
  161 |   if (!m_isValid)
      |                  ^
      |                   {
  162 |     return fallback;
      |                     
  166 | inline const std::string& Node::Scalar() const {
      |        ~~~~~~~~~~~~~~~~~~       ^
      |        auto                                    -> const std::string&
  167 |   if (!m_isValid)
      |                  ^
      |                   {
  168 |     throw InvalidNode(m_invalidKey);
      |                                     
  168 |     throw InvalidNode(m_invalidKey);
      |     ^
  169 |   return m_pNode ? m_pNode->scalar() : detail::node_data::empty_scalar();
      |          ^
      |          (       != nullptr)
  172 | inline const std::string& Node::Tag() const {
      |        ~~~~~~~~~~~~~~~~~~       ^
      |        auto                                 -> const std::string&
  173 |   if (!m_isValid)
      |                  ^
      |                   {
  174 |     throw InvalidNode(m_invalidKey);
      |                                     
  174 |     throw InvalidNode(m_invalidKey);
      |     ^
  175 |   return m_pNode ? m_pNode->tag() : detail::node_data::empty_scalar();
      |          ^
      |          (       != nullptr)
  183 | inline EmitterStyle::value Node::Style() const {
      |        ~~~~~~~~~~~~~~~~~~~       ^
      |        auto                                    -> EmitterStyle::value
  184 |   if (!m_isValid)
      |                  ^
      |                   {
  185 |     throw InvalidNode(m_invalidKey);
      |                                     
  185 |     throw InvalidNode(m_invalidKey);
      |     ^
  186 |   return m_pNode ? m_pNode->style() : EmitterStyle::Default;
      |          ^
      |          (       != nullptr)
  195 | inline bool Node::is(const Node& rhs) const {
      |        ~~~~       ^
      |        auto                                 -> bool
  196 |   if (!m_isValid || !rhs.m_isValid)
      |                                    ^
      |                                     {
  197 |     throw InvalidNode(m_invalidKey);
      |                                     
  197 |     throw InvalidNode(m_invalidKey);
      |     ^
  198 |   if (!m_pNode || !rhs.m_pNode)
      |       ~^
      |       (        == nullptr)
  198 |   if (!m_pNode || !rhs.m_pNode)
      |                   ~^          
      |                   (            == nullptr)
  198 |   if (!m_pNode || !rhs.m_pNode)
      |                                ^
      |                                 {
  199 |     return false;
      |                  
  204 | inline Node& Node::operator=(const T& rhs) {
      |        ~~~~~       ^
      |        auto                                -> Node&
  209 | inline Node& Node::operator=(const Node& rhs) {
      |                    ^
  209 | inline Node& Node::operator=(const Node& rhs) {
      |        ~~~~~       ^
      |        auto                                   -> Node&
  210 |   if (is(rhs))
      |               ^
      |                {
  211 |     return *this;
      |                  
  217 |   if (!m_isValid || !rhs.m_isValid)
      |                                    ^
      |                                     {
  218 |     throw InvalidNode(m_invalidKey);
      |                                     
  218 |     throw InvalidNode(m_invalidKey);
      |     ^
  225 |   if (!m_isValid)
      |                  ^
      |                   {
  226 |     throw InvalidNode(m_invalidKey);
      |                                     
  231 | inline void Node::Assign(const std::string& rhs) {
      |                   ^~~~~~
      |                   assign
  241 | inline void Node::Assign(char* rhs) {
      |                                ^
      |                          const 
  255 |   if (!m_isValid)
      |                  ^
      |                   {
  256 |     throw InvalidNode(m_invalidKey);
      |                                     
  256 |     throw InvalidNode(m_invalidKey);
      |     ^
  259 |   if (!m_pNode) {
      |       ~^      
      |                == nullptr
  271 | inline std::size_t Node::size() const {
      |        ~~~~~~~~~~~       ^
      |        auto                           -> std::size_t
  272 |   if (!m_isValid)
      |                  ^
      |                   {
  273 |     throw InvalidNode(m_invalidKey);
      |                                     
  273 |     throw InvalidNode(m_invalidKey);
      |     ^
  274 |   return m_pNode ? m_pNode->size() : 0;
      |          ^
      |          (       != nullptr)
  277 | inline const_iterator Node::begin() const {
      |        ~~~~~~~~~~~~~~       ^
      |        auto                               -> const_iterator
  278 |   if (!m_isValid)
      |                  ^
      |                   {
  279 |     return const_iterator();
      |                             
  279 |     return const_iterator();
      |            ^~~~~~~~~~~~~~~~
      |            {}
  280 |   return m_pNode ? const_iterator(m_pNode->begin(), m_pMemory)
      |          ^
      |          (       != nullptr)
  284 | inline iterator Node::begin() {
      |        ~~~~~~~~       ^
      |        auto                   -> iterator
  285 |   if (!m_isValid)
      |                  ^
      |                   {
  286 |     return iterator();
      |                       
  286 |     return iterator();
      |            ^~~~~~~~~~
      |            {}
  287 |   return m_pNode ? iterator(m_pNode->begin(), m_pMemory) : iterator();
      |          ^
      |          (       != nullptr)
  290 | inline const_iterator Node::end() const {
      |        ~~~~~~~~~~~~~~       ^
      |        auto                             -> const_iterator
  291 |   if (!m_isValid)
      |                  ^
      |                   {
  292 |     return const_iterator();
      |                             
  292 |     return const_iterator();
      |            ^~~~~~~~~~~~~~~~
      |            {}
  293 |   return m_pNode ? const_iterator(m_pNode->end(), m_pMemory) : const_iterator();
      |          ^
      |          (       != nullptr)
  296 | inline iterator Node::end() {
      |        ~~~~~~~~       ^
      |        auto                 -> iterator
  297 |   if (!m_isValid)
      |                  ^
      |                   {
  298 |     return iterator();
      |                       
  298 |     return iterator();
      |            ^~~~~~~~~~
      |            {}
  299 |   return m_pNode ? iterator(m_pNode->end(), m_pMemory) : iterator();
      |          ^
      |          (       != nullptr)
  305 |   if (!m_isValid)
      |                  ^
      |                   {
  306 |     throw InvalidNode(m_invalidKey);
      |                                     
  319 | std::string key_to_string(const Key& key) {
      | ~~~~~~~~~~~ ^
      | auto                                      -> std::string
  319 | std::string key_to_string(const Key& key) {
      |             ^~~~~~~~~~~~~
      |             keyToString
  325 | inline const Node Node::operator[](const Key& key) const {
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  325 | inline const Node Node::operator[](const Key& key) const {
      |        ~~~~~~~~~~       ^
      |        auto                                              -> const Node
  336 | inline Node Node::operator[](const Key& key) {
      |        ~~~~       ^
      |        auto                                  -> Node
  343 | inline bool Node::remove(const Key& key) {
      |        ~~~~       ^
      |        auto                              -> bool
  348 | inline const Node Node::operator[](const Node& key) const {
      | ^      ~~~~~
note: this fix will not be applied because it overlaps with another fix
  348 | inline const Node Node::operator[](const Node& key) const {
      |        ~~~~~~~~~~       ^
      |        auto                                               -> const Node
  354 |   if (!value) {
      |       ~^    
      |              == nullptr
  360 | inline Node Node::operator[](const Node& key) {
      |        ~~~~       ^
      |        auto                                   -> Node
  368 | inline bool Node::remove(const Node& key) {
      |        ~~~~       ^
      |        auto                               -> bool
  382 | inline bool operator==(const Node& lhs, const Node& rhs) { return lhs.is(rhs); }
      |        ~~~~ ^
      |        auto                                              -> bool
    7 | #pragma once
      | ^
   11 | #include "yaml-cpp/node/node.h"
      | ^        ~~~~~~~~~~~~~~~~~~~~~~
   12 | #include "yaml-cpp/node/detail/iterator_fwd.h"
   13 | #include "yaml-cpp/node/detail/iterator.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   19 | static_assert(std::is_constructible<YAML::Node, const YAML::Node&>::value, "Node must be copy constructable");
      |               ^                                                   ~~~~~~~
      |                                    _v
   21 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   22 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   23 | struct iterator_value : public Node, std::pair<Node, Node> {
   24 |   iterator_value() = default;
   25 |   explicit iterator_value(const Node& rhs)
   26 |       : Node(rhs),
   27 |         std::pair<Node, Node>(Node(Node::ZombieNode), Node(Node::ZombieNode)) {}
   28 |   explicit iterator_value(const Node& key, const Node& value)
   29 |       : Node(Node::ZombieNode), std::pair<Node, Node>(key, value) {}
   30 | };
   31 | }
   32 | }
      | ~
   23 | struct iterator_value : public Node, std::pair<Node, Node> {
      |        ^
   24 |   iterator_value() = default;
   25 |   explicit iterator_value(const Node& rhs)
   26 |       : Node(rhs),
   27 |         std::pair<Node, Node>(Node(Node::ZombieNode), Node(Node::ZombieNode)) {}
   28 |   explicit iterator_value(const Node& key, const Node& value)
   29 |       : Node(Node::ZombieNode), std::pair<Node, Node>(key, value) {}
   30 | };
      |  
      |   __attribute__((packed))
   23 | struct iterator_value : public Node, std::pair<Node, Node> {
      |        ^
   24 |   iterator_value() = default;
   25 |   explicit iterator_value(const Node& rhs)
   26 |       : Node(rhs),
   27 |         std::pair<Node, Node>(Node(Node::ZombieNode), Node(Node::ZombieNode)) {}
   28 |   explicit iterator_value(const Node& key, const Node& value)
   29 |       : Node(Node::ZombieNode), std::pair<Node, Node>(key, value) {}
   30 | };
      |  
      |   __attribute__((aligned(1)))
   31 | }
      | ^
      |   // namespace detail
   22 | namespace detail {
      |           ^
   32 | }
      | ^
      |   // namespace YAML
   21 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   20 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   21 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   22 | class node;
   23 | class node_data;
   24 | struct iterator_value;
   25 | }  // namespace detail
      | ~~~~~~~~~~~~~~~~~~~~~~
      | } // namespace YAML::detail
   26 | }  // namespace YAML
      | ~~~~~~~~~~~~~~~~~~~~
   29 | class YAML_CPP_API Node {
      |                    ^
   39 |   friend struct as_if;
      |                 ^~~~~
      |                 AsIf
   52 |   YAML::Mark Mark() const;
      |   ~~~~~~~~~~ ^           
      |   auto                    -> YAML::Mark
   52 |   YAML::Mark Mark() const;
      |              ^~~~
      |              mark
   53 |   NodeType::value Type() const;
      |   ~~~~~~~~~~~~~~~ ^           
      |   auto                         -> NodeType::value
   54 |   bool IsDefined() const;
      |   ~~~~ ^                
      |   auto                   -> bool
   54 |   bool IsDefined() const;
      |        ^~~~~~~~~
      |        isDefined
   55 |   bool IsNull() const { return Type() == NodeType::Null; }
   56 |   bool IsScalar() const { return Type() == NodeType::Scalar; }
   57 |   bool IsSequence() const { return Type() == NodeType::Sequence; }
   58 |   bool IsMap() const { return Type() == NodeType::Map; }
   59 | 
   60 |   // bool conversions
   61 |   explicit operator bool() const { return IsDefined(); }
      |                                           ~~~~~~~~~
      |                                           isDefined
   62 |   bool operator!() const { return !IsDefined(); }
      |                                    ~~~~~~~~~
      |                                    isDefined
   55 |   bool IsNull() const { return Type() == NodeType::Null; }
      |   ~~~~ ^
      |   auto                -> bool
   55 |   bool IsNull() const { return Type() == NodeType::Null; }
      |        ^~~~~~
      |        isNull
   56 |   bool IsScalar() const { return Type() == NodeType::Scalar; }
      |   ~~~~ ^
      |   auto                  -> bool
   56 |   bool IsScalar() const { return Type() == NodeType::Scalar; }
      |        ^~~~~~~~
      |        isScalar
   57 |   bool IsSequence() const { return Type() == NodeType::Sequence; }
      |   ~~~~ ^
      |   auto                    -> bool
   57 |   bool IsSequence() const { return Type() == NodeType::Sequence; }
      |        ^~~~~~~~~~
      |        isSequence
   58 |   bool IsMap() const { return Type() == NodeType::Map; }
      |   ~~~~ ^
      |   auto               -> bool
   58 |   bool IsMap() const { return Type() == NodeType::Map; }
      |        ^~~~~
      |        isMap
   62 |   bool operator!() const { return !IsDefined(); }
      |   ~~~~ ^
      |   auto                   -> bool
   66 |   T as() const;
      |   ~ ^         
      |   auto         -> T
   68 |   T as(const S& fallback) const;
      |   ~ ^                          
      |   auto                          -> T
   69 |   const std::string& Scalar() const;
      |   ~~~~~~~~~~~~~~~~~~ ^             
      |   auto                              -> const std::string&
   71 |   const std::string& Tag() const;
      |   ~~~~~~~~~~~~~~~~~~ ^          
      |   auto                           -> const std::string&
   71 |   const std::string& Tag() const;
      |                      ^~~
      |                      tag
   72 |   void SetTag(const std::string& tag);
      |        ^~~~~~
      |        setTag
   76 |   EmitterStyle::value Style() const;
      |   ~~~~~~~~~~~~~~~~~~~ ^            
      |   auto                              -> EmitterStyle::value
   76 |   EmitterStyle::value Style() const;
      |                       ^~~~~
      |                       style
   77 |   void SetStyle(EmitterStyle::value style);
      |        ^~~~~~~~
      |        setStyle
   80 |   bool is(const Node& rhs) const;
      |   ~~~~ ^                        
      |   auto                           -> bool
   82 |   Node& operator=(const T& rhs);
      |   ~~~~~ ^                      
      |   auto                          -> Node&
   83 |   Node& operator=(const Node& rhs);
      |   ~~~~~ ^                         
      |   auto                             -> Node&
   87 |   std::size_t size() const;
      |   ~~~~~~~~~~~ ^           
      |   auto                     -> std::size_t
   89 |   const_iterator begin() const;
      |   ~~~~~~~~~~~~~~ ^            
      |   auto                         -> const_iterator
   90 |   iterator begin();
      |   ~~~~~~~~ ^      
      |   auto             -> iterator
   92 |   const_iterator end() const;
      |   ~~~~~~~~~~~~~~ ^          
      |   auto                       -> const_iterator
   93 |   iterator end();
      |   ~~~~~~~~ ^    
      |   auto           -> iterator
   97 |   void push_back(const T& rhs);
      |        ^~~~~~~~~
      |        pushBack
   98 |   void push_back(const Node& rhs);
      |        ^~~~~~~~~
      |        pushBack
  102 |   const Node operator[](const Key& key) const;
      |   ~~~~~~~~~~ ^                               
      |   auto                                        -> const Node
  104 |   Node operator[](const Key& key);
      |   ~~~~ ^                         
      |   auto                            -> Node
  106 |   bool remove(const Key& key);
      |   ~~~~ ^                     
      |   auto                        -> bool
  108 |   const Node operator[](const Node& key) const;
      |   ~~~~~~~~~~ ^                                
      |   auto                                         -> const Node
  109 |   Node operator[](const Node& key);
      |   ~~~~ ^                          
      |   auto                             -> Node
  110 |   bool remove(const Node& key);
      |   ~~~~ ^                      
      |   auto                         -> bool
  114 |   void force_insert(const Key& key, const Value& value);
      |        ^~~~~~~~~~~~
      |        forceInsert
  117 |   enum Zombie { ZombieNode };
      |        ^
  118 |   explicit Node(Zombie);
      |                       ^
      |                        /*unused*/
  119 |   explicit Node(Zombie, const std::string&);
      |                       ^                   
      |                        /*unused*/          /*key*/
  122 |   void EnsureNodeExists() const;
      |        ^~~~~~~~~~~~~~~~
      |        ensureNodeExists
  125 |   void Assign(const T& rhs);
      |        ^~~~~~
      |        assign
  126 |   void Assign(const char* rhs);
      |        ^~~~~~
      |        assign
  127 |   void Assign(char* rhs);
      |        ^~~~~~
      |        assign
  129 |   void AssignData(const Node& rhs);
      |        ^~~~~~~~~~
      |        assignData
  130 |   void AssignNode(const Node& rhs);
      |        ^~~~~~~~~~
      |        assignNode
  132 |  private:
      |  ^~~~~~~~
  116 |  private:
      |  ^
  133 |   bool m_isValid;
      |        ^~~~~~~~~
      |        m_isValid_
  135 |   std::string m_invalidKey;
      |               ^
note: this fix will not be applied because it overlaps with another fix
  136 |   mutable detail::shared_memory_holder m_pMemory;
      |                                        ^
note: this fix will not be applied because it overlaps with another fix
  137 |   mutable detail::node* m_pNode;
      |                         ^~~~~~~
      |                         m_pNode_
  140 | YAML_CPP_API bool operator==(const Node& lhs, const Node& rhs);
      |              ~~~~ ^                                           
      |              auto                                              -> bool
  142 | YAML_CPP_API Node Clone(const Node& node);
      |              ~~~~ ^                      
      |              auto                         -> Node
  142 | YAML_CPP_API Node Clone(const Node& node);
      |                   ^~~~~
      |                   clone
  146 | }
      | ^
      |   // namespace YAML
   28 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   24 | YAML_CPP_API Node Load(const std::string& input);
      |              ~~~~ ^                             
      |              auto                                -> Node
   24 | YAML_CPP_API Node Load(const std::string& input);
      |                   ^~~~
      |                   load
   31 | YAML_CPP_API Node Load(const char* input);
      |              ~~~~ ^                      
      |              auto                         -> Node
   31 | YAML_CPP_API Node Load(const char* input);
      |                   ^~~~
      |                   load
   38 | YAML_CPP_API Node Load(std::istream& input);
      |              ~~~~ ^                        
      |              auto                           -> Node
   38 | YAML_CPP_API Node Load(std::istream& input);
      |                   ^~~~
      |                   load
   46 | YAML_CPP_API Node LoadFile(const std::string& filename);
      |              ~~~~ ^                                    
      |              auto                                       -> Node
   46 | YAML_CPP_API Node LoadFile(const std::string& filename);
      |                   ^~~~~~~~
      |                   loadFile
   53 | YAML_CPP_API std::vector<Node> LoadAll(const std::string& input);
      |              ~~~~~~~~~~~~~~~~~ ^                                
      |              auto                                                -> std::vector<Node>
   53 | YAML_CPP_API std::vector<Node> LoadAll(const std::string& input);
      |                                ^~~~~~~
      |                                loadAll
   60 | YAML_CPP_API std::vector<Node> LoadAll(const char* input);
      |              ~~~~~~~~~~~~~~~~~ ^                         
      |              auto                                         -> std::vector<Node>
   60 | YAML_CPP_API std::vector<Node> LoadAll(const char* input);
      |                                ^~~~~~~
      |                                loadAll
   67 | YAML_CPP_API std::vector<Node> LoadAll(std::istream& input);
      |              ~~~~~~~~~~~~~~~~~ ^                           
      |              auto                                           -> std::vector<Node>
   67 | YAML_CPP_API std::vector<Node> LoadAll(std::istream& input);
      |                                ^~~~~~~
      |                                loadAll
   75 | YAML_CPP_API std::vector<Node> LoadAllFromFile(const std::string& filename);
      |              ~~~~~~~~~~~~~~~~~ ^                                           
      |              auto                                                           -> std::vector<Node>
   75 | YAML_CPP_API std::vector<Node> LoadAllFromFile(const std::string& filename);
      |                                ^~~~~~~~~~~~~~~
      |                                loadAllFromFile
    7 | #pragma once
      | ^
   12 | namespace YAML {
      | ^~~~~~~~~~~~~~~~
   13 | namespace detail {
      | ~~~~~~~~~~~~~~~~
      | namespace YAML::detail
   14 | class node;
   15 | class node_ref;
   16 | class node_data;
   17 | class memory;
   18 | class memory_holder;
   19 | 
   20 | using shared_node = std::shared_ptr<node>;
   21 | using shared_node_ref = std::shared_ptr<node_ref>;
   22 | using shared_node_data = std::shared_ptr<node_data>;
   23 | using shared_memory_holder = std::shared_ptr<memory_holder>;
   24 | using shared_memory = std::shared_ptr<memory>;
   25 | }
   26 | }
      | ~
   14 | class node;
      |       ^
note: this fix will not be applied because it overlaps with another fix
   15 | class node_ref;
      |       ^
note: this fix will not be applied because it overlaps with another fix
   16 | class node_data;
      |       ^
note: this fix will not be applied because it overlaps with another fix
   17 | class memory;
      |       ^~~~~~
      |       Memory
   18 | class memory_holder;
   19 | 
   20 | using shared_node = std::shared_ptr<node>;
   21 | using shared_node_ref = std::shared_ptr<node_ref>;
   22 | using shared_node_data = std::shared_ptr<node_data>;
   23 | using shared_memory_holder = std::shared_ptr<memory_holder>;
   24 | using shared_memory = std::shared_ptr<memory>;
      |                                       ~~~~~~
      |                                       Memory
   18 | class memory_holder;
      |       ^
note: this fix will not be applied because it overlaps with another fix
   25 | }
      | ^
      |   // namespace detail
   13 | namespace detail {
      |           ^
   26 | }
      | ^
      |   // namespace YAML
   12 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   12 |   enum value { Undefined, Null, Scalar, Sequence, Map };
      |        ^
   14 | }
      | ^
      |   // namespace YAML
   10 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
    7 | #pragma once
      | ^
   16 | struct YAML_CPP_API _Null {};
      |                     ^
note: this fix will not be applied because it overlaps with another fix
note: this fix will not be applied because it overlaps with another fix
   17 | inline bool operator==(const _Null&, const _Null&) { return true; }
      |        ~~~~ ^
      |        auto                                        -> bool
   17 | inline bool operator==(const _Null&, const _Null&) { return true; }
      |                                    ^             
      |                                     /*unused*/    /*unused*/
   18 | inline bool operator!=(const _Null&, const _Null&) { return false; }
      |        ~~~~ ^
      |        auto                                        -> bool
   18 | inline bool operator!=(const _Null&, const _Null&) { return false; }
      |                                    ^             
      |                                     /*unused*/    /*unused*/
   20 | YAML_CPP_API bool IsNull(const Node& node);  // old API only
      |              ~~~~ ^                       
      |              auto                          -> bool
   20 | YAML_CPP_API bool IsNull(const Node& node);  // old API only
      |                   ^~~~~~
      |                   isNull
   21 | YAML_CPP_API bool IsNullString(const std::string& str);
      |              ~~~~ ^                                   
      |              auto                                      -> bool
   21 | YAML_CPP_API bool IsNullString(const std::string& str);
      |                   ^~~~~~~~~~~~
      |                   isNullString
   23 | extern YAML_CPP_API _Null Null;
      |                           ^
   23 | extern YAML_CPP_API _Null Null;
      |                           ^~~~
      |                           null
   24 | }
      | ^
      |   // namespace YAML
   13 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   16 | class YAML_CPP_API ostream_wrapper {
      |                    ^
note: this fix will not be applied because it overlaps with another fix
   22 |   ostream_wrapper& operator=(const ostream_wrapper&) = delete;
      |   ~~~~~~~~~~~~~~~~ ^
      |   auto                                               -> ostream_wrapper&
   23 |   ostream_wrapper& operator=(ostream_wrapper&&) = delete;
      |   ~~~~~~~~~~~~~~~~ ^
      |   auto                                          -> ostream_wrapper&
   29 |   void set_comment() { m_comment = true; }
      |        ^~~~~~~~~~~
      |        setComment
   31 |   const char* str() const {
      |   ~~~~~~~~~~~ ^
      |   auto                    -> const char*
   32 |     if (m_pStream) {
      |         ^        
      |                   != nullptr
   34 |     } else {
      |       ^~~~~~
   35 |       m_buffer[m_pos] = '\0';
      |       ~~~~~~~~~~~~~~~~~~~~~~~
   36 |       return &m_buffer[0];
      |       ~~~~~~~~~~~~~~~~~~~~
   37 |     }
      |     ~
   36 |       return &m_buffer[0];
      |              ^
note: this fix will not be applied because it overlaps with another fix
   40 |   std::size_t row() const { return m_row; }
      |   ~~~~~~~~~~~ ^
      |   auto                    -> std::size_t
   41 |   std::size_t col() const { return m_col; }
      |   ~~~~~~~~~~~ ^
      |   auto                    -> std::size_t
   42 |   std::size_t pos() const { return m_pos; }
      |   ~~~~~~~~~~~ ^
      |   auto                    -> std::size_t
   43 |   bool comment() const { return m_comment; }
      |   ~~~~ ^
      |   auto                 -> bool
   46 |   void update_pos(char ch);
      |        ^~~~~~~~~~
      |        updatePos
   46 |   void update_pos(char ch);
      |                        ^
   48 |  private:
      |  ^~~~~~~~
   45 |  private:
      |  ^
   49 |   mutable std::vector<char> m_buffer;
      |                             ^
note: this fix will not be applied because it overlaps with another fix
   32 |   std::ostream* const m_pStream;
      |                       ^~~~~~~~~
      |                       m_pStream_
   52 |   std::size_t m_pos;
      |               ^
note: this fix will not be applied because it overlaps with another fix
   40 |   std::size_t row() const { return m_row; }
      |                                    ~~~~~
      |                                    m_row_
   41 |   std::size_t col() const { return m_col; }
   42 |   std::size_t pos() const { return m_pos; }
   43 |   bool comment() const { return m_comment; }
   44 | 
   45 |  private:
   46 |   void update_pos(char ch);
   47 | 
   48 |  private:
   49 |   mutable std::vector<char> m_buffer;
   50 |   std::ostream* const m_pStream;
   51 | 
   52 |   std::size_t m_pos;
   53 |   std::size_t m_row, m_col;
      |               ^~~~~
      |               m_row_
   41 |   std::size_t col() const { return m_col; }
      |                                    ~~~~~
      |                                    m_col_
   42 |   std::size_t pos() const { return m_pos; }
   43 |   bool comment() const { return m_comment; }
   44 | 
   45 |  private:
   46 |   void update_pos(char ch);
   47 | 
   48 |  private:
   49 |   mutable std::vector<char> m_buffer;
   50 |   std::ostream* const m_pStream;
   51 | 
   52 |   std::size_t m_pos;
   53 |   std::size_t m_row, m_col;
      |                      ^~~~~
      |                      m_col_
   29 |   bool comment() const { return m_comment; }
      |                                 ~~~~~~~~~
      |                                 m_comment_
   30 | 
   31 |  private:
   32 |   void update_pos(char ch);
   33 | 
   34 |  private:
   35 |   mutable std::vector<char> m_buffer;
   36 |   std::ostream* const m_pStream;
   37 | 
   38 |   std::size_t m_pos;
   39 |   std::size_t m_row, m_col;
   40 |   bool m_comment;
      |        ^~~~~~~~~
      |        m_comment_
   58 | inline ostream_wrapper& operator<<(ostream_wrapper& stream,
      |        ~~~~~~~~~~~~~~~~ ^
      |        auto
   59 |                                    const char (&str)[N]) {
      |                                                          -> ostream_wrapper&
   59 |                                    const char (&str)[N]) {
      |                                          ^
   64 | inline ostream_wrapper& operator<<(ostream_wrapper& stream,
      |        ~~~~~~~~~~~~~~~~ ^
      |        auto
   65 |                                    const std::string& str) {
      |                                                            -> ostream_wrapper&
   70 | inline ostream_wrapper& operator<<(ostream_wrapper& stream, char ch) {
      |        ~~~~~~~~~~~~~~~~ ^
      |        auto                                                          -> ostream_wrapper&
   70 | inline ostream_wrapper& operator<<(ostream_wrapper& stream, char ch) {
      |                                                                  ^
    7 | #pragma once
      | ^
   33 |   Parser& operator=(const Parser&) = delete;
      |   ~~~~~~~ ^
      |   auto                             -> Parser&
   34 |   Parser& operator=(Parser&&) = delete;
      |   ~~~~~~~ ^
      |   auto                        -> Parser&
   40 |   explicit Parser(std::istream& in);
      |                                 ^
   51 |   void Load(std::istream& in);
      |        ^~~~
      |        load
   51 |   void Load(std::istream& in);
      |                           ^
   59 |   bool HandleNextDocument(EventHandler& eventHandler);
      |   ~~~~ ^                                             
      |   auto                                                -> bool
   59 |   bool HandleNextDocument(EventHandler& eventHandler);
      |        ^~~~~~~~~~~~~~~~~~
      |        handleNextDocument
   61 |   void PrintTokens(std::ostream& out);
      |        ^~~~~~~~~~~
      |        printTokens
   68 |   void ParseDirectives();
      |        ^~~~~~~~~~~~~~~
      |        parseDirectives
   70 |   void HandleDirective(const Token& token);
      |        ^~~~~~~~~~~~~~~
      |        handleDirective
   76 |   void HandleYamlDirective(const Token& token);
      |        ^~~~~~~~~~~~~~~~~~~
      |        handleYamlDirective
   82 |   void HandleTagDirective(const Token& token);
      |        ^~~~~~~~~~~~~~~~~~
      |        handleTagDirective
   84 |  private:
      |  ^~~~~~~~
   63 |  private:
      |  ^
   85 |   std::unique_ptr<Scanner> m_pScanner;
      |                            ^~~~~~~~~~
      |                            m_pScanner_
   86 |   std::unique_ptr<Directives> m_pDirectives;
      |                               ^~~~~~~~~~~~~
      |                               m_pDirectives_
    7 | #pragma once
      | ^
   10 | #include <vector>
      | ^        ~~~~~~~~
   11 | #include <list>
      |          ~~~~~~
   12 | #include <set>
   13 | #include <map>
      |          ~~~~~
   17 | inline Emitter& EmitSeq(Emitter& emitter, const Seq& seq) {
      |        ~~~~~~~~ ^
      |        auto                                               -> Emitter&
   17 | inline Emitter& EmitSeq(Emitter& emitter, const Seq& seq) {
      |                 ^~~~~~~
      |                 emitSeq
   19 |   for (const auto& v : seq)
      |   ^
   19 |   for (const auto& v : seq)
      |                    ^
   19 |   for (const auto& v : seq)
      |                            ^
      |                             {
   20 |     emitter << v;
      |                  
   26 | inline Emitter& operator<<(Emitter& emitter, const std::vector<T>& v) {
      |        ~~~~~~~~ ^
      |        auto                                                           -> Emitter&
   26 | inline Emitter& operator<<(Emitter& emitter, const std::vector<T>& v) {
      |                                                                    ^
   31 | inline Emitter& operator<<(Emitter& emitter, const std::list<T>& v) {
      |        ~~~~~~~~ ^
      |        auto                                                         -> Emitter&
   31 | inline Emitter& operator<<(Emitter& emitter, const std::list<T>& v) {
      |                                                                  ^
   36 | inline Emitter& operator<<(Emitter& emitter, const std::set<T>& v) {
      |        ~~~~~~~~ ^
      |        auto                                                        -> Emitter&
   36 | inline Emitter& operator<<(Emitter& emitter, const std::set<T>& v) {
      |                                                                 ^
   41 | inline Emitter& operator<<(Emitter& emitter, const std::map<K, V>& m) {
      |        ~~~~~~~~ ^
      |        auto                                                           -> Emitter&
   41 | inline Emitter& operator<<(Emitter& emitter, const std::map<K, V>& m) {
      |                                                                    ^
   43 |   for (const auto& v : m)
      |   ^
   43 |   for (const auto& v : m)
      |                    ^
   43 |   for (const auto& v : m)
      |                          ^
      |                           {
   44 |     emitter << Key << v.first << Value << v.second;
      |                                                    
   48 | }
      | ^
      |   // namespace YAML
   15 | namespace YAML {
      |           ^
    7 | #pragma once
      | ^
   10 | #include <type_traits>
      | ^        ~~~~~~~~~~~~~
   11 | #include <utility>
      |          ~~~~~~~~~
   12 | #include <string>
      |          ~~~~~~~~
   13 | #include <sstream>
      |          ~~~~~~~~~
   17 | struct is_numeric {
      |        ^~~~~~~~~~
      |        IsNumeric
   18 |   enum { value = false };
      |   ^
   23 |   enum { value = true };
      |   ^
   23 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   27 |   enum { value = true };
      |   ^
   27 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   31 |   enum { value = true };
      |   ^
   31 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   35 |   enum { value = true };
      |   ^
   35 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   39 |   enum { value = true };
      |   ^
   39 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   43 |   enum { value = true };
      |   ^
   43 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   47 |   enum { value = true };
      |   ^
   47 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   51 |   enum { value = true };
      |   ^
   51 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   65 |   enum { value = true };
      |   ^
   65 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   69 |   enum { value = true };
      |   ^
   69 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   74 |   enum { value = true };
      |   ^
   74 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   78 |   enum { value = true };
      |   ^
   78 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   82 |   enum { value = true };
      |   ^
   82 |   enum { value = true };
      |                  ^
      |                  static_cast<int>( )
   86 | struct enable_if_c {
      |        ^~~~~~~~~~~
      |        EnableIfC
   87 |   using type = T;
   88 | };
   89 | 
   90 | template <class T>
   91 | struct enable_if_c<false, T> {};
   92 | 
   93 | template <class Cond, class T = void>
   94 | struct enable_if : public enable_if_c<Cond::value, T> {};
      |                           ~~~~~~~~~~~
      |                           EnableIfC
   94 | struct enable_if : public enable_if_c<Cond::value, T> {};
      |        ^~~~~~~~~
      |        EnableIf
   97 | struct disable_if_c {
      |        ^~~~~~~~~~~~
      |        DisableIfC
   98 |   using type = T;
   99 | };
  100 | 
  101 | template <class T>
  102 | struct disable_if_c<true, T> {};
  103 | 
  104 | template <class Cond, class T = void>
  105 | struct disable_if : public disable_if_c<Cond::value, T> {};
      |                            ~~~~~~~~~~~~
      |                            DisableIfC
  105 | struct disable_if : public disable_if_c<Cond::value, T> {};
      |        ^~~~~~~~~~
      |        DisableIf
  106 | }
      | ^
      |   // namespace YAML
   15 | namespace YAML {
      |           ^
  109 | struct is_streamable {
      |        ^~~~~~~~~~~~~
      |        IsStreamable
  121 | struct streamable_to_string {
      |        ^~~~~~~~~~~~~~~~~~~~
      |        StreamableToString
  122 |   static std::string impl(const Key& key) {
      |          ~~~~~~~~~~~ ^
      |          auto                             -> std::string
  123 |     std::stringstream ss;
      |                       ^
  131 |   static std::string impl(const Key&) {
      |          ~~~~~~~~~~~ ^
      |          auto                         -> std::string
  131 |   static std::string impl(const Key&) {
      |                                     ^
      |                                      /*unused*/
    7 | #pragma once
      | ^
   10 | #include "yaml-cpp/parser.h"
      | ^        ~~~~~~~~~~~~~~~~~~~
   11 | #include "yaml-cpp/emitter.h"
      |          ~~~~~~~~~~~~~~~~~~~~
   12 | #include "yaml-cpp/emitterstyle.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~
   13 | #include "yaml-cpp/stlemitter.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~
   14 | #include "yaml-cpp/exceptions.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~
   16 | #include "yaml-cpp/node/node.h"
      | ^        ~~~~~~~~~~~~~~~~~~~~~~
   17 | #include "yaml-cpp/node/impl.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~
   18 | #include "yaml-cpp/node/convert.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~
   19 | #include "yaml-cpp/node/iterator.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~
   20 | #include "yaml-cpp/node/detail/impl.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   21 | #include "yaml-cpp/node/parse.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~~
   22 | #include "yaml-cpp/node/emit.h"
      |          ~~~~~~~~~~~~~~~~~~~~~~
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:38:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   38 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:56:11: error: invalid case style for namespace 'cwf' [readability-identifier-naming,-warnings-as-errors]
   56 | namespace cwf::config
      |           ^~~
      |           Cwf
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:56:16: error: invalid case style for namespace 'config' [readability-identifier-naming,-warnings-as-errors]
   56 | namespace cwf::config
      |                ^~~~~~
      |                Config
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: error: accessing fields in struct 'ConfigError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   83 | struct ConfigError
      |        ^
   84 | {
   85 |     std::string              message; ///< spicy human-readable error message uwu
   86 |     std::vector<std::string> context; ///< breadcrumb trail showing where things derailed
   87 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: note: use "__attribute__((aligned(64)))" to align struct 'ConfigError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: error: accessing fields in struct 'Material' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   97 | struct Material
      |        ^
   98 | {
   99 |     std::string name;           ///< unique material nickname, referenced in assignments
  100 |     double      youngs_modulus; ///< E [Pa], must be > 0
  101 |     double      poisson_ratio;  ///< nu [-], typically 0 < nu < 0.5
  102 |     double      density;        ///< rho [kg/m^3], must be > 0
  103 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: note: use "__attribute__((aligned(64)))" to align struct 'Material' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: error: accessing fields in struct 'Assignment' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  108 | struct Assignment
      |        ^
  109 | {
  110 |     std::string group;    ///< physical group name from mesh (e.g., "SOLID")
  111 |     std::string material; ///< material name defined in materials list
  112 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: note: use "__attribute__((aligned(64)))" to align struct 'Assignment' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: error: accessing fields in struct 'Damping' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  119 | struct Damping
      |        ^
  120 | {
  121 |     double xi; ///< damping ratio target (0.0 - 1.0 typically)
  122 |     double w1; ///< lower angular frequency for Rayleigh fit [rad/s]
  123 |     double w2; ///< upper angular frequency [rad/s]
  124 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: note: use "__attribute__((aligned(32)))" to align struct 'Damping' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: error: accessing fields in struct 'TimeSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  129 | struct TimeSettings
      |        ^
  130 | {
  131 |     double initial_dt; ///< starting timestep [s]
  132 |     bool   adaptive;   ///< enable adaptive dt policies per spec
  133 |     double min_dt;     ///< optional safety clamp (0 if unspecified)
  134 |     double max_dt;     ///< optional safety clamp (> initial dt for safety)
  135 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: note: use "__attribute__((aligned(32)))" to align struct 'TimeSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to padding; only needs 84 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'SolverSettings'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((aligned(128)))" to align struct 'SolverSettings' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: error: accessing fields in struct 'PrecisionSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  152 | struct PrecisionSettings
      |        ^
  153 | {
  154 |     std::string vector_precision;    ///< e.g., "fp32"
  155 |     std::string reduction_precision; ///< e.g., "fp64"
  156 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: note: use "__attribute__((aligned(64)))" to align struct 'PrecisionSettings' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: error: accessing fields in struct 'Curve' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  161 | struct Curve
      |        ^
  162 | {
  163 |     std::vector<std::pair<double, double>> points; ///< (time, value) pairs sorted by time
  164 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: note: use "__attribute__((aligned(32)))" to align struct 'Curve' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: error: accessing fields in struct 'SurfaceTraction' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  169 | struct SurfaceTraction
      |        ^
  170 | {
  171 |     std::string           group;       ///< surface physical group name
  172 |     std::array<double, 3> value;       ///< traction direction + magnitude [Pa]
  173 |     std::string           scale_curve; ///< optional curve id ("" if constant)
  174 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: note: use "__attribute__((aligned(128)))" to align struct 'SurfaceTraction' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: error: accessing fields in struct 'Loads' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  179 | struct Loads
      |        ^
  180 | {
  181 |     std::array<double, 3>        gravity;   ///< global gravity vector [m/s^2]
  182 |     std::vector<SurfaceTraction> tractions; ///< list of surface loads
  183 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: note: use "__attribute__((aligned(64)))" to align struct 'Loads' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to padding; only needs 83 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'DirichletFix'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((aligned(128)))" to align struct 'DirichletFix' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: error: accessing fields in struct 'OutputSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  198 | struct OutputSettings
      |        ^
  199 | {
  200 |     std::uint32_t              vtu_stride; ///< write VTU every N frames (>= 1)
  201 |     std::vector<std::uint32_t> probes;     ///< node indices to track
  202 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: note: use "__attribute__((aligned(32)))" to align struct 'OutputSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: error: accessing fields in struct 'Config' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  207 | struct Config
      |        ^
  208 | {
  209 |     std::filesystem::path                  mesh_path;   ///< path to mesh (relative allowed)
  210 |     std::vector<Material>                  materials;   ///< materials registry
  211 |     std::vector<Assignment>                assignments; ///< physical group  material mapping
  212 |     Damping                                damping;     ///< Rayleigh damping spec
  213 |     TimeSettings                           time;        ///< time stepping configuration
  214 |     SolverSettings                         solver;      ///< solver knobs (PCG etc.)
  215 |     PrecisionSettings                      precision;   ///< precision toggles
  216 |     Loads                                  loads;       ///< body + surface loads
  217 |     std::unordered_map<std::string, Curve> curves;      ///< time history curves
  218 |     std::vector<DirichletFix>              dirichlet;   ///< locked DoFs definitions
  219 |     OutputSettings                         output;      ///< post-processing preferences
  220 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: note: use "__attribute__((aligned(128)))" to align struct 'Config' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:255:20: error: invalid case style for function 'load_config_from_file' [readability-identifier-naming,-warnings-as-errors]
  255 | [[nodiscard]] auto load_config_from_file(const std::filesystem::path &path) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromFile
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:268:20: error: invalid case style for function 'load_config_from_string' [readability-identifier-naming,-warnings-as-errors]
  268 | [[nodiscard]] auto load_config_from_string(std::string_view yaml_text) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromString
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:281:20: error: invalid case style for function 'parse_config_node' [readability-identifier-naming,-warnings-as-errors]
  281 | [[nodiscard]] auto parse_config_node(const YAML::Node &root) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~
      |                    parseConfigNode
C:\Dev\CiviWave-FEM\src\config\config.cpp:12:1: error: included header charconv is not used directly [misc-include-cleaner,-warnings-as-errors]
   12 | #include <charconv>
      | ^~~~~~~~~~~~~~~~~~~
   13 | #include <cmath>
C:\Dev\CiviWave-FEM\src\config\config.cpp:13:1: error: included header cmath is not used directly [misc-include-cleaner,-warnings-as-errors]
   13 | #include <cmath>
      | ^~~~~~~~~~~~~~~~
   14 | #include <format>
C:\Dev\CiviWave-FEM\src\config\config.cpp:15:1: error: included header stdexcept is not used directly [misc-include-cleaner,-warnings-as-errors]
   15 | #include <stdexcept>
      | ^~~~~~~~~~~~~~~~~~~~
   16 | #include <yaml-cpp/yaml.h>
C:\Dev\CiviWave-FEM\src\config\config.cpp:16:1: error: included header yaml.h is not used directly [misc-include-cleaner,-warnings-as-errors]
   16 | #include <yaml-cpp/yaml.h>
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~
   17 | 
C:\Dev\CiviWave-FEM\src\config\config.cpp:23:20: error: function 'make_error' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   23 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx) -> ConfigResult
      |                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:23:20: error: invalid case style for function 'make_error' [readability-identifier-naming,-warnings-as-errors]
   23 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx) -> ConfigResult
      |                    ^~~~~~~~~~
      |                    makeError
   24 | {
   25 |     return std::unexpected(ConfigError{std::move(message), std::move(ctx)});
   26 | }
   27 | 
   28 | [[nodiscard]] auto make_scalar_error(const std::string &expectation, std::vector<std::string> ctx)
   29 |     -> ConfigResult
   30 | {
   31 |     return make_error(expectation, std::move(ctx));
      |            ~~~~~~~~~~
      |            makeError
C:\Dev\CiviWave-FEM\src\config\config.cpp:23:36: error: no header providing "std::string" is directly included [misc-include-cleaner,-warnings-as-errors]
   16 | #include <yaml-cpp/yaml.h>
   17 | 
   18 | namespace cwf::config
   19 | {
   20 | namespace
   21 | {
   22 | 
   23 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx) -> ConfigResult
      |                                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:23:57: error: no header providing "std::vector" is directly included [misc-include-cleaner,-warnings-as-errors]
   16 | #include <yaml-cpp/yaml.h>
   17 | 
   18 | namespace cwf::config
   19 | {
   20 | namespace
   21 | {
   22 | 
   23 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx) -> ConfigResult
      |                                                         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:25:17: error: no header providing "std::unexpected" is directly included [misc-include-cleaner,-warnings-as-errors]
   14 | #include <format>
   15 | #include <stdexcept>
   16 | #include <yaml-cpp/yaml.h>
   17 | 
   18 | namespace cwf::config
   19 | {
   20 | namespace
   21 | {
   22 | 
   23 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx) -> ConfigResult
   24 | {
   25 |     return std::unexpected(ConfigError{std::move(message), std::move(ctx)});
      |                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:25:39: error: use designated initializer list to initialize 'ConfigError' [modernize-use-designated-initializers,-warnings-as-errors]
   25 |     return std::unexpected(ConfigError{std::move(message), std::move(ctx)});
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                        .message=           .context=
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:1: note: aggregate type is defined here
   83 | struct ConfigError
      | ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:25:45: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
   16 | #include <yaml-cpp/yaml.h>
   17 | 
   18 | namespace cwf::config
   19 | {
   20 | namespace
   21 | {
   22 | 
   23 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx) -> ConfigResult
   24 | {
   25 |     return std::unexpected(ConfigError{std::move(message), std::move(ctx)});
      |                                             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:25:65: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
   25 |     return std::unexpected(ConfigError{std::move(message), std::move(ctx)});
      |                                                                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:28:20: error: function 'make_scalar_error' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   28 | [[nodiscard]] auto make_scalar_error(const std::string &expectation, std::vector<std::string> ctx)
      |                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:28:20: error: invalid case style for function 'make_scalar_error' [readability-identifier-naming,-warnings-as-errors]
   28 | [[nodiscard]] auto make_scalar_error(const std::string &expectation, std::vector<std::string> ctx)
      |                    ^~~~~~~~~~~~~~~~~
      |                    makeScalarError
C:\Dev\CiviWave-FEM\src\config\config.cpp:34:20: error: function 'node_to_vec3' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   34 | [[nodiscard]] auto node_to_vec3(const YAML::Node &node, std::vector<std::string> ctx)
      |                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:34:20: error: invalid case style for function 'node_to_vec3' [readability-identifier-naming,-warnings-as-errors]
   34 | [[nodiscard]] auto node_to_vec3(const YAML::Node &node, std::vector<std::string> ctx)
      |                    ^~~~~~~~~~~~
      |                    nodeToVec3
C:\Dev\CiviWave-FEM\src\config\config.cpp:35:13: error: no header providing "std::expected" is directly included [misc-include-cleaner,-warnings-as-errors]
   35 |     -> std::expected<std::array<double, 3>, ConfigError>
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:35:27: error: no header providing "std::array" is directly included [misc-include-cleaner,-warnings-as-errors]
   12 |     -> std::expected<std::array<double, 3>, ConfigError>
      |                           ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:39:43: error: use designated initializer list to initialize 'ConfigError' [modernize-use-designated-initializers,-warnings-as-errors]
   39 |         return std::unexpected(ConfigError{"expected sequence[3] for vector", std::move(ctx)});
      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                            .message=                          .context=
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:1: note: aggregate type is defined here
   83 | struct ConfigError
      | ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:42:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   42 |     for (std::size_t i = 0; i < 3; ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:42:15: error: no header providing "std::size_t" is directly included [misc-include-cleaner,-warnings-as-errors]
   14 |     for (std::size_t i = 0; i < 3; ++i)
      |               ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:44:9: error: cannot use 'try' with exceptions disabled [clang-diagnostic-error]
   44 |         try
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:46:13: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
   46 |             values[i] = node[i].as<double>();
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:48:28: error: no header providing "YAML::Exception" is directly included [misc-include-cleaner,-warnings-as-errors]
   17 |         catch (const YAML::Exception &ex)
      |                            ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:52:47: error: use designated initializer list to initialize 'ConfigError' [modernize-use-designated-initializers,-warnings-as-errors]
   52 |             return std::unexpected(ConfigError{ex.what(), std::move(child_ctx)});
      |                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                                .message=  .context=
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:1: note: aggregate type is defined here
   83 | struct ConfigError
      | ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:58:20: error: function 'node_to_optional_vec3' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   58 | [[nodiscard]] auto node_to_optional_vec3(const YAML::Node &node, std::vector<std::string> ctx)
      |                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:58:20: error: invalid case style for function 'node_to_optional_vec3' [readability-identifier-naming,-warnings-as-errors]
   58 | [[nodiscard]] auto node_to_optional_vec3(const YAML::Node &node, std::vector<std::string> ctx)
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    nodeToOptionalVec3
C:\Dev\CiviWave-FEM\src\config\config.cpp:59:38: error: no header providing "std::optional" is directly included [misc-include-cleaner,-warnings-as-errors]
   15 |     -> std::expected<std::array<std::optional<double>, 3>, ConfigError>
      |                                      ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:68:43: error: use designated initializer list to initialize 'ConfigError' [modernize-use-designated-initializers,-warnings-as-errors]
   68 |         return std::unexpected(ConfigError{"expected sequence[3] for value override", std::move(ctx)});
      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                            .message=                                  .context=
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:1: note: aggregate type is defined here
   83 | struct ConfigError
      | ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:70:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   70 |     for (std::size_t i = 0; i < 3; ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:74:13: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
   74 |             result[i] = std::nullopt;
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:74:30: error: no header providing "std::nullopt" is directly included [misc-include-cleaner,-warnings-as-errors]
   74 |             result[i] = std::nullopt;
      |                              ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:77:9: error: cannot use 'try' with exceptions disabled [clang-diagnostic-error]
   77 |         try
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:79:13: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
   79 |             result[i] = node[i].as<double>();
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:85:47: error: use designated initializer list to initialize 'ConfigError' [modernize-use-designated-initializers,-warnings-as-errors]
   85 |             return std::unexpected(ConfigError{ex.what(), std::move(child_ctx)});
      |                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                                .message=  .context=
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:1: note: aggregate type is defined here
   83 | struct ConfigError
      | ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:91:20: error: function 'node_to_string_vec' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   91 | [[nodiscard]] auto node_to_string_vec(const YAML::Node &node, std::vector<std::string> ctx)
      |                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:91:20: error: invalid case style for function 'node_to_string_vec' [readability-identifier-naming,-warnings-as-errors]
   91 | [[nodiscard]] auto node_to_string_vec(const YAML::Node &node, std::vector<std::string> ctx)
      |                    ^~~~~~~~~~~~~~~~~~
      |                    nodeToStringVec
C:\Dev\CiviWave-FEM\src\config\config.cpp:96:43: error: use designated initializer list to initialize 'ConfigError' [modernize-use-designated-initializers,-warnings-as-errors]
   96 |         return std::unexpected(ConfigError{"expected sequence for string list", std::move(ctx)});
      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                            .message=                            .context=
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:1: note: aggregate type is defined here
   83 | struct ConfigError
      | ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:100:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  100 |     for (std::size_t i = 0; i < node.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:102:9: error: cannot use 'try' with exceptions disabled [clang-diagnostic-error]
  102 |         try
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:110:47: error: use designated initializer list to initialize 'ConfigError' [modernize-use-designated-initializers,-warnings-as-errors]
  110 |             return std::unexpected(ConfigError{ex.what(), std::move(child_ctx)});
      |                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                                .message=  .context=
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:1: note: aggregate type is defined here
   83 | struct ConfigError
      | ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:118:51: error: no header providing "std::filesystem::path" is directly included [misc-include-cleaner,-warnings-as-errors]
   14 | auto load_config_from_file(const std::filesystem::path &path) -> ConfigResult
      |                                                   ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:120:5: error: cannot use 'try' with exceptions disabled [clang-diagnostic-error]
  120 |     try
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:122:33: error: no header providing "YAML::LoadFile" is directly included [misc-include-cleaner,-warnings-as-errors]
   17 |         const auto node = YAML::LoadFile(path.string());
      |                                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:125:24: error: no header providing "YAML::BadFile" is directly included [misc-include-cleaner,-warnings-as-errors]
  125 |     catch (const YAML::BadFile &ex)
      |                        ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:135:35: error: no header providing "std::string_view" is directly included [misc-include-cleaner,-warnings-as-errors]
   16 | auto load_config_from_string(std::string_view yaml_text) -> ConfigResult
      |                                   ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:137:5: error: cannot use 'try' with exceptions disabled [clang-diagnostic-error]
  137 |     try
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:139:33: error: no header providing "YAML::Load" is directly included [misc-include-cleaner,-warnings-as-errors]
  139 |         const auto node = YAML::Load(yaml_text.data());
      |                                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:139:48: error: result of a `data()` call may not be null terminated, provide size information to the callee to prevent potential issues [bugprone-suspicious-stringview-data-usage,-warnings-as-errors]
  139 |         const auto node = YAML::Load(yaml_text.data());
      |                                      ~~~~~~~~~~^~~~
C:\Dev\CiviWave-FEM\src\config\config.cpp:148:6: error: function 'parse_config_node' has cognitive complexity of 117 (threshold 25) [readability-function-cognitive-complexity,-warnings-as-errors]
  148 | auto parse_config_node(const YAML::Node &root) -> ConfigResult
      |      ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:150:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  150 |     if (!root || !root.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:150:15: note: +1
  150 |     if (!root || !root.IsMap())
      |               ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:159:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  159 |     if (!mesh_node || !mesh_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:159:20: note: +1
  159 |     if (!mesh_node || !mesh_node.IsMap())
      |                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:164:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  164 |     if (!mesh_path_node || !mesh_path_node.IsScalar())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:164:25: note: +1
  164 |     if (!mesh_path_node || !mesh_path_node.IsScalar())
      |                         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:172:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  172 |     if (!materials_node || !materials_node.IsSequence() || materials_node.size() == 0U)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:172:57: note: +1
  172 |     if (!materials_node || !materials_node.IsSequence() || materials_node.size() == 0U)
      |                                                         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:178:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  178 |     for (std::size_t i = 0; i < materials_node.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:181:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  181 |         if (!node.IsMap())
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:193:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  193 |         catch (const YAML::Exception &ex)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:198:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  198 |         if (mat.youngs_modulus <= 0.0)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:202:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  202 |         if (mat.poisson_ratio <= -0.999 || mat.poisson_ratio >= 0.5)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:202:41: note: +1
  202 |         if (mat.poisson_ratio <= -0.999 || mat.poisson_ratio >= 0.5)
      |                                         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:207:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  207 |         if (mat.density <= 0.0)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:211:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  211 |         if (material_index.contains(mat.name))
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:221:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  221 |     if (!assignments_node || !assignments_node.IsSequence() || assignments_node.size() == 0U)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:221:61: note: +1
  221 |     if (!assignments_node || !assignments_node.IsSequence() || assignments_node.size() == 0U)
      |                                                             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:226:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  226 |     for (std::size_t i = 0; i < assignments_node.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:229:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  229 |         if (!node.IsMap())
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:239:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  239 |         catch (const YAML::Exception &ex)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:243:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  243 |         if (!material_index.contains(a.material))
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:253:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  253 |     if (!damping_node || !damping_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:253:23: note: +1
  253 |     if (!damping_node || !damping_node.IsMap())
      |                       ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:263:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  263 |     catch (const YAML::Exception &ex)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:267:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  267 |     if (cfg.damping.xi <= 0.0 || cfg.damping.xi >= 1.0)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:267:31: note: +1
  267 |     if (cfg.damping.xi <= 0.0 || cfg.damping.xi >= 1.0)
      |                               ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:271:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  271 |     if (cfg.damping.w1 <= 0.0)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:275:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  275 |     if (cfg.damping.w2 <= cfg.damping.w1)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:282:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  282 |     if (!time_node || !time_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:282:20: note: +1
  282 |     if (!time_node || !time_node.IsMap())
      |                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:291:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  291 |     catch (const YAML::Exception &ex)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:298:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  298 |     if (cfg.time.initial_dt <= 0.0)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:302:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  302 |     if (cfg.time.min_dt < 0.0)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:306:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  306 |     if (cfg.time.max_dt < cfg.time.initial_dt)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:313:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  313 |     if (!solver_node || !solver_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:313:22: note: +1
  313 |     if (!solver_node || !solver_node.IsMap())
      |                      ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:325:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  325 |     catch (const YAML::Exception &ex)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:329:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  329 |     if (cfg.solver.max_iterations == 0U)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:333:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  333 |     if (cfg.solver.runtime_tolerance <= 0.0 || cfg.solver.pause_tolerance <= 0.0)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:333:45: note: +1
  333 |     if (cfg.solver.runtime_tolerance <= 0.0 || cfg.solver.pause_tolerance <= 0.0)
      |                                             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:340:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  340 |     if (!precision_node || !precision_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:340:25: note: +1
  340 |     if (!precision_node || !precision_node.IsMap())
      |                         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:349:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  349 |     catch (const YAML::Exception &ex)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:356:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  356 |     if (curves_node && curves_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:356:21: note: +1
  356 |     if (curves_node && curves_node.IsMap())
      |                     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:402:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  402 |     if (!loads_node || !loads_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:402:21: note: +1
  402 |     if (!loads_node || !loads_node.IsMap())
      |                     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:408:9: note: +1, including nesting penalty of 0, nesting level increased to 1
  408 |         if (!gravity_result)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:415:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  415 |     if (tractions_node && tractions_node.IsSequence())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:415:24: note: +1
  415 |     if (tractions_node && tractions_node.IsSequence())
      |                        ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:418:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  418 |         for (std::size_t i = 0; i < tractions_node.size(); ++i)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:421:13: note: +3, including nesting penalty of 2, nesting level increased to 3
  421 |             if (!entry.IsMap())
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:431:54: note: +3, including nesting penalty of 2, nesting level increased to 3
  431 |                     entry["scale_curve"].IsDefined() ? entry["scale_curve"].as<std::string>() : std::string{};
      |                                                      ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:433:13: note: +3, including nesting penalty of 2, nesting level increased to 3
  433 |             catch (const YAML::Exception &ex)
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:439:13: note: +3, including nesting penalty of 2, nesting level increased to 3
  439 |             if (!val_result)
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:444:13: note: +3, including nesting penalty of 2, nesting level increased to 3
  444 |             if (!traction.scale_curve.empty() && !cfg.curves.contains(traction.scale_curve))
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:444:47: note: +1
  444 |             if (!traction.scale_curve.empty() && !cfg.curves.contains(traction.scale_curve))
      |                                               ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:455:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  455 |     if (dirichlet_node && dirichlet_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:455:24: note: +1
  455 |     if (dirichlet_node && dirichlet_node.IsMap())
      |                        ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:458:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  458 |         if (fixes_node && fixes_node.IsSequence())
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:458:24: note: +1
  458 |         if (fixes_node && fixes_node.IsSequence())
      |                        ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:461:13: note: +3, including nesting penalty of 2, nesting level increased to 3
  461 |             for (std::size_t i = 0; i < fixes_node.size(); ++i)
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:464:17: note: +4, including nesting penalty of 3, nesting level increased to 4
  464 |                 if (!entry.IsMap())
      |                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:474:17: note: +4, including nesting penalty of 3, nesting level increased to 4
  474 |                 catch (const YAML::Exception &ex)
      |                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:480:17: note: +4, including nesting penalty of 3, nesting level increased to 4
  480 |                 if (!dof_result)
      |                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:484:17: note: +4, including nesting penalty of 3, nesting level increased to 4
  484 |                 if (dof_result->empty())
      |                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:512:17: note: +4, including nesting penalty of 3, nesting level increased to 4
  512 |                 if (!value_result)
      |                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:524:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  524 |     if (!output_node || !output_node.IsMap())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:524:22: note: +1
  524 |     if (!output_node || !output_node.IsMap())
      |                      ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:532:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  532 |     catch (const YAML::Exception &ex)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:536:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  536 |     if (cfg.output.vtu_stride == 0U)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:541:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  541 |     if (probes_node && probes_node.IsSequence())
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:541:21: note: +1
  541 |     if (probes_node && probes_node.IsSequence())
      |                     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:544:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  544 |         for (std::size_t i = 0; i < probes_node.size(); ++i)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:550:13: note: +3, including nesting penalty of 2, nesting level increased to 3
  550 |             catch (const YAML::Exception &ex)
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:177:10: error: no header providing "std::unordered_map" is directly included [misc-include-cleaner,-warnings-as-errors]
   16 |     std::unordered_map<std::string, std::size_t> material_index;
      |          ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:178:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  178 |     for (std::size_t i = 0; i < materials_node.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:178:29: error: backward branch (for loop) is ID-dependent due to variable reference to 'materials_node' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
  178 |     for (std::size_t i = 0; i < materials_node.size(); ++i)
      |                             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:171:5: note: inferred assignment of ID-dependent value from ID-dependent 
  171 |     const auto materials_node = root["materials"];
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:186:9: error: cannot use 'try' with exceptions disabled [clang-diagnostic-error]
  186 |         try
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:202:35: error: 0.999 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  202 |         if (mat.poisson_ratio <= -0.999 || mat.poisson_ratio >= 0.5)
      |                                   ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:202:65: error: 0.5 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  202 |         if (mat.poisson_ratio <= -0.999 || mat.poisson_ratio >= 0.5)
      |                                                                 ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:216:38: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  216 |         cfg.materials.push_back(std::move(mat));
      |                                      ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:226:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  226 |     for (std::size_t i = 0; i < assignments_node.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:226:29: error: backward branch (for loop) is ID-dependent due to variable reference to 'assignments_node' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
  226 |     for (std::size_t i = 0; i < assignments_node.size(); ++i)
      |                             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:220:5: note: inferred assignment of ID-dependent value from ID-dependent 
  220 |     const auto assignments_node = root["assignments"];
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:233:20: error: variable name 'a' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  233 |         Assignment a{};
      |                    ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:234:9: error: cannot use 'try' with exceptions disabled [clang-diagnostic-error]
  234 |         try
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:248:40: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  248 |         cfg.assignments.push_back(std::move(a));
      |                                        ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:257:5: error: cannot use 'try' with exceptions disabled [clang-diagnostic-error]
  257 |     try
      |     ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:323:73: error: no header providing "std::uint32_t" is directly included [misc-include-cleaner,-warnings-as-errors]
   14 |         cfg.solver.max_iterations    = solver_node["max_iters"].as<std::uint32_t>();
      |                                                                         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:418:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  418 |         for (std::size_t i = 0; i < tractions_node.size(); ++i)
      |         ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:461:13: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  461 |             for (std::size_t i = 0; i < fixes_node.size(); ++i)
      |             ^
C:\Dev\CiviWave-FEM\src\config\config.cpp:544:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  544 |         for (std::size_t i = 0; i < probes_node.size(); ++i)
      |         ^
Suppressed 108112 warnings (108112 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
1303 warnings treated as errors

File: .\src\mesh\preprocess.cpp
109106 warnings and 3 errors generated.
Error while processing C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp.
error: unknown argument: '-fdeps-format=p1689r5' [clang-diagnostic-error]
error: unknown argument: '-fmodule-mapper=src\CMakeFiles\cwf_core.dir\mesh\preprocess.cpp.obj.modmap' [clang-diagnostic-error]
error: unknown argument: '-fmodules-ts' [clang-diagnostic-error]
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:36:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   36 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:11: error: invalid case style for namespace 'cwf' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |           ^~~
      |           Cwf
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:16: error: invalid case style for namespace 'common' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |                ^~~~~~
      |                Common
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:181:27: error: invalid case style for function 'safe_normalize' [readability-identifier-naming,-warnings-as-errors]
  181 | [[nodiscard]] inline auto safe_normalize(const Vec3 &value) noexcept -> Vec3
      |                           ^~~~~~~~~~~~~~
      |                           safeNormalize
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:183:22: error: invalid case style for variable 'kThreshold' [readability-identifier-naming,-warnings-as-errors]
  183 |     constexpr double kThreshold = 1.0e-12;
      |                      ^~~~~~~~~~
      |                      k_threshold
  184 |     const auto       mag        = magnitude(value);
  185 |     if (mag < kThreshold || !std::isfinite(mag))
      |               ~~~~~~~~~~
      |               k_threshold
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:38:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   38 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:56:16: error: invalid case style for namespace 'config' [readability-identifier-naming,-warnings-as-errors]
   56 | namespace cwf::config
      |                ^~~~~~
      |                Config
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: error: accessing fields in struct 'ConfigError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   83 | struct ConfigError
      |        ^
   84 | {
   85 |     std::string              message; ///< spicy human-readable error message uwu
   86 |     std::vector<std::string> context; ///< breadcrumb trail showing where things derailed
   87 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: note: use "__attribute__((aligned(64)))" to align struct 'ConfigError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: error: accessing fields in struct 'Material' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   97 | struct Material
      |        ^
   98 | {
   99 |     std::string name;           ///< unique material nickname, referenced in assignments
  100 |     double      youngs_modulus; ///< E [Pa], must be > 0
  101 |     double      poisson_ratio;  ///< nu [-], typically 0 < nu < 0.5
  102 |     double      density;        ///< rho [kg/m^3], must be > 0
  103 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: note: use "__attribute__((aligned(64)))" to align struct 'Material' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: error: accessing fields in struct 'Assignment' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  108 | struct Assignment
      |        ^
  109 | {
  110 |     std::string group;    ///< physical group name from mesh (e.g., "SOLID")
  111 |     std::string material; ///< material name defined in materials list
  112 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: note: use "__attribute__((aligned(64)))" to align struct 'Assignment' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: error: accessing fields in struct 'Damping' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  119 | struct Damping
      |        ^
  120 | {
  121 |     double xi; ///< damping ratio target (0.0 - 1.0 typically)
  122 |     double w1; ///< lower angular frequency for Rayleigh fit [rad/s]
  123 |     double w2; ///< upper angular frequency [rad/s]
  124 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: note: use "__attribute__((aligned(32)))" to align struct 'Damping' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: error: accessing fields in struct 'TimeSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  129 | struct TimeSettings
      |        ^
  130 | {
  131 |     double initial_dt; ///< starting timestep [s]
  132 |     bool   adaptive;   ///< enable adaptive dt policies per spec
  133 |     double min_dt;     ///< optional safety clamp (0 if unspecified)
  134 |     double max_dt;     ///< optional safety clamp (> initial dt for safety)
  135 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: note: use "__attribute__((aligned(32)))" to align struct 'TimeSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to padding; only needs 84 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'SolverSettings'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((aligned(128)))" to align struct 'SolverSettings' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: error: accessing fields in struct 'PrecisionSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  152 | struct PrecisionSettings
      |        ^
  153 | {
  154 |     std::string vector_precision;    ///< e.g., "fp32"
  155 |     std::string reduction_precision; ///< e.g., "fp64"
  156 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: note: use "__attribute__((aligned(64)))" to align struct 'PrecisionSettings' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: error: accessing fields in struct 'Curve' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  161 | struct Curve
      |        ^
  162 | {
  163 |     std::vector<std::pair<double, double>> points; ///< (time, value) pairs sorted by time
  164 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: note: use "__attribute__((aligned(32)))" to align struct 'Curve' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: error: accessing fields in struct 'SurfaceTraction' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  169 | struct SurfaceTraction
      |        ^
  170 | {
  171 |     std::string           group;       ///< surface physical group name
  172 |     std::array<double, 3> value;       ///< traction direction + magnitude [Pa]
  173 |     std::string           scale_curve; ///< optional curve id ("" if constant)
  174 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: note: use "__attribute__((aligned(128)))" to align struct 'SurfaceTraction' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: error: accessing fields in struct 'Loads' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  179 | struct Loads
      |        ^
  180 | {
  181 |     std::array<double, 3>        gravity;   ///< global gravity vector [m/s^2]
  182 |     std::vector<SurfaceTraction> tractions; ///< list of surface loads
  183 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: note: use "__attribute__((aligned(64)))" to align struct 'Loads' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to padding; only needs 83 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'DirichletFix'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((aligned(128)))" to align struct 'DirichletFix' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: error: accessing fields in struct 'OutputSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  198 | struct OutputSettings
      |        ^
  199 | {
  200 |     std::uint32_t              vtu_stride; ///< write VTU every N frames (>= 1)
  201 |     std::vector<std::uint32_t> probes;     ///< node indices to track
  202 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: note: use "__attribute__((aligned(32)))" to align struct 'OutputSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: error: accessing fields in struct 'Config' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  207 | struct Config
      |        ^
  208 | {
  209 |     std::filesystem::path                  mesh_path;   ///< path to mesh (relative allowed)
  210 |     std::vector<Material>                  materials;   ///< materials registry
  211 |     std::vector<Assignment>                assignments; ///< physical group  material mapping
  212 |     Damping                                damping;     ///< Rayleigh damping spec
  213 |     TimeSettings                           time;        ///< time stepping configuration
  214 |     SolverSettings                         solver;      ///< solver knobs (PCG etc.)
  215 |     PrecisionSettings                      precision;   ///< precision toggles
  216 |     Loads                                  loads;       ///< body + surface loads
  217 |     std::unordered_map<std::string, Curve> curves;      ///< time history curves
  218 |     std::vector<DirichletFix>              dirichlet;   ///< locked DoFs definitions
  219 |     OutputSettings                         output;      ///< post-processing preferences
  220 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: note: use "__attribute__((aligned(128)))" to align struct 'Config' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:255:20: error: invalid case style for function 'load_config_from_file' [readability-identifier-naming,-warnings-as-errors]
  255 | [[nodiscard]] auto load_config_from_file(const std::filesystem::path &path) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromFile
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:268:20: error: invalid case style for function 'load_config_from_string' [readability-identifier-naming,-warnings-as-errors]
  268 | [[nodiscard]] auto load_config_from_string(std::string_view yaml_text) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromString
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:281:20: error: invalid case style for function 'parse_config_node' [readability-identifier-naming,-warnings-as-errors]
  281 | [[nodiscard]] auto parse_config_node(const YAML::Node &root) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~
      |                    parseConfigNode
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:30:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   30 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:42:16: error: invalid case style for namespace 'mesh' [readability-identifier-naming,-warnings-as-errors]
   42 | namespace cwf::mesh
      |                ^~~~
      |                Mesh
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:8: error: accessing fields in struct 'MeshError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   48 | struct MeshError
      |        ^
   49 | {
   50 |     std::string              message; ///< human-friendly vibe check for what failed
   51 |     std::vector<std::string> context; ///< structured breadcrumbs (e.g., "Elements[12]")
   52 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:8: note: use "__attribute__((aligned(64)))" to align struct 'MeshError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: error: accessing fields in struct 'PhysicalGroup' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   66 | struct PhysicalGroup
      |        ^
   67 | {
   68 |     std::uint32_t dimension; ///< topological dimension (2 surface, 3 volume)
   69 |     std::uint32_t id;        ///< numeric identifier from Gmsh $PhysicalNames
   70 |     std::string   name;      ///< optional user name ("SOLID", "FIXED_BASE", ...)
   71 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: note: use "__attribute__((aligned(64)))" to align struct 'PhysicalGroup' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:8: error: accessing fields in struct 'Node' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
   76 | struct Node
      |        ^
   77 | {
   78 |     std::uint32_t original_id; ///< id from Gmsh file (1-indexed)
   79 |     common::Vec3  position;    ///< xyz coordinates in meters
   80 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:8: note: use "__attribute__((aligned(32)))" to align struct 'Node' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: accessing fields in struct 'Element' is inefficient due to padding; only needs 41 bytes but is using 44 bytes [altera-struct-pack-align,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
   91 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'Element'
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: accessing fields in struct 'Element' is inefficient due to poor alignment; currently aligned to 4 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
   91 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: note: use "__attribute__((aligned(64)))" to align struct 'Element' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: constructor does not initialize these fields: original_id, geometry, physical_group [cppcoreguidelines-pro-type-member-init,hicpp-member-init,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
      |                                             
      |                                             {}
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
      |                                                
      |                                                {}
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:89:31: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
      |                               ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:96:8: error: accessing fields in struct 'Mesh' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   96 | struct Mesh
      |        ^
   97 | {
   98 |     std::vector<Node>                              nodes;           ///< contiguous node buffer (id-sorted)
   99 |     std::vector<Element>                           elements;        ///< supported volume elements (tet/hexa)
  100 |     std::vector<PhysicalGroup>                     physical_groups; ///< physical metadata
  101 |     std::unordered_map<std::uint32_t, std::size_t> group_lookup;    ///< id  index map for fast lookup
  102 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:96:8: note: use "__attribute__((aligned(128)))" to align struct 'Mesh' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:121:20: error: invalid case style for function 'load_gmsh_file' [readability-identifier-naming,-warnings-as-errors]
  121 | [[nodiscard]] auto load_gmsh_file(const std::filesystem::path &path) -> MeshResult;
      |                    ^~~~~~~~~~~~~~
      |                    loadGmshFile
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:131:20: error: invalid case style for function 'load_gmsh_from_string' [readability-identifier-naming,-warnings-as-errors]
  131 | [[nodiscard]] auto load_gmsh_from_string(std::string_view ascii_contents) -> MeshResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadGmshFromString
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:16:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   16 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:25:22: error: invalid case style for namespace 'pre' [readability-identifier-naming,-warnings-as-errors]
   25 | namespace cwf::mesh::pre
      |                      ^~~
      |                      Pre
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:8: error: accessing fields in struct 'PreprocessError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   31 | struct PreprocessError
      |        ^
   32 | {
   33 |     std::string              message;
   34 |     std::vector<std::string> context;
   35 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:8: note: use "__attribute__((aligned(64)))" to align struct 'PreprocessError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:40:8: error: accessing fields in struct 'NodeAdjacency' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   40 | struct NodeAdjacency
      |        ^
   41 | {
   42 |     std::vector<std::uint32_t> offsets;         ///< size = nodes + 1
   43 |     std::vector<std::uint32_t> element_indices; ///< flattened element indices per node
   44 |     std::vector<std::uint8_t>  local_indices;   ///< corresponding local node slot (0-7)
   45 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:40:8: note: use "__attribute__((aligned(128)))" to align struct 'NodeAdjacency' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:50:8: error: accessing fields in struct 'Outputs' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   50 | struct Outputs
      |        ^
   51 | {
   52 |     NodeAdjacency                            adjacency;       ///< node-element incidence
   53 |     std::vector<double>                      element_volumes; ///< volume per element [m^3]
   54 |     std::vector<std::array<common::Vec3, 8>> shape_gradients; ///< grad Ni per element (tet uses first 4)
   55 |     std::vector<double>                      lumped_mass;     ///< mass per node [kg]
   56 |     std::vector<std::size_t> element_material_index;          ///< index into config.materials per element
   57 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:50:8: note: use "__attribute__((aligned(128)))" to align struct 'Outputs' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:54:42: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   54 |     std::vector<std::array<common::Vec3, 8>> shape_gradients; ///< grad Ni per element (tet uses first 4)
      |                                          ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:18:15: error: no header providing "cwf::common::Vec3" is directly included [misc-include-cleaner,-warnings-as-errors]
   12 | 
   13 | namespace cwf::mesh::pre
   14 | {
   15 | namespace
   16 | {
   17 | 
   18 | using common::Vec3;
      |               ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:20:20: error: function 'make_error' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   20 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx)
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:20:20: error: invalid case style for function 'make_error' [readability-identifier-naming,-warnings-as-errors]
   20 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx)
      |                    ^~~~~~~~~~
      |                    makeError
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:20:36: error: no header providing "std::string" is directly included [misc-include-cleaner,-warnings-as-errors]
   11 | #include <unordered_map>
   12 | 
   13 | namespace cwf::mesh::pre
   14 | {
   15 | namespace
   16 | {
   17 | 
   18 | using common::Vec3;
   19 | 
   20 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx)
      |                                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:20:57: error: no header providing "std::vector" is directly included [misc-include-cleaner,-warnings-as-errors]
   12 | 
   13 | namespace cwf::mesh::pre
   14 | {
   15 | namespace
   16 | {
   17 | 
   18 | using common::Vec3;
   19 | 
   20 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx)
      |                                                         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:21:13: error: no header providing "std::expected" is directly included [misc-include-cleaner,-warnings-as-errors]
    9 | #include <format>
   10 | #include <limits>
   11 | #include <unordered_map>
   12 | 
   13 | namespace cwf::mesh::pre
   14 | {
   15 | namespace
   16 | {
   17 | 
   18 | using common::Vec3;
   19 | 
   20 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx)
   21 |     -> std::expected<Outputs, PreprocessError>
      |             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:23:17: error: no header providing "std::unexpected" is directly included [misc-include-cleaner,-warnings-as-errors]
   23 |     return std::unexpected(PreprocessError{std::move(message), std::move(ctx)});
      |                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:23:43: error: use designated initializer list to initialize 'PreprocessError' [modernize-use-designated-initializers,-warnings-as-errors]
   23 |     return std::unexpected(PreprocessError{std::move(message), std::move(ctx)});
      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                            .message=           .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:1: note: aggregate type is defined here
   31 | struct PreprocessError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:23:49: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
   12 | 
   13 | namespace cwf::mesh::pre
   14 | {
   15 | namespace
   16 | {
   17 | 
   18 | using common::Vec3;
   19 | 
   20 | [[nodiscard]] auto make_error(std::string message, std::vector<std::string> ctx)
   21 |     -> std::expected<Outputs, PreprocessError>
   22 | {
   23 |     return std::unexpected(PreprocessError{std::move(message), std::move(ctx)});
      |                                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:23:69: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
   23 |     return std::unexpected(PreprocessError{std::move(message), std::move(ctx)});
      |                                                                     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:26:20: error: function 'subtract' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   26 | [[nodiscard]] auto subtract(const Vec3 &a, const Vec3 &b) noexcept -> Vec3
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:26:41: error: parameter name 'a' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   26 | [[nodiscard]] auto subtract(const Vec3 &a, const Vec3 &b) noexcept -> Vec3
      |                                         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:26:56: error: parameter name 'b' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   26 | [[nodiscard]] auto subtract(const Vec3 &a, const Vec3 &b) noexcept -> Vec3
      |                                                        ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:31:8: error: accessing fields in struct 'MaterialBinding' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   31 | struct MaterialBinding
      |        ^
   32 | {
   33 |     std::unordered_map<std::uint32_t, std::size_t> group_to_material;
   34 | };
      |  
      |   __attribute__((aligned(64)))
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:31:8: note: use "__attribute__((aligned(64)))" to align struct 'MaterialBinding' to 64 bytes
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:33:29: error: no header providing "std::uint32_t" is directly included [misc-include-cleaner,-warnings-as-errors]
    9 |     std::unordered_map<std::uint32_t, std::size_t> group_to_material;
      |                             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:33:44: error: no header providing "std::size_t" is directly included [misc-include-cleaner,-warnings-as-errors]
    9 |     std::unordered_map<std::uint32_t, std::size_t> group_to_material;
      |                                            ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:36:20: error: function 'bind_materials' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   36 | [[nodiscard]] auto bind_materials(const mesh::Mesh &mesh, const config::Config &cfg)
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:36:20: error: invalid case style for function 'bind_materials' [readability-identifier-naming,-warnings-as-errors]
   36 | [[nodiscard]] auto bind_materials(const mesh::Mesh &mesh, const config::Config &cfg)
      |                    ^~~~~~~~~~~~~~
      |                    bindMaterials
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:36:47: error: no header providing "cwf::mesh::Mesh" is directly included [misc-include-cleaner,-warnings-as-errors]
   12 | [[nodiscard]] auto bind_materials(const mesh::Mesh &mesh, const config::Config &cfg)
      |                                               ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:36:73: error: no header providing "cwf::config::Config" is directly included [misc-include-cleaner,-warnings-as-errors]
   12 | [[nodiscard]] auto bind_materials(const mesh::Mesh &mesh, const config::Config &cfg)
      |                                                                         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:41:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   41 |     for (const auto &group : mesh.physical_groups)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:51:51: error: use designated initializer list to initialize 'PreprocessError' [modernize-use-designated-initializers,-warnings-as-errors]
   51 |             return std::unexpected(PreprocessError{
      |                                                   ^
   52 |                 std::format("assignment references missing physical group '{}'", assignment.group),
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                 .message=
   53 |                 {"assignments", std::format("[{}]", i)}});
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                 .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:1: note: aggregate type is defined here
   31 | struct PreprocessError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:57:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   57 |         for (std::size_t m = 0; m < cfg.materials.size(); ++m)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:57:26: error: loop variable name 'm' is too short, expected at least 2 characters [readability-identifier-length,-warnings-as-errors]
   57 |         for (std::size_t m = 0; m < cfg.materials.size(); ++m)
      |                          ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:68:51: error: use designated initializer list to initialize 'PreprocessError' [modernize-use-designated-initializers,-warnings-as-errors]
   68 |             return std::unexpected(PreprocessError{
      |                                                   ^
   69 |                 std::format("assignment references missing material '{}'", assignment.material),
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                 .message=
   70 |                 {"assignments", std::format("[{}]", i)}});
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                 .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:1: note: aggregate type is defined here
   31 | struct PreprocessError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:77:20: error: function 'scale_vec' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   77 | [[nodiscard]] auto scale_vec(const Vec3 &value, double scalar) noexcept -> Vec3
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:77:20: error: invalid case style for function 'scale_vec' [readability-identifier-naming,-warnings-as-errors]
   77 | [[nodiscard]] auto scale_vec(const Vec3 &value, double scalar) noexcept -> Vec3
      |                    ^~~~~~~~~
      |                    scaleVec
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:82:20: error: function 'check_duplicate_nodes' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   82 | [[nodiscard]] auto check_duplicate_nodes(const mesh::Mesh &mesh) -> std::expected<void, PreprocessError>
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:82:20: error: invalid case style for function 'check_duplicate_nodes' [readability-identifier-naming,-warnings-as-errors]
   82 | [[nodiscard]] auto check_duplicate_nodes(const mesh::Mesh &mesh) -> std::expected<void, PreprocessError>
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    checkDuplicateNodes
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:82:74: error: no header providing "std::expected" is directly included [misc-include-cleaner,-warnings-as-errors]
   82 | [[nodiscard]] auto check_duplicate_nodes(const mesh::Mesh &mesh) -> std::expected<void, PreprocessError>
      |                                                                          ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:84:65: error: invalid case style for variable 'kEpsilon' [readability-identifier-naming,-warnings-as-errors]
   84 |     constexpr double                                            kEpsilon = 1.0e-12;
      |                                                                 ^~~~~~~~
      |                                                                 k_epsilon
   85 |     std::unordered_map<std::uint64_t, std::vector<std::size_t>> coord_hash_to_indices;
   86 | 
   87 |     auto hash_coord = [](double x) -> std::uint64_t {
   88 |         const auto scaled = static_cast<std::int64_t>(x / kEpsilon);
      |                                                           ~~~~~~~~
      |                                                           k_epsilon
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:85:29: error: no header providing "std::uint64_t" is directly included [misc-include-cleaner,-warnings-as-errors]
   85 |     std::unordered_map<std::uint64_t, std::vector<std::size_t>> coord_hash_to_indices;
      |                             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:87:33: error: parameter name 'x' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   87 |     auto hash_coord = [](double x) -> std::uint64_t {
      |                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:88:46: error: no header providing "std::int64_t" is directly included [misc-include-cleaner,-warnings-as-errors]
   88 |         const auto scaled = static_cast<std::int64_t>(x / kEpsilon);
      |                                              ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:92:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   92 |     for (std::size_t i = 0; i < mesh.nodes.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:95:21: error: variable name 'hx' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   95 |         const auto  hx  = hash_coord(pos[0]);
      |                     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:96:21: error: variable name 'hy' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   96 |         const auto  hy  = hash_coord(pos[1]);
      |                     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:97:21: error: variable name 'hz' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   97 |         const auto  hz  = hash_coord(pos[2]);
      |                     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:108:17: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  108 |                 for (std::size_t j = i + 1; j < indices.size(); ++j)
      |                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:108:45: error: backward branch (for loop) is ID-dependent due to variable reference to 'j' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
  108 |                 for (std::size_t j = i + 1; j < indices.size(); ++j)
      |                                             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:108:22: note: inferred assignment of ID-dependent value from ID-dependent 
  108 |                 for (std::size_t j = i + 1; j < indices.size(); ++j)
      |                      ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:112:33: error: variable name 'dx' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  112 |                     const auto  dx      = pos_i[0] - pos_j[0];
      |                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:113:33: error: variable name 'dy' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  113 |                     const auto  dy      = pos_i[1] - pos_j[1];
      |                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:114:33: error: variable name 'dz' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  114 |                     const auto  dz      = pos_i[2] - pos_j[2];
      |                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:115:43: error: '*' has higher precedence than '+'; add parentheses to explicitly specify the order of operations [readability-math-missing-parentheses,-warnings-as-errors]
  115 |                     const auto  dist_sq = dx * dx + dy * dy + dz * dz;
      |                                           ^~~~~~~
      |                                           (      )
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:115:53: error: '*' has higher precedence than '+'; add parentheses to explicitly specify the order of operations [readability-math-missing-parentheses,-warnings-as-errors]
  115 |                     const auto  dist_sq = dx * dx + dy * dy + dz * dz;
      |                                                     ^~~~~~~
      |                                                     (      )
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:115:63: error: '*' has higher precedence than '+'; add parentheses to explicitly specify the order of operations [readability-math-missing-parentheses,-warnings-as-errors]
  115 |                     const auto  dist_sq = dx * dx + dy * dy + dz * dz;
      |                                                               ^~~~~~~~
      |                                                               (      )
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:118:63: error: use designated initializer list to initialize 'PreprocessError' [modernize-use-designated-initializers,-warnings-as-errors]
  118 |                         return std::unexpected(PreprocessError{
      |                                                               ^
  119 |                             std::format("duplicate nodes detected: node {} and node {} at same position",
      |                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                             .message=
  120 |                                         indices[i], indices[j]),
      |                                         ~~~~~~~~~~~~~~~~~~~~~~~~
  121 |                             {"mesh", "nodes"}});
      |                             ~~~~~~~~~~~~~~~~~~
      |                             .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:1: note: aggregate type is defined here
   31 | struct PreprocessError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:130:20: error: function 'check_duplicate_elements' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
  130 | [[nodiscard]] auto check_duplicate_elements(const mesh::Mesh &mesh) -> std::expected<void, PreprocessError>
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:130:20: error: function 'check_duplicate_elements' has cognitive complexity of 30 (threshold 25) [readability-function-cognitive-complexity,-warnings-as-errors]
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:138:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  138 |     for (std::size_t i = 0; i < mesh.elements.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:142:85: note: +2, including nesting penalty of 1, nesting level increased to 2
  142 |             static_cast<std::size_t>(elem.geometry == ElementGeometry::Tetrahedron4 ? 4U : 8U);
      |                                                                                     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:148:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  148 |         for (std::size_t n = 0; n < node_count; ++n)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:155:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  155 |     for (const auto &[hash, indices] : conn_hash_to_indices)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:157:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  157 |         if (indices.size() > 1)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:159:13: note: +3, including nesting penalty of 2, nesting level increased to 3
  159 |             for (std::size_t i = 0; i < indices.size(); ++i)
      |             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:161:17: note: +4, including nesting penalty of 3, nesting level increased to 4
  161 |                 for (std::size_t j = i + 1; j < indices.size(); ++j)
      |                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:165:21: note: +5, including nesting penalty of 4, nesting level increased to 5
  165 |                     if (elem_i.geometry != elem_j.geometry)
      |                     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:169:99: note: +5, including nesting penalty of 4, nesting level increased to 5
  169 |                         static_cast<std::size_t>(elem_i.geometry == ElementGeometry::Tetrahedron4 ? 4U : 8U);
      |                                                                                                   ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:175:21: note: +5, including nesting penalty of 4, nesting level increased to 5
  175 |                     if (std::equal(sorted_i.begin(), sorted_i.begin() + static_cast<std::ptrdiff_t>(count),
      |                     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:130:20: error: invalid case style for function 'check_duplicate_elements' [readability-identifier-naming,-warnings-as-errors]
  130 | [[nodiscard]] auto check_duplicate_elements(const mesh::Mesh &mesh) -> std::expected<void, PreprocessError>
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~
      |                    checkDuplicateElements
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:142:55: error: no header providing "cwf::mesh::ElementGeometry" is directly included [misc-include-cleaner,-warnings-as-errors]
  142 |             static_cast<std::size_t>(elem.geometry == ElementGeometry::Tetrahedron4 ? 4U : 8U);
      |                                                       ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:144:14: error: no header providing "std::array" is directly included [misc-include-cleaner,-warnings-as-errors]
    8 |         std::array<std::uint32_t, 8> sorted_nodes = elem.nodes;
      |              ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:144:35: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  144 |         std::array<std::uint32_t, 8> sorted_nodes = elem.nodes;
      |                                   ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:145:81: error: no header providing "std::ptrdiff_t" is directly included [misc-include-cleaner,-warnings-as-errors]
  145 |         std::sort(sorted_nodes.begin(), sorted_nodes.begin() + static_cast<std::ptrdiff_t>(node_count));
      |                                                                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:148:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  148 |         for (std::size_t n = 0; n < node_count; ++n)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:148:26: error: loop variable name 'n' is too short, expected at least 2 characters [readability-identifier-length,-warnings-as-errors]
  148 |         for (std::size_t n = 0; n < node_count; ++n)
      |                          ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:148:33: error: backward branch (for loop) is ID-dependent due to variable reference to 'node_count' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
  148 |         for (std::size_t n = 0; n < node_count; ++n)
      |                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:141:9: note: inferred assignment of ID-dependent value from ID-dependent 
  141 |         const auto  node_count =
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:150:49: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
  150 |             hash ^= (static_cast<std::uint64_t>(sorted_nodes[n]) * 2654435761ULL);
      |                                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:150:68: error: 2654435761ULL is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  150 |             hash ^= (static_cast<std::uint64_t>(sorted_nodes[n]) * 2654435761ULL);
      |                                                                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:161:17: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  161 |                 for (std::size_t j = i + 1; j < indices.size(); ++j)
      |                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:161:45: error: backward branch (for loop) is ID-dependent due to variable reference to 'j' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
  161 |                 for (std::size_t j = i + 1; j < indices.size(); ++j)
      |                                             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:161:22: note: inferred assignment of ID-dependent value from ID-dependent 
  161 |                 for (std::size_t j = i + 1; j < indices.size(); ++j)
      |                      ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:165:60: error: statement should be inside braces [hicpp-braces-around-statements,readability-braces-around-statements,-warnings-as-errors]
  165 |                     if (elem_i.geometry != elem_j.geometry)
      |                                                            ^
      |                                                             {
  166 |                         continue;
      |                                  
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:170:47: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  170 |                     std::array<std::uint32_t, 8> sorted_i = elem_i.nodes;
      |                                               ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:171:47: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  171 |                     std::array<std::uint32_t, 8> sorted_j = elem_j.nodes;
      |                                               ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:179:44: error: use designated initializer list to initialize 'PreprocessError' [modernize-use-designated-initializers,-warnings-as-errors]
  179 |                             PreprocessError{std::format("duplicate elements detected: element {} and element "
      |                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                             .message=
  180 |                                                         "{} have same connectivity",
      |                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  181 |                                                         indices[i], indices[j]),
      |                                                         ~~~~~~~~~~~~~~~~~~~~~~~~
  182 |                                             {"mesh", "elements"}});
      |                                             ~~~~~~~~~~~~~~~~~~~~~
      |                                             .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:1: note: aggregate type is defined here
   31 | struct PreprocessError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:194:20: error: function 'validate_config_groups' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
  194 | [[nodiscard]] auto validate_config_groups(const mesh::Mesh &mesh, const config::Config &cfg)
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:194:20: error: invalid case style for function 'validate_config_groups' [readability-identifier-naming,-warnings-as-errors]
  194 | [[nodiscard]] auto validate_config_groups(const mesh::Mesh &mesh, const config::Config &cfg)
      |                    ^~~~~~~~~~~~~~~~~~~~~~
      |                    validateConfigGroups
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:198:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  198 |     for (const auto &group : mesh.physical_groups)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:203:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  203 |     for (std::size_t i = 0; i < cfg.dirichlet.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:206:27: error: use 'contains' to check for membership [readability-container-contains,-warnings-as-errors]
  206 |         if (name_to_group.find(fix.group) == name_to_group.end())
      |                           ^~~~            ~~~~~~~~~~~~~~~~~~~~~~
      |             !             contains
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:208:51: error: use designated initializer list to initialize 'PreprocessError' [modernize-use-designated-initializers,-warnings-as-errors]
  208 |             return std::unexpected(PreprocessError{
      |                                                   ^
  209 |                 std::format("dirichlet fix references missing physical group '{}'", fix.group),
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                 .message=
  210 |                 {"dirichlet", "fixes", std::format("[{}]", i)}});
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                 .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:1: note: aggregate type is defined here
   31 | struct PreprocessError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:214:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  214 |     for (std::size_t i = 0; i < cfg.loads.tractions.size(); ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:217:27: error: use 'contains' to check for membership [readability-container-contains,-warnings-as-errors]
  217 |         if (name_to_group.find(traction.group) == name_to_group.end())
      |                           ^~~~                 ~~~~~~~~~~~~~~~~~~~~~~
      |             !             contains
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:219:51: error: use designated initializer list to initialize 'PreprocessError' [modernize-use-designated-initializers,-warnings-as-errors]
  219 |             return std::unexpected(PreprocessError{
      |                                                   ^
  220 |                 std::format("traction load references missing physical group '{}'", traction.group),
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                 .message=
  221 |                 {"loads", "tractions", std::format("[{}]", i)}});
      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                 .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:1: note: aggregate type is defined here
   31 | struct PreprocessError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:228:20: error: function 'compute_tet_gradients' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
  228 | [[nodiscard]] auto compute_tet_gradients(const std::array<Vec3, 4> &positions, double volume6)
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:228:20: error: invalid case style for function 'compute_tet_gradients' [readability-identifier-naming,-warnings-as-errors]
  228 | [[nodiscard]] auto compute_tet_gradients(const std::array<Vec3, 4> &positions, double volume6)
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    computeTetGradients
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:231:18: error: variable name 'p0' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  231 |     const Vec3  &p0   = positions[0];
      |                  ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:232:18: error: variable name 'p1' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  232 |     const Vec3  &p1   = positions[1];
      |                  ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:233:18: error: variable name 'p2' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  233 |     const Vec3  &p2   = positions[2];
      |                  ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:234:18: error: variable name 'p3' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  234 |     const Vec3  &p3   = positions[3];
      |                  ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:236:31: error: no header providing "cwf::common::cross" is directly included [misc-include-cleaner,-warnings-as-errors]
  236 |     return {scale_vec(common::cross(subtract(p2, p1), subtract(p3, p1)), inv6),
      |                               ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:244:6: error: function 'run' has cognitive complexity of 26 (threshold 25) [readability-function-cognitive-complexity,-warnings-as-errors]
  244 | auto run(const mesh::Mesh &mesh, const config::Config &cfg) -> std::expected<Outputs, PreprocessError>
      |      ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:246:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  246 |     if (mesh.nodes.empty())
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:250:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  250 |     if (mesh.elements.empty())
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:255:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  255 |     if (auto dup_nodes = check_duplicate_nodes(mesh); !dup_nodes)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:259:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  259 |     if (auto dup_elems = check_duplicate_elements(mesh); !dup_elems)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:263:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  263 |     if (auto group_check = validate_config_groups(mesh, cfg); !group_check)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:269:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  269 |     if (!binding_result)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:283:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  283 |     for (std::size_t elem_index = 0; elem_index < mesh.elements.size(); ++elem_index)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:286:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  286 |         if (element.geometry != ElementGeometry::Tetrahedron4)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:292:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  292 |         for (std::size_t local = 0; local < 4; ++local)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:295:13: note: +3, including nesting penalty of 2, nesting level increased to 3
  295 |             if (node_idx >= mesh.nodes.size())
      |             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:308:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  308 |         if (volume <= std::numeric_limits<double>::epsilon())
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:317:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  317 |         for (std::size_t i = 0; i < 4; ++i)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:323:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  323 |         if (material_iter == binding.group_to_material.end())
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:332:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  332 |         for (std::size_t local = 0; local < 4; ++local)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:340:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  340 |     for (std::size_t node = 0; node < mesh.nodes.size(); ++node)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:350:5: note: +1, including nesting penalty of 0, nesting level increased to 1
  350 |     for (std::size_t elem_index = 0; elem_index < mesh.elements.size(); ++elem_index)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:353:9: note: +2, including nesting penalty of 1, nesting level increased to 2
  353 |         for (std::size_t local = 0; local < 4; ++local)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:292:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  292 |         for (std::size_t local = 0; local < 4; ++local)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:294:35: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
  294 |             const auto node_idx = element.nodes[local];
      |                                   ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:300:13: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
  300 |             positions[local] = mesh.nodes[node_idx].position;
      |             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:303:22: error: variable name 'e0' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  303 |         const Vec3   e0      = subtract(positions[1], positions[0]);
      |                      ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:304:22: error: variable name 'e1' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  304 |         const Vec3   e1      = subtract(positions[2], positions[0]);
      |                      ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:305:22: error: variable name 'e2' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  305 |         const Vec3   e2      = subtract(positions[3], positions[0]);
      |                      ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:306:40: error: no header providing "cwf::common::dot" is directly included [misc-include-cleaner,-warnings-as-errors]
  306 |         const double volume6 = common::dot(e0, common::cross(e1, e2));
      |                                        ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:317:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  317 |         for (std::size_t i = 0; i < 4; ++i)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:319:13: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
  319 |             outputs.shape_gradients[elem_index][i] = gradients[i];
      |             ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:319:54: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
  319 |             outputs.shape_gradients[elem_index][i] = gradients[i];
      |                                                      ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:332:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  332 |         for (std::size_t local = 0; local < 4; ++local)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:334:33: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
  334 |             outputs.lumped_mass[element.nodes[local]] += lump;
      |                                 ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:340:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  340 |     for (std::size_t node = 0; node < mesh.nodes.size(); ++node)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:353:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  353 |         for (std::size_t local = 0; local < 4; ++local)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:355:37: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
  355 |             const auto node_index = element.nodes[local];
      |                                     ^
C:\Dev\CiviWave-FEM\src\mesh\preprocess.cpp:358:78: error: no header providing "std::uint8_t" is directly included [misc-include-cleaner,-warnings-as-errors]
  358 |             outputs.adjacency.local_indices[write_base]   = static_cast<std::uint8_t>(local);
      |                                                                              ^
Suppressed 108951 warnings (108951 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
141 warnings treated as errors

File: .\src\mesh\mesh.cpp
110335 warnings and 3 errors generated.
Error while processing C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp.
error: unknown argument: '-fdeps-format=p1689r5' [clang-diagnostic-error]
error: unknown argument: '-fmodule-mapper=src\CMakeFiles\cwf_core.dir\mesh\mesh.cpp.obj.modmap' [clang-diagnostic-error]
error: unknown argument: '-fmodules-ts' [clang-diagnostic-error]
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:36:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   36 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:11: error: invalid case style for namespace 'cwf' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |           ^~~
      |           Cwf
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:16: error: invalid case style for namespace 'common' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |                ^~~~~~
      |                Common
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:181:27: error: invalid case style for function 'safe_normalize' [readability-identifier-naming,-warnings-as-errors]
  181 | [[nodiscard]] inline auto safe_normalize(const Vec3 &value) noexcept -> Vec3
      |                           ^~~~~~~~~~~~~~
      |                           safeNormalize
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:183:22: error: invalid case style for variable 'kThreshold' [readability-identifier-naming,-warnings-as-errors]
  183 |     constexpr double kThreshold = 1.0e-12;
      |                      ^~~~~~~~~~
      |                      k_threshold
  184 |     const auto       mag        = magnitude(value);
  185 |     if (mag < kThreshold || !std::isfinite(mag))
      |               ~~~~~~~~~~
      |               k_threshold
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:30:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   30 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:42:16: error: invalid case style for namespace 'mesh' [readability-identifier-naming,-warnings-as-errors]
   42 | namespace cwf::mesh
      |                ^~~~
      |                Mesh
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:8: error: accessing fields in struct 'MeshError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   48 | struct MeshError
      |        ^
   49 | {
   50 |     std::string              message; ///< human-friendly vibe check for what failed
   51 |     std::vector<std::string> context; ///< structured breadcrumbs (e.g., "Elements[12]")
   52 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:8: note: use "__attribute__((aligned(64)))" to align struct 'MeshError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: error: accessing fields in struct 'PhysicalGroup' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   66 | struct PhysicalGroup
      |        ^
   67 | {
   68 |     std::uint32_t dimension; ///< topological dimension (2 surface, 3 volume)
   69 |     std::uint32_t id;        ///< numeric identifier from Gmsh $PhysicalNames
   70 |     std::string   name;      ///< optional user name ("SOLID", "FIXED_BASE", ...)
   71 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: note: use "__attribute__((aligned(64)))" to align struct 'PhysicalGroup' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: error: constructor does not initialize these fields: dimension, id [cppcoreguidelines-pro-type-member-init,hicpp-member-init,-warnings-as-errors]
   66 | struct PhysicalGroup
      |        ^
   67 | {
   68 |     std::uint32_t dimension; ///< topological dimension (2 surface, 3 volume)
      |                            
      |                            {}
   69 |     std::uint32_t id;        ///< numeric identifier from Gmsh $PhysicalNames
      |                     
      |                     {}
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:8: error: accessing fields in struct 'Node' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
   76 | struct Node
      |        ^
   77 | {
   78 |     std::uint32_t original_id; ///< id from Gmsh file (1-indexed)
   79 |     common::Vec3  position;    ///< xyz coordinates in meters
   80 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:8: note: use "__attribute__((aligned(32)))" to align struct 'Node' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: accessing fields in struct 'Element' is inefficient due to padding; only needs 41 bytes but is using 44 bytes [altera-struct-pack-align,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
   91 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'Element'
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: accessing fields in struct 'Element' is inefficient due to poor alignment; currently aligned to 4 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
   91 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: note: use "__attribute__((aligned(64)))" to align struct 'Element' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:89:31: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
      |                               ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:96:8: error: accessing fields in struct 'Mesh' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   96 | struct Mesh
      |        ^
   97 | {
   98 |     std::vector<Node>                              nodes;           ///< contiguous node buffer (id-sorted)
   99 |     std::vector<Element>                           elements;        ///< supported volume elements (tet/hexa)
  100 |     std::vector<PhysicalGroup>                     physical_groups; ///< physical metadata
  101 |     std::unordered_map<std::uint32_t, std::size_t> group_lookup;    ///< id  index map for fast lookup
  102 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:96:8: note: use "__attribute__((aligned(128)))" to align struct 'Mesh' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:121:20: error: invalid case style for function 'load_gmsh_file' [readability-identifier-naming,-warnings-as-errors]
  121 | [[nodiscard]] auto load_gmsh_file(const std::filesystem::path &path) -> MeshResult;
      |                    ^~~~~~~~~~~~~~
      |                    loadGmshFile
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:131:20: error: invalid case style for function 'load_gmsh_from_string' [readability-identifier-naming,-warnings-as-errors]
  131 | [[nodiscard]] auto load_gmsh_from_string(std::string_view ascii_contents) -> MeshResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadGmshFromString
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:11:1: error: included header cctype is not used directly [misc-include-cleaner,-warnings-as-errors]
   11 | #include <cctype>
      | ^~~~~~~~~~~~~~~~~
   12 | #include <charconv>
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:12:1: error: included header charconv is not used directly [misc-include-cleaner,-warnings-as-errors]
   12 | #include <charconv>
      | ^~~~~~~~~~~~~~~~~~~
   13 | #include <fstream>
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:24:24: error: no header providing "std::uint64_t" is directly included [misc-include-cleaner,-warnings-as-errors]
   13 | #include <fstream>
   14 | #include <limits>
   15 | #include <sstream>
   16 | #include <string_view>
   17 | #include <unordered_set>
   18 | 
   19 | namespace cwf::mesh
   20 | {
   21 | namespace
   22 | {
   23 | 
   24 | using EntityKey = std::uint64_t;
      |                        ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:26:16: error: function 'make_entity_key' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   26 | constexpr auto make_entity_key(std::uint32_t dimension, std::uint32_t tag) noexcept -> EntityKey
      |                ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:26:16: error: invalid case style for function 'make_entity_key' [readability-identifier-naming,-warnings-as-errors]
   26 | constexpr auto make_entity_key(std::uint32_t dimension, std::uint32_t tag) noexcept -> EntityKey
      |                ^~~~~~~~~~~~~~~
      |                makeEntityKey
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:26:37: error: no header providing "std::uint32_t" is directly included [misc-include-cleaner,-warnings-as-errors]
   26 | constexpr auto make_entity_key(std::uint32_t dimension, std::uint32_t tag) noexcept -> EntityKey
      |                                     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:28:50: error: 32U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   28 |     return (static_cast<EntityKey>(dimension) << 32U) | static_cast<EntityKey>(tag);
      |                                                  ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:31:8: error: accessing fields in struct 'EntitiesInfo' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   31 | struct EntitiesInfo
      |        ^
   32 | {
   33 |     std::unordered_map<EntityKey, std::vector<std::uint32_t>> physical_mapping;
   34 | };
      |  
      |   __attribute__((aligned(64)))
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:31:8: note: use "__attribute__((aligned(64)))" to align struct 'EntitiesInfo' to 64 bytes
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:33:10: error: no header providing "std::unordered_map" is directly included [misc-include-cleaner,-warnings-as-errors]
   17 |     std::unordered_map<EntityKey, std::vector<std::uint32_t>> physical_mapping;
      |          ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:33:40: error: no header providing "std::vector" is directly included [misc-include-cleaner,-warnings-as-errors]
   18 | 
   19 | namespace cwf::mesh
   20 | {
   21 | namespace
   22 | {
   23 | 
   24 | using EntityKey = std::uint64_t;
   25 | 
   26 | constexpr auto make_entity_key(std::uint32_t dimension, std::uint32_t tag) noexcept -> EntityKey
   27 | {
   28 |     return (static_cast<EntityKey>(dimension) << 32U) | static_cast<EntityKey>(tag);
   29 | }
   30 | 
   31 | struct EntitiesInfo
   32 | {
   33 |     std::unordered_map<EntityKey, std::vector<std::uint32_t>> physical_mapping;
      |                                        ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:36:8: error: accessing fields in struct 'PhysicalNamesInfo' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   36 | struct PhysicalNamesInfo
      |        ^
   37 | {
   38 |     std::unordered_map<EntityKey, std::string> names;
   39 | };
      |  
      |   __attribute__((aligned(64)))
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:36:8: note: use "__attribute__((aligned(64)))" to align struct 'PhysicalNamesInfo' to 64 bytes
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:38:40: error: no header providing "std::string" is directly included [misc-include-cleaner,-warnings-as-errors]
   16 |     std::unordered_map<EntityKey, std::string> names;
      |                                        ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:41:20: error: function 'trim' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   41 | [[nodiscard]] auto trim(std::string_view value) -> std::string_view
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:52:20: error: function 'parse_physical_names' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   52 | [[nodiscard]] auto parse_physical_names(std::istringstream &stream)
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:52:20: error: invalid case style for function 'parse_physical_names' [readability-identifier-naming,-warnings-as-errors]
   52 | [[nodiscard]] auto parse_physical_names(std::istringstream &stream)
      |                    ^~~~~~~~~~~~~~~~~~~~
      |                    parsePhysicalNames
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:53:13: error: no header providing "std::expected" is directly included [misc-include-cleaner,-warnings-as-errors]
   13 |     -> std::expected<PhysicalNamesInfo, MeshError>
      |             ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:57:10: error: no header providing "std::getline" is directly included [misc-include-cleaner,-warnings-as-errors]
   57 |     std::getline(stream, line);
      |          ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:58:56: error: no header providing "std::stoul" is directly included [misc-include-cleaner,-warnings-as-errors]
   58 |     const auto count = static_cast<std::uint32_t>(std::stoul(std::string(trim(line))));
      |                                                        ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:59:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   59 |     for (std::uint32_t i = 0; i < count; ++i)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:59:31: error: backward branch (for loop) is ID-dependent due to variable reference to 'count' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
   59 |     for (std::uint32_t i = 0; i < count; ++i)
      |                               ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:58:5: note: inferred assignment of ID-dependent value from ID-dependent 
   58 |     const auto count = static_cast<std::uint32_t>(std::stoul(std::string(trim(line))));
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:63:25: error: no header providing "std::unexpected" is directly included [misc-include-cleaner,-warnings-as-errors]
   63 |             return std::unexpected(MeshError{"unexpected EOF in $PhysicalNames", {"PhysicalNames"}});
      |                         ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:63:45: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
   63 |             return std::unexpected(MeshError{"unexpected EOF in $PhysicalNames", {"PhysicalNames"}});
      |                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                              .message=                           .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:70:42: error: no header providing "std::ws" is directly included [misc-include-cleaner,-warnings-as-errors]
   14 |         std::getline(line_stream >> std::ws, name);
      |                                          ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:75:60: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
   18 |         info.names.emplace(make_entity_key(dim, tag), std::move(name));
      |                                                            ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:80:20: error: function 'parse_entities' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   80 | [[nodiscard]] auto parse_entities(std::istringstream &stream) -> std::expected<EntitiesInfo, MeshError>
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:80:20: error: invalid case style for function 'parse_entities' [readability-identifier-naming,-warnings-as-errors]
   80 | [[nodiscard]] auto parse_entities(std::istringstream &stream) -> std::expected<EntitiesInfo, MeshError>
      |                    ^~~~~~~~~~~~~~
      |                    parseEntities
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:86:41: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
   86 |         return std::unexpected(MeshError{"unexpected EOF in $Entities header", {"Entities"}});
      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                          .message=                             .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:89:5: error: multiple declarations in a single statement reduces readability [readability-isolate-declaration,-warnings-as-errors]
   89 |     std::uint32_t      num_points{}, num_curves{}, num_surfaces{}, num_volumes{};
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:93:64: error: no header providing "std::expected" is directly included [misc-include-cleaner,-warnings-as-errors]
   93 |                                   std::uint32_t count) -> std::expected<void, MeshError> {
      |                                                                ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:98:49: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
   98 |                 return std::unexpected(MeshError{"unexpected EOF inside $Entities block",
      |                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                                  .message=
   99 |                                                  {"Entities", std::format("dim{}", dimension)}});
      |                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                                  .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:99:68: error: no header providing "std::format" is directly included [misc-include-cleaner,-warnings-as-errors]
   13 |                                                  {"Entities", std::format("dim{}", dimension)}});
      |                                                                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:104:13: error: multiple declarations in a single statement reduces readability [readability-isolate-declaration,-warnings-as-errors]
  104 |             double minx{}, miny{}, minz{}, maxx{}, maxy{}, maxz{};
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:110:13: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  110 |             for (std::uint32_t j = 0; j < num_phys; ++j)
      |             ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:118:85: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  118 |                 info.physical_mapping.emplace(make_entity_key(dimension, tag), std::move(phys_ids));
      |                                                                                     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:143:20: error: function 'parse_nodes' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
  143 | [[nodiscard]] auto parse_nodes(std::istringstream &stream)
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:143:20: error: invalid case style for function 'parse_nodes' [readability-identifier-naming,-warnings-as-errors]
  143 | [[nodiscard]] auto parse_nodes(std::istringstream &stream)
      |                    ^~~~~~~~~~~
      |                    parseNodes
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:144:27: error: no header providing "std::pair" is directly included [misc-include-cleaner,-warnings-as-errors]
  144 |     -> std::expected<std::pair<std::vector<Node>, std::unordered_map<std::uint32_t, std::size_t>>, MeshError>
      |                           ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:144:90: error: no header providing "std::size_t" is directly included [misc-include-cleaner,-warnings-as-errors]
   13 |     -> std::expected<std::pair<std::vector<Node>, std::unordered_map<std::uint32_t, std::size_t>>, MeshError>
      |                                                                                          ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:151:41: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  151 |         return std::unexpected(MeshError{"unexpected EOF in $Nodes header", {"Nodes"}});
      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                          .message=                          .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:154:5: error: multiple declarations in a single statement reduces readability [readability-isolate-declaration,-warnings-as-errors]
  154 |     std::uint64_t      num_entity_blocks{}, num_nodes{}, min_node{}, max_node{};
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:162:45: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  162 |             return std::unexpected(MeshError{"unexpected EOF in $Nodes block header", {"Nodes"}});
      |                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                              .message=                                .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:165:9: error: multiple declarations in a single statement reduces readability [readability-isolate-declaration,-warnings-as-errors]
  165 |         std::uint32_t      entity_dim{}, entity_tag{};
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:173:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  173 |         for (std::uint64_t i = 0; i < nodes_in_block; ++i)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:177:49: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  177 |                 return std::unexpected(MeshError{"unexpected EOF reading node ids", {"Nodes"}});
      |                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                                  .message=                          .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:182:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  182 |         for (std::uint64_t i = 0; i < nodes_in_block; ++i)
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:186:49: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  186 |                 return std::unexpected(MeshError{"unexpected EOF reading node coordinates", {"Nodes"}});
      |                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                                  .message=                                  .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:189:13: error: multiple declarations in a single statement reduces readability [readability-isolate-declaration,-warnings-as-errors]
  189 |             double             x{}, y{}, z{};
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:189:32: error: variable name 'x' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  189 |             double             x{}, y{}, z{};
      |                                ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:189:37: error: variable name 'y' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  189 |             double             x{}, y{}, z{};
      |                                     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:189:42: error: variable name 'z' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  189 |             double             x{}, y{}, z{};
      |                                          ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:191:22: error: use designated initializer list to initialize 'Node' [modernize-use-designated-initializers,-warnings-as-errors]
  191 |             Node node{node_ids[static_cast<std::size_t>(i)], common::Vec3{x, y, z}};
      |                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                       .original_id=                          .position=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:1: note: aggregate type is defined here
   76 | struct Node
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:191:70: error: no header providing "cwf::common::Vec3" is directly included [misc-include-cleaner,-warnings-as-errors]
   18 |             Node node{node_ids[static_cast<std::size_t>(i)], common::Vec3{x, y, z}};
      |                                                                      ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:193:29: error: std::move of the variable 'node' of the trivially-copyable type 'Node' has no effect [hicpp-move-const-arg,performance-move-const-arg,-warnings-as-errors]
  193 |             nodes.push_back(std::move(node));
      |                             ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:193:34: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  193 |             nodes.push_back(std::move(node));
      |                                  ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:199:41: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  199 |         return std::unexpected(MeshError{"node count mismatch", {"Nodes"}});
      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                          .message=              .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:201:17: error: no header providing "std::pair" is directly included [misc-include-cleaner,-warnings-as-errors]
  201 |     return std::pair{std::move(nodes), std::move(id_to_index)};
      |                 ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:201:27: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  201 |     return std::pair{std::move(nodes), std::move(id_to_index)};
      |                           ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:201:45: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  201 |     return std::pair{std::move(nodes), std::move(id_to_index)};
      |                                             ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:204:20: error: function 'element_node_count' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
  204 | [[nodiscard]] auto element_node_count(std::uint32_t gmsh_type) -> std::optional<std::size_t>
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:204:20: error: invalid case style for function 'element_node_count' [readability-identifier-naming,-warnings-as-errors]
  204 | [[nodiscard]] auto element_node_count(std::uint32_t gmsh_type) -> std::optional<std::size_t>
      |                    ^~~~~~~~~~~~~~~~~~
      |                    elementNodeCount
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:204:72: error: no header providing "std::optional" is directly included [misc-include-cleaner,-warnings-as-errors]
   15 | [[nodiscard]] auto element_node_count(std::uint32_t gmsh_type) -> std::optional<std::size_t>
      |                                                                        ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:210:10: error: 5U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  210 |     case 5U:
      |          ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:211:16: error: 8U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  211 |         return 8U; // Hexahedron
      |                ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:213:21: error: no header providing "std::nullopt" is directly included [misc-include-cleaner,-warnings-as-errors]
  213 |         return std::nullopt;
      |                     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:217:20: error: function 'to_geometry' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
  217 | [[nodiscard]] auto to_geometry(std::uint32_t gmsh_type) -> std::optional<ElementGeometry>
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:217:20: error: invalid case style for function 'to_geometry' [readability-identifier-naming,-warnings-as-errors]
  217 | [[nodiscard]] auto to_geometry(std::uint32_t gmsh_type) -> std::optional<ElementGeometry>
      |                    ^~~~~~~~~~~
      |                    toGeometry
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:223:10: error: 5U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  223 |     case 5U:
      |          ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:230:20: error: function 'parse_elements' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
  230 | [[nodiscard]] auto parse_elements(std::istringstream                                   &stream,
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:230:20: error: invalid case style for function 'parse_elements' [readability-identifier-naming,-warnings-as-errors]
  230 | [[nodiscard]] auto parse_elements(std::istringstream                                   &stream,
      |                    ^~~~~~~~~~~~~~
      |                    parseElements
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:239:41: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  239 |         return std::unexpected(MeshError{"unexpected EOF in $Elements header", {"Elements"}});
      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                          .message=                             .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:242:5: error: multiple declarations in a single statement reduces readability [readability-isolate-declaration,-warnings-as-errors]
  242 |     std::uint64_t      num_blocks{}, num_elements{}, min_tag{}, max_tag{};
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:250:45: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  250 |             return std::unexpected(MeshError{"unexpected EOF reading element block header", {"Elements"}});
      |                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                              .message=                                      .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:253:9: error: multiple declarations in a single statement reduces readability [readability-isolate-declaration,-warnings-as-errors]
  253 |         std::uint32_t      entity_dim{}, entity_tag{}, element_type{};
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:260:45: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  260 |             return std::unexpected(MeshError{std::format("unsupported Gmsh element type {}", element_type),
      |                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                              .message=
  261 |                                              {"Elements", std::format("entityTag={}", entity_tag)}});
      |                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                              .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:277:49: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  277 |                 return std::unexpected(MeshError{"unexpected EOF reading element data", {"Elements"}});
      |                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                                  .message=                              .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:287:13: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  287 |             for (std::size_t node_idx = 0; node_idx < node_count; ++node_idx)
      |             ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:287:44: error: backward branch (for loop) is ID-dependent due to variable reference to 'node_count' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
  287 |             for (std::size_t node_idx = 0; node_idx < node_count; ++node_idx)
      |                                            ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:263:9: note: inferred assignment of ID-dependent value from ID-dependent variable node_count_opt
  263 |         const auto    node_count        = node_count_opt.value();
      |         ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:295:34: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  295 |                         MeshError{std::format("element references unknown node {}", node_tag),
      |                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                   .message=
  296 |                                   {"Elements", std::format("elementTag={}", element_tag)}});
      |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                   .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:298:17: error: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index,-warnings-as-errors]
  298 |                 element.nodes[node_idx] = static_cast<std::uint32_t>(map_iter->second);
      |                 ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:300:32: error: std::move of the variable 'element' of the trivially-copyable type 'Element' has no effect [hicpp-move-const-arg,performance-move-const-arg,-warnings-as-errors]
  300 |             elements.push_back(std::move(element));
      |                                ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:300:37: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  300 |             elements.push_back(std::move(element));
      |                                     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:306:41: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  306 |         return std::unexpected(MeshError{"element count mismatch", {"Elements"}});
      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                          .message=                 .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:311:20: error: function 'read_section' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
  311 | [[nodiscard]] auto read_section(std::istringstream &stream, std::string_view expected_end)
      |                    ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:311:20: error: invalid case style for function 'read_section' [readability-identifier-naming,-warnings-as-errors]
  311 | [[nodiscard]] auto read_section(std::istringstream &stream, std::string_view expected_end)
      |                    ^~~~~~~~~~~~
      |                    readSection
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:316:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  316 |     while (std::getline(stream, line))
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:330:44: error: no header providing "std::filesystem::path" is directly included [misc-include-cleaner,-warnings-as-errors]
   13 | auto load_gmsh_file(const std::filesystem::path &path) -> MeshResult
      |                                            ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:332:5: error: variable 'file' of type 'std::ifstream' (aka 'basic_ifstream<char, char_traits<char>>') can be declared 'const' [misc-const-correctness,-warnings-as-errors]
  332 |     std::ifstream file(path);
      |     ^
      |                   const 
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:336:22: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  336 |             MeshError{std::format("failed to open mesh file: {}", path.string()), {path.string()}});
      |                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                       .message=                                                   .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:336:28: error: no header providing "std::format" is directly included [misc-include-cleaner,-warnings-as-errors]
  336 |             MeshError{std::format("failed to open mesh file: {}", path.string()), {path.string()}});
      |                            ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:353:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  353 |     while (std::getline(input, line))
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:353:12: error: backward branch (while loop) is ID-dependent due to variable reference to 'input' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
  353 |     while (std::getline(input, line))
      |            ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:351:5: note: inferred assignment of ID-dependent value from ID-dependent 
  351 |     std::istringstream input{std::string(ascii_contents)};
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:364:35: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  364 |             physical_names = std::move(result.value());
      |                                   ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:365:50: error: 9U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  365 |             seen_sections.insert(make_entity_key(9U, 9U));
      |                                                  ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:365:54: error: 9U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  365 |             seen_sections.insert(make_entity_key(9U, 9U));
      |                                                      ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:375:29: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  375 |             entities = std::move(result.value());
      |                             ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:376:50: error: 8U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  376 |             seen_sections.insert(make_entity_key(8U, 8U));
      |                                                  ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:376:54: error: 8U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  376 |             seen_sections.insert(make_entity_key(8U, 8U));
      |                                                      ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:388:50: error: 7U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  388 |             seen_sections.insert(make_entity_key(7U, 7U));
      |                                                  ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:388:54: error: 7U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  388 |             seen_sections.insert(make_entity_key(7U, 7U));
      |                                                      ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:398:34: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  398 |             mesh.elements = std::move(result.value());
      |                                  ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:399:50: error: 6U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  399 |             seen_sections.insert(make_entity_key(6U, 6U));
      |                                                  ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:399:54: error: 6U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  399 |             seen_sections.insert(make_entity_key(6U, 6U));
      |                                                      ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:403:49: error: 7U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  403 |     if (!seen_sections.contains(make_entity_key(7U, 7U)))
      |                                                 ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:403:53: error: 7U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  403 |     if (!seen_sections.contains(make_entity_key(7U, 7U)))
      |                                                     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:405:41: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  405 |         return std::unexpected(MeshError{"missing $Nodes section", {}});
      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                          .message=                 .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:407:49: error: 6U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  407 |     if (!seen_sections.contains(make_entity_key(6U, 6U)))
      |                                                 ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:407:53: error: 6U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  407 |     if (!seen_sections.contains(make_entity_key(6U, 6U)))
      |                                                     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:409:41: error: use designated initializer list to initialize 'MeshError' [modernize-use-designated-initializers,-warnings-as-errors]
  409 |         return std::unexpected(MeshError{"missing $Elements section", {}});
      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                          .message=                    .context=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:1: note: aggregate type is defined here
   48 | struct MeshError
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:413:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  413 |     for (const auto &[key, name] : physical_names.names)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:417:45: error: use designated initializer list to initialize 'PhysicalGroup' [modernize-use-designated-initializers,-warnings-as-errors]
  417 |         group_map.emplace(tag, PhysicalGroup{dimension, tag, name});
      |                                             ^~~~~~~~~~~~~~~~~~~~~~
      |                                              .dimension=.id= .name=
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:1: note: aggregate type is defined here
   66 | struct PhysicalGroup
      | ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:419:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  419 |     for (const auto &element : mesh.elements)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:430:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  430 |     for (auto &[id, group] : group_map)
      |     ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:430:17: error: variable name 'id' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
  430 |     for (auto &[id, group] : group_map)
      |                 ^
C:\Dev\CiviWave-FEM\src\mesh\mesh.cpp:433:45: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
  433 |         mesh.physical_groups.push_back(std::move(group));
      |                                             ^
Suppressed 110184 warnings (110184 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
131 warnings treated as errors

File: .\tests\config_validation_test.cpp
127260 warnings and 4 errors generated.
Error while processing C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp.
error: unknown argument: '-fdeps-format=p1689r5' [clang-diagnostic-error]
error: unknown argument: '-fmodule-mapper=tests\CMakeFiles\cwf_core_tests.dir\config_validation_test.cpp.obj.modmap' [clang-diagnostic-error]
error: unknown argument: '-fmodules-ts' [clang-diagnostic-error]
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:38:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   38 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:56:11: error: invalid case style for namespace 'cwf' [readability-identifier-naming,-warnings-as-errors]
   56 | namespace cwf::config
      |           ^~~
      |           Cwf
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:56:16: error: invalid case style for namespace 'config' [readability-identifier-naming,-warnings-as-errors]
   56 | namespace cwf::config
      |                ^~~~~~
      |                Config
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: error: accessing fields in struct 'ConfigError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   83 | struct ConfigError
      |        ^
   84 | {
   85 |     std::string              message; ///< spicy human-readable error message uwu
   86 |     std::vector<std::string> context; ///< breadcrumb trail showing where things derailed
   87 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: note: use "__attribute__((aligned(64)))" to align struct 'ConfigError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: error: accessing fields in struct 'Material' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   97 | struct Material
      |        ^
   98 | {
   99 |     std::string name;           ///< unique material nickname, referenced in assignments
  100 |     double      youngs_modulus; ///< E [Pa], must be > 0
  101 |     double      poisson_ratio;  ///< nu [-], typically 0 < nu < 0.5
  102 |     double      density;        ///< rho [kg/m^3], must be > 0
  103 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: note: use "__attribute__((aligned(64)))" to align struct 'Material' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: error: accessing fields in struct 'Assignment' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  108 | struct Assignment
      |        ^
  109 | {
  110 |     std::string group;    ///< physical group name from mesh (e.g., "SOLID")
  111 |     std::string material; ///< material name defined in materials list
  112 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: note: use "__attribute__((aligned(64)))" to align struct 'Assignment' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: error: accessing fields in struct 'Damping' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  119 | struct Damping
      |        ^
  120 | {
  121 |     double xi; ///< damping ratio target (0.0 - 1.0 typically)
  122 |     double w1; ///< lower angular frequency for Rayleigh fit [rad/s]
  123 |     double w2; ///< upper angular frequency [rad/s]
  124 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: note: use "__attribute__((aligned(32)))" to align struct 'Damping' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: error: accessing fields in struct 'TimeSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  129 | struct TimeSettings
      |        ^
  130 | {
  131 |     double initial_dt; ///< starting timestep [s]
  132 |     bool   adaptive;   ///< enable adaptive dt policies per spec
  133 |     double min_dt;     ///< optional safety clamp (0 if unspecified)
  134 |     double max_dt;     ///< optional safety clamp (> initial dt for safety)
  135 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: note: use "__attribute__((aligned(32)))" to align struct 'TimeSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to padding; only needs 84 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'SolverSettings'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((aligned(128)))" to align struct 'SolverSettings' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: error: accessing fields in struct 'PrecisionSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  152 | struct PrecisionSettings
      |        ^
  153 | {
  154 |     std::string vector_precision;    ///< e.g., "fp32"
  155 |     std::string reduction_precision; ///< e.g., "fp64"
  156 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: note: use "__attribute__((aligned(64)))" to align struct 'PrecisionSettings' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: error: accessing fields in struct 'Curve' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  161 | struct Curve
      |        ^
  162 | {
  163 |     std::vector<std::pair<double, double>> points; ///< (time, value) pairs sorted by time
  164 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: note: use "__attribute__((aligned(32)))" to align struct 'Curve' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: error: accessing fields in struct 'SurfaceTraction' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  169 | struct SurfaceTraction
      |        ^
  170 | {
  171 |     std::string           group;       ///< surface physical group name
  172 |     std::array<double, 3> value;       ///< traction direction + magnitude [Pa]
  173 |     std::string           scale_curve; ///< optional curve id ("" if constant)
  174 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: note: use "__attribute__((aligned(128)))" to align struct 'SurfaceTraction' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: error: accessing fields in struct 'Loads' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  179 | struct Loads
      |        ^
  180 | {
  181 |     std::array<double, 3>        gravity;   ///< global gravity vector [m/s^2]
  182 |     std::vector<SurfaceTraction> tractions; ///< list of surface loads
  183 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: note: use "__attribute__((aligned(64)))" to align struct 'Loads' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to padding; only needs 83 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'DirichletFix'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((aligned(128)))" to align struct 'DirichletFix' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: error: accessing fields in struct 'OutputSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  198 | struct OutputSettings
      |        ^
  199 | {
  200 |     std::uint32_t              vtu_stride; ///< write VTU every N frames (>= 1)
  201 |     std::vector<std::uint32_t> probes;     ///< node indices to track
  202 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: note: use "__attribute__((aligned(32)))" to align struct 'OutputSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: error: accessing fields in struct 'Config' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  207 | struct Config
      |        ^
  208 | {
  209 |     std::filesystem::path                  mesh_path;   ///< path to mesh (relative allowed)
  210 |     std::vector<Material>                  materials;   ///< materials registry
  211 |     std::vector<Assignment>                assignments; ///< physical group  material mapping
  212 |     Damping                                damping;     ///< Rayleigh damping spec
  213 |     TimeSettings                           time;        ///< time stepping configuration
  214 |     SolverSettings                         solver;      ///< solver knobs (PCG etc.)
  215 |     PrecisionSettings                      precision;   ///< precision toggles
  216 |     Loads                                  loads;       ///< body + surface loads
  217 |     std::unordered_map<std::string, Curve> curves;      ///< time history curves
  218 |     std::vector<DirichletFix>              dirichlet;   ///< locked DoFs definitions
  219 |     OutputSettings                         output;      ///< post-processing preferences
  220 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: note: use "__attribute__((aligned(128)))" to align struct 'Config' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:255:20: error: invalid case style for function 'load_config_from_file' [readability-identifier-naming,-warnings-as-errors]
  255 | [[nodiscard]] auto load_config_from_file(const std::filesystem::path &path) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromFile
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:268:20: error: invalid case style for function 'load_config_from_string' [readability-identifier-naming,-warnings-as-errors]
  268 | [[nodiscard]] auto load_config_from_string(std::string_view yaml_text) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromString
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:281:20: error: invalid case style for function 'parse_config_node' [readability-identifier-naming,-warnings-as-errors]
  281 | [[nodiscard]] auto parse_config_node(const YAML::Node &root) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~
      |                    parseConfigNode
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:5:1: error: #includes are not sorted properly [llvm-include-order,-warnings-as-errors]
    5 | #include <filesystem>
      | ^        ~~~~~~~~~~~~
    6 | #include <functional>
      |          ~~~~~~~~~~~~
    7 | #include <gmock/gmock.h>
      |          ~~~~~~~~~~~~~~~
    8 | #include <gtest/gtest.h>
      |          ~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:11:1: error: included header utility is not used directly [misc-include-cleaner,-warnings-as-errors]
   11 | #include <utility>
      | ^~~~~~~~~~~~~~~~~~
   12 | #include <vector>
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:25:20: error: function 'test_data_path' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   25 | [[nodiscard]] auto test_data_path(std::string_view file) -> std::filesystem::path
      |                    ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:25:20: error: invalid case style for function 'test_data_path' [readability-identifier-naming,-warnings-as-errors]
   25 | [[nodiscard]] auto test_data_path(std::string_view file) -> std::filesystem::path
      |                    ^~~~~~~~~~~~~~
      |                    testDataPath
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:25:40: error: no header providing "std::string_view" is directly included [misc-include-cleaner,-warnings-as-errors]
   11 | #include <utility>
   12 | #include <vector>
   13 | 
   14 | #include "cwf/config/config.hpp"
   15 | #include "support/config_builder.hpp"
   16 | #include "test_config.hpp"
   17 | 
   18 | using testing::ElementsAre;
   19 | using testing::ElementsAreArray;
   20 | using testing::HasSubstr;
   21 | 
   22 | namespace
   23 | {
   24 | 
   25 | [[nodiscard]] auto test_data_path(std::string_view file) -> std::filesystem::path
      |                                        ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:30:20: error: function 'make_good_config' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   30 | [[nodiscard]] auto make_good_config() -> cwf::config::Config
      |                    ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:30:20: error: invalid case style for function 'make_good_config' [readability-identifier-naming,-warnings-as-errors]
   30 | [[nodiscard]] auto make_good_config() -> cwf::config::Config
      |                    ^~~~~~~~~~~~~~~~
      |                    makeGoodConfig
   31 | {
   32 |     const auto result = cwf::test_support::load_config();
   33 |     if (!result)
   34 |     {
   35 |         throw std::runtime_error("expected default builder to succeed");
   36 |     }
   37 |     return result.value();
   38 | }
   39 | 
   40 | } // namespace
   41 | 
   42 | TEST(ConfigValidation, ParsesGoldenConfigFromBuilder)
   43 | {
   44 |     const auto config = make_good_config();
      |                         ~~~~~~~~~~~~~~~~
      |                         makeGoodConfig
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:35:9: error: cannot use 'throw' with exceptions disabled [clang-diagnostic-error]
   35 |         throw std::runtime_error("expected default builder to succeed");
      |         ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:8: error: accessing fields in struct 'InvalidConfigCase' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   71 | struct InvalidConfigCase
      |        ^
   72 | {
   73 |     std::string                             name;
   74 |     cwf::test_support::ConfigBuilderOptions options;
   75 |     std::string                             expected_message_substring;
   76 |     std::vector<std::string>                expected_context;
   77 |     std::function<void(std::string &)>      mutate_yaml; ///< optional for bespoke tweaks
   78 | };
      |  
      |   __attribute__((aligned(128)))
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:8: note: use "__attribute__((aligned(128)))" to align struct 'InvalidConfigCase' to 128 bytes
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:99:6: error: function 'make_invalid_cases' can be made static or moved into an anonymous namespace to enforce internal linkage [misc-use-internal-linkage,-warnings-as-errors]
   99 | auto make_invalid_cases() -> std::vector<InvalidConfigCase>
      |      ^
      | static 
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:99:6: error: invalid case style for function 'make_invalid_cases' [readability-identifier-naming,-warnings-as-errors]
   99 | auto make_invalid_cases() -> std::vector<InvalidConfigCase>
      |      ^~~~~~~~~~~~~~~~~~
      |      makeInvalidCases
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:113:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  113 |         cases.push_back({"MissingMeshSection", opts, "missing 'mesh' section", {"mesh"}, nullptr});
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=                .options= .expected_message_substring= .expected_context= .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:118:39: error: use designated initializer list to initialize 'MaterialSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  118 |         opts.materials = {MaterialSpec{"concrete", -1.0, 0.2, 2500.0}};
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                        .name=      .youngs_modulus= .poisson_ratio= .density=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:29:1: note: aggregate type is defined here
   29 | struct MaterialSpec
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:118:58: error: 0.2 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  118 |         opts.materials = {MaterialSpec{"concrete", -1.0, 0.2, 2500.0}};
      |                                                          ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:118:63: error: 2500.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  118 |         opts.materials = {MaterialSpec{"concrete", -1.0, 0.2, 2500.0}};
      |                                                               ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:120:13: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  120 |             {"NegativeYoungsModulus", opts, "material.E must be > 0", {"materials", "[0]", "E"}, nullptr});
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |              .name=                   .options= .expected_message_substring= .expected_context=  .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:125:39: error: use designated initializer list to initialize 'MaterialSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  125 |         opts.materials = {MaterialSpec{"concrete", 3.0e10, 0.75, 2500.0}};
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                        .name=      .youngs_modulus= .poisson_ratio= .density=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:29:1: note: aggregate type is defined here
   29 | struct MaterialSpec
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:125:52: error: 3.0e10 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  125 |         opts.materials = {MaterialSpec{"concrete", 3.0e10, 0.75, 2500.0}};
      |                                                    ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:125:60: error: 0.75 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  125 |         opts.materials = {MaterialSpec{"concrete", 3.0e10, 0.75, 2500.0}};
      |                                                            ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:125:66: error: 2500.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  125 |         opts.materials = {MaterialSpec{"concrete", 3.0e10, 0.75, 2500.0}};
      |                                                                  ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:126:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  126 |         cases.push_back({"PoissonRatioTooLarge",
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=
  127 |                          opts,
      |                          ~~~~~
      |                          .options=
  128 |                          "material.nu must be (-0.999, 0.5)",
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_message_substring=
  129 |                          {"materials", "[0]", "nu"},
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_context=
  130 |                          nullptr});
      |                          ~~~~~~~~
      |                          .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:135:39: error: use designated initializer list to initialize 'MaterialSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  135 |         opts.materials = {MaterialSpec{"duplicate", 3.0e10, 0.2, 2500.0},
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                        .name=       .youngs_modulus= .poisson_ratio= .density=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:29:1: note: aggregate type is defined here
   29 | struct MaterialSpec
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:135:53: error: 3.0e10 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  135 |         opts.materials = {MaterialSpec{"duplicate", 3.0e10, 0.2, 2500.0},
      |                                                     ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:135:61: error: 0.2 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  135 |         opts.materials = {MaterialSpec{"duplicate", 3.0e10, 0.2, 2500.0},
      |                                                             ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:135:66: error: 2500.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  135 |         opts.materials = {MaterialSpec{"duplicate", 3.0e10, 0.2, 2500.0},
      |                                                                  ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:136:39: error: use designated initializer list to initialize 'MaterialSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  136 |                           MaterialSpec{"duplicate", 1.0e11, 0.3, 7800.0}};
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                        .name=       .youngs_modulus= .poisson_ratio= .density=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:29:1: note: aggregate type is defined here
   29 | struct MaterialSpec
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:136:53: error: 1.0e11 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  136 |                           MaterialSpec{"duplicate", 1.0e11, 0.3, 7800.0}};
      |                                                     ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:136:61: error: 0.3 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  136 |                           MaterialSpec{"duplicate", 1.0e11, 0.3, 7800.0}};
      |                                                             ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:136:66: error: 7800.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  136 |                           MaterialSpec{"duplicate", 1.0e11, 0.3, 7800.0}};
      |                                                                  ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:137:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  137 |         cases.push_back({"DuplicateMaterialNames",
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=
  138 |                          opts,
      |                          ~~~~~
      |                          .options=
  139 |                          "material names must be unique",
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_message_substring=
  140 |                          {"materials", "[1]", "name"},
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_context=
  141 |                          nullptr});
      |                          ~~~~~~~~
      |                          .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:146:43: error: use designated initializer list to initialize 'AssignmentSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  146 |         opts.assignments = {AssignmentSpec{"SOLID", "missing"}};
      |                                           ^~~~~~~~~~~~~~~~~~~~
      |                                            .group=  .material=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:37:1: note: aggregate type is defined here
   37 | struct AssignmentSpec
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:147:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  147 |         cases.push_back({"AssignmentUnknownMaterial",
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=
  148 |                          opts,
      |                          ~~~~~
      |                          .options=
  149 |                          "assignment references unknown material",
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_message_substring=
  150 |                          {"assignments", "[0]", "material"},
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_context=
  151 |                          nullptr});
      |                          ~~~~~~~~
      |                          .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:156:27: error: 1.2 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  156 |         opts.damping_xi = 1.2;
      |                           ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:158:13: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  158 |             {"DampingXiOutOfRange", opts, "damping.xi must be (0,1)", {"damping", "xi"}, nullptr});
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |              .name=                 .options= .expected_message_substring= .expected_context= .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:163:27: error: 5.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  163 |         opts.damping_w2 = 5.0;
      |                           ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:164:27: error: 10.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  164 |         opts.damping_w1 = 10.0;
      |                           ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:166:13: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  166 |             {"DampingW2TooSmall", opts, "damping.w2 must be > damping.w1", {"damping", "w2"}, nullptr});
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |              .name=               .options= .expected_message_substring=   .expected_context= .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:171:25: error: 0.01 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  171 |         opts.time_dt = -0.01;
      |                         ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:172:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  172 |         cases.push_back({"NegativeTimeStep", opts, "time.dt must be > 0", {"time", "dt"}, nullptr});
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=              .options= .expected_message_substring= .expected_context= .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:177:29: error: 0.01 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  177 |         opts.time_min_dt = -0.01;
      |                             ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:178:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  178 |         cases.push_back({"NegativeMinDt", opts, "time.min_dt must be >= 0", {"time", "min_dt"}, nullptr});
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=           .options= .expected_message_substring= .expected_context= .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:183:28: error: 0.001 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  183 |         opts.time_max_dt = 0.001;
      |                            ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:185:13: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  185 |             {"MaxDtBelowInitial", opts, "time.max_dt must be >= time.dt", {"time", "max_dt"}, nullptr});
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |              .name=               .options= .expected_message_substring=  .expected_context=  .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:191:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  191 |         cases.push_back({"ZeroSolverIterations",
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=
  192 |                          opts,
      |                          ~~~~~
      |                          .options=
  193 |                          "solver.max_iters must be >= 1",
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_message_substring=
  194 |                          {"solver", "max_iters"},
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_context=
  195 |                          nullptr});
      |                          ~~~~~~~~
      |                          .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:202:13: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  202 |             {"NegativeSolverTolerance", opts, "solver tolerances must be > 0", {"solver"}, nullptr});
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |              .name=                     .options= .expected_message_substring= .expected_context= .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:208:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  208 |         cases.push_back({"MissingPrecisionSection", opts, "missing precision map", {"precision"}, nullptr});
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=                     .options= .expected_message_substring= .expected_context= .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:213:33: error: use designated initializer list to initialize 'CurveSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  213 |         opts.curves = {CurveSpec{"load_curve1", {{0.0, 0.0}, {0.6, 1.0}, {0.5, 1.1}}}};
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                  .name=         .points=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:43:1: note: aggregate type is defined here
   43 | struct CurveSpec
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:213:63: error: 0.6 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  213 |         opts.curves = {CurveSpec{"load_curve1", {{0.0, 0.0}, {0.6, 1.0}, {0.5, 1.1}}}};
      |                                                               ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:213:75: error: 0.5 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  213 |         opts.curves = {CurveSpec{"load_curve1", {{0.0, 0.0}, {0.6, 1.0}, {0.5, 1.1}}}};
      |                                                                           ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:213:80: error: 1.1 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  213 |         opts.curves = {CurveSpec{"load_curve1", {{0.0, 0.0}, {0.6, 1.0}, {0.5, 1.1}}}};
      |                                                                                ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:214:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  214 |         cases.push_back({"CurveTimesNotMonotonic",
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=
  215 |                          opts,
      |                          ~~~~~
      |                          .options=
  216 |                          "curve times must be non-decreasing",
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_message_substring=
  217 |                          {"curves", "load_curve1", "[2]"},
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_context=
  218 |                          nullptr});
      |                          ~~~~~~~~
      |                          .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:224:44: error: use designated initializer list to initialize 'TractionSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  224 |         opts.tractions      = {TractionSpec{"LOAD_FACE", {0.0, 0.0, -1.0e5}, "load_curve1"}};
      |                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                             .group=      .value=             .scale_curve=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:49:1: note: aggregate type is defined here
   49 | struct TractionSpec
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:224:70: error: 1.0e5 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  224 |         opts.tractions      = {TractionSpec{"LOAD_FACE", {0.0, 0.0, -1.0e5}, "load_curve1"}};
      |                                                                      ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:225:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  225 |         cases.push_back({"TractionUnknownCurve",
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=
  226 |                          opts,
      |                          ~~~~~
      |                          .options=
  227 |                          "traction references unknown curve",
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_message_substring=
  228 |                          {"loads", "tractions", "[0]", "scale_curve"},
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_context=
  229 |                          nullptr});
      |                          ~~~~~~~~
      |                          .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:235:26: error: use designated initializer list to initialize 'DirichletSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  235 |             DirichletSpec{"FIXED_BASE", {false, false, false}, {std::nullopt, std::nullopt, std::nullopt}}};
      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                           .group=       .constrain=            .values=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:56:1: note: aggregate type is defined here
   56 | struct DirichletSpec
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:235:70: error: no header providing "std::nullopt" is directly included [misc-include-cleaner,-warnings-as-errors]
    9 |             DirichletSpec{"FIXED_BASE", {false, false, false}, {std::nullopt, std::nullopt, std::nullopt}}};
      |                                                                      ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:236:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  236 |         cases.push_back({"EmptyDirichletDof",
      |                         ^~~~~~~~~~~~~~~~~~~~~
      |                          .name=
  237 |                          opts,
      |                          ~~~~~
      |                          .options=
  238 |                          "dirichlet.dof must not be empty",
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_message_substring=
  239 |                          {"dirichlet", "fixes", "[0]", "dof"},
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_context=
  240 |                          nullptr});
      |                          ~~~~~~~~
      |                          .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:247:13: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  247 |             {"ZeroOutputStride", opts, "output.vtu_stride must be >= 1", {"output", "vtu_stride"}, nullptr});
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |              .name=              .options= .expected_message_substring=  .expected_context=        .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:253:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  253 |         cases.push_back({"MissingOutputSection", opts, "missing output map", {"output"}, nullptr});
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=                  .options= .expected_message_substring= .expected_context= .mutate_yaml=
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:259:25: error: use designated initializer list to initialize 'InvalidConfigCase' [modernize-use-designated-initializers,-warnings-as-errors]
  259 |         cases.push_back({"DirichletInvalidAxis",
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~
      |                          .name=
  260 |                          opts,
      |                          ~~~~~
      |                          .options=
  261 |                          "dirichlet.dof must be subset of {x,y,z}",
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_message_substring=
  262 |                          {"dirichlet", "fixes", "[0]", "dof"},
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                          .expected_context=
  263 |                          [](std::string &yaml) {
      |                          ~~~~~~~~~~~~~~~~~~~~~~~
      |                          .mutate_yaml=
  264 |                              const auto token = std::string{"dof: [x, y, z]"};
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  265 |                              const auto pos   = yaml.find(token);
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  266 |                              if (pos != std::string::npos)
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  267 |                              {
      |                              ~
  268 |                                  yaml.replace(pos, token.size(), "dof: [x, q]");
      |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  269 |                              }
      |                              ~
  270 |                          }});
      |                          ~~
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:71:1: note: aggregate type is defined here
   71 | struct InvalidConfigCase
      | ^
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:263:26: error: use a trailing return type for this lambda [modernize-use-trailing-return-type,-warnings-as-errors]
  263 |                          [](std::string &yaml) {
      |                          ^
      |                                                -> void
C:\Dev\CiviWave-FEM\tests\config_validation_test.cpp:278:26: error: use a trailing return type for this lambda [modernize-use-trailing-return-type,-warnings-as-errors]
  278 |                          [](const ::testing::TestParamInfo<InvalidConfigCase> &test_info) {
      |                          ^
      |                                                                                           -> std::string
  505 |           __VA_ARGS__,                                                       \
      |           ^
  494 | #define GTEST_GET_SECOND_(first, second, ...) second
      |                                               ^
  492 | #define GTEST_EXPAND_(arg) arg
      |                            ^
Suppressed 127212 warnings (127024 in non-user code, 188 NOLINT).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
82 warnings treated as errors

File: .\tests\preprocess_test.cpp
129124 warnings and 6 errors generated.
Error while processing C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp.
error: unknown argument: '-fdeps-format=p1689r5' [clang-diagnostic-error]
error: unknown argument: '-fmodule-mapper=tests\CMakeFiles\cwf_core_tests.dir\preprocess_test.cpp.obj.modmap' [clang-diagnostic-error]
error: unknown argument: '-fmodules-ts' [clang-diagnostic-error]
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:36:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   36 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:16: error: invalid case style for namespace 'common' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |                ^~~~~~
      |                Common
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:181:27: error: invalid case style for function 'safe_normalize' [readability-identifier-naming,-warnings-as-errors]
  181 | [[nodiscard]] inline auto safe_normalize(const Vec3 &value) noexcept -> Vec3
      |                           ^~~~~~~~~~~~~~
      |                           safeNormalize
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:183:22: error: invalid case style for variable 'kThreshold' [readability-identifier-naming,-warnings-as-errors]
  183 |     constexpr double kThreshold = 1.0e-12;
      |                      ^~~~~~~~~~
      |                      k_threshold
  184 |     const auto       mag        = magnitude(value);
  185 |     if (mag < kThreshold || !std::isfinite(mag))
      |               ~~~~~~~~~~
      |               k_threshold
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:38:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   38 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:56:11: error: invalid case style for namespace 'cwf' [readability-identifier-naming,-warnings-as-errors]
   56 | namespace cwf::config
      |           ^~~
      |           Cwf
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:56:16: error: invalid case style for namespace 'config' [readability-identifier-naming,-warnings-as-errors]
   56 | namespace cwf::config
      |                ^~~~~~
      |                Config
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: error: accessing fields in struct 'ConfigError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   83 | struct ConfigError
      |        ^
   84 | {
   85 |     std::string              message; ///< spicy human-readable error message uwu
   86 |     std::vector<std::string> context; ///< breadcrumb trail showing where things derailed
   87 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: note: use "__attribute__((aligned(64)))" to align struct 'ConfigError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: error: accessing fields in struct 'Material' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   97 | struct Material
      |        ^
   98 | {
   99 |     std::string name;           ///< unique material nickname, referenced in assignments
  100 |     double      youngs_modulus; ///< E [Pa], must be > 0
  101 |     double      poisson_ratio;  ///< nu [-], typically 0 < nu < 0.5
  102 |     double      density;        ///< rho [kg/m^3], must be > 0
  103 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: note: use "__attribute__((aligned(64)))" to align struct 'Material' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: error: accessing fields in struct 'Assignment' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  108 | struct Assignment
      |        ^
  109 | {
  110 |     std::string group;    ///< physical group name from mesh (e.g., "SOLID")
  111 |     std::string material; ///< material name defined in materials list
  112 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: note: use "__attribute__((aligned(64)))" to align struct 'Assignment' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: error: accessing fields in struct 'Damping' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  119 | struct Damping
      |        ^
  120 | {
  121 |     double xi; ///< damping ratio target (0.0 - 1.0 typically)
  122 |     double w1; ///< lower angular frequency for Rayleigh fit [rad/s]
  123 |     double w2; ///< upper angular frequency [rad/s]
  124 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: note: use "__attribute__((aligned(32)))" to align struct 'Damping' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: error: accessing fields in struct 'TimeSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  129 | struct TimeSettings
      |        ^
  130 | {
  131 |     double initial_dt; ///< starting timestep [s]
  132 |     bool   adaptive;   ///< enable adaptive dt policies per spec
  133 |     double min_dt;     ///< optional safety clamp (0 if unspecified)
  134 |     double max_dt;     ///< optional safety clamp (> initial dt for safety)
  135 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: note: use "__attribute__((aligned(32)))" to align struct 'TimeSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to padding; only needs 84 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'SolverSettings'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((aligned(128)))" to align struct 'SolverSettings' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: error: accessing fields in struct 'PrecisionSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  152 | struct PrecisionSettings
      |        ^
  153 | {
  154 |     std::string vector_precision;    ///< e.g., "fp32"
  155 |     std::string reduction_precision; ///< e.g., "fp64"
  156 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: note: use "__attribute__((aligned(64)))" to align struct 'PrecisionSettings' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: error: accessing fields in struct 'Curve' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  161 | struct Curve
      |        ^
  162 | {
  163 |     std::vector<std::pair<double, double>> points; ///< (time, value) pairs sorted by time
  164 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: note: use "__attribute__((aligned(32)))" to align struct 'Curve' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: error: accessing fields in struct 'SurfaceTraction' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  169 | struct SurfaceTraction
      |        ^
  170 | {
  171 |     std::string           group;       ///< surface physical group name
  172 |     std::array<double, 3> value;       ///< traction direction + magnitude [Pa]
  173 |     std::string           scale_curve; ///< optional curve id ("" if constant)
  174 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: note: use "__attribute__((aligned(128)))" to align struct 'SurfaceTraction' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: error: accessing fields in struct 'Loads' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  179 | struct Loads
      |        ^
  180 | {
  181 |     std::array<double, 3>        gravity;   ///< global gravity vector [m/s^2]
  182 |     std::vector<SurfaceTraction> tractions; ///< list of surface loads
  183 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: note: use "__attribute__((aligned(64)))" to align struct 'Loads' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to padding; only needs 83 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'DirichletFix'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((aligned(128)))" to align struct 'DirichletFix' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: error: accessing fields in struct 'OutputSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  198 | struct OutputSettings
      |        ^
  199 | {
  200 |     std::uint32_t              vtu_stride; ///< write VTU every N frames (>= 1)
  201 |     std::vector<std::uint32_t> probes;     ///< node indices to track
  202 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: note: use "__attribute__((aligned(32)))" to align struct 'OutputSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: error: accessing fields in struct 'Config' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  207 | struct Config
      |        ^
  208 | {
  209 |     std::filesystem::path                  mesh_path;   ///< path to mesh (relative allowed)
  210 |     std::vector<Material>                  materials;   ///< materials registry
  211 |     std::vector<Assignment>                assignments; ///< physical group  material mapping
  212 |     Damping                                damping;     ///< Rayleigh damping spec
  213 |     TimeSettings                           time;        ///< time stepping configuration
  214 |     SolverSettings                         solver;      ///< solver knobs (PCG etc.)
  215 |     PrecisionSettings                      precision;   ///< precision toggles
  216 |     Loads                                  loads;       ///< body + surface loads
  217 |     std::unordered_map<std::string, Curve> curves;      ///< time history curves
  218 |     std::vector<DirichletFix>              dirichlet;   ///< locked DoFs definitions
  219 |     OutputSettings                         output;      ///< post-processing preferences
  220 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: note: use "__attribute__((aligned(128)))" to align struct 'Config' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:255:20: error: invalid case style for function 'load_config_from_file' [readability-identifier-naming,-warnings-as-errors]
  255 | [[nodiscard]] auto load_config_from_file(const std::filesystem::path &path) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromFile
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:268:20: error: invalid case style for function 'load_config_from_string' [readability-identifier-naming,-warnings-as-errors]
  268 | [[nodiscard]] auto load_config_from_string(std::string_view yaml_text) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromString
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:281:20: error: invalid case style for function 'parse_config_node' [readability-identifier-naming,-warnings-as-errors]
  281 | [[nodiscard]] auto parse_config_node(const YAML::Node &root) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~
      |                    parseConfigNode
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:30:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   30 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:42:16: error: invalid case style for namespace 'mesh' [readability-identifier-naming,-warnings-as-errors]
   42 | namespace cwf::mesh
      |                ^~~~
      |                Mesh
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:8: error: accessing fields in struct 'MeshError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   48 | struct MeshError
      |        ^
   49 | {
   50 |     std::string              message; ///< human-friendly vibe check for what failed
   51 |     std::vector<std::string> context; ///< structured breadcrumbs (e.g., "Elements[12]")
   52 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:8: note: use "__attribute__((aligned(64)))" to align struct 'MeshError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: error: accessing fields in struct 'PhysicalGroup' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   66 | struct PhysicalGroup
      |        ^
   67 | {
   68 |     std::uint32_t dimension; ///< topological dimension (2 surface, 3 volume)
   69 |     std::uint32_t id;        ///< numeric identifier from Gmsh $PhysicalNames
   70 |     std::string   name;      ///< optional user name ("SOLID", "FIXED_BASE", ...)
   71 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: note: use "__attribute__((aligned(64)))" to align struct 'PhysicalGroup' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:8: error: accessing fields in struct 'Node' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
   76 | struct Node
      |        ^
   77 | {
   78 |     std::uint32_t original_id; ///< id from Gmsh file (1-indexed)
   79 |     common::Vec3  position;    ///< xyz coordinates in meters
   80 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:8: note: use "__attribute__((aligned(32)))" to align struct 'Node' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: accessing fields in struct 'Element' is inefficient due to padding; only needs 41 bytes but is using 44 bytes [altera-struct-pack-align,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
   91 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'Element'
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: accessing fields in struct 'Element' is inefficient due to poor alignment; currently aligned to 4 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
   91 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: note: use "__attribute__((aligned(64)))" to align struct 'Element' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:89:31: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
      |                               ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:96:8: error: accessing fields in struct 'Mesh' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   96 | struct Mesh
      |        ^
   97 | {
   98 |     std::vector<Node>                              nodes;           ///< contiguous node buffer (id-sorted)
   99 |     std::vector<Element>                           elements;        ///< supported volume elements (tet/hexa)
  100 |     std::vector<PhysicalGroup>                     physical_groups; ///< physical metadata
  101 |     std::unordered_map<std::uint32_t, std::size_t> group_lookup;    ///< id  index map for fast lookup
  102 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:96:8: note: use "__attribute__((aligned(128)))" to align struct 'Mesh' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:121:20: error: invalid case style for function 'load_gmsh_file' [readability-identifier-naming,-warnings-as-errors]
  121 | [[nodiscard]] auto load_gmsh_file(const std::filesystem::path &path) -> MeshResult;
      |                    ^~~~~~~~~~~~~~
      |                    loadGmshFile
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:131:20: error: invalid case style for function 'load_gmsh_from_string' [readability-identifier-naming,-warnings-as-errors]
  131 | [[nodiscard]] auto load_gmsh_from_string(std::string_view ascii_contents) -> MeshResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadGmshFromString
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:16:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   16 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:25:22: error: invalid case style for namespace 'pre' [readability-identifier-naming,-warnings-as-errors]
   25 | namespace cwf::mesh::pre
      |                      ^~~
      |                      Pre
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:8: error: accessing fields in struct 'PreprocessError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   31 | struct PreprocessError
      |        ^
   32 | {
   33 |     std::string              message;
   34 |     std::vector<std::string> context;
   35 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:31:8: note: use "__attribute__((aligned(64)))" to align struct 'PreprocessError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:40:8: error: accessing fields in struct 'NodeAdjacency' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   40 | struct NodeAdjacency
      |        ^
   41 | {
   42 |     std::vector<std::uint32_t> offsets;         ///< size = nodes + 1
   43 |     std::vector<std::uint32_t> element_indices; ///< flattened element indices per node
   44 |     std::vector<std::uint8_t>  local_indices;   ///< corresponding local node slot (0-7)
   45 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:40:8: note: use "__attribute__((aligned(128)))" to align struct 'NodeAdjacency' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:50:8: error: accessing fields in struct 'Outputs' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   50 | struct Outputs
      |        ^
   51 | {
   52 |     NodeAdjacency                            adjacency;       ///< node-element incidence
   53 |     std::vector<double>                      element_volumes; ///< volume per element [m^3]
   54 |     std::vector<std::array<common::Vec3, 8>> shape_gradients; ///< grad Ni per element (tet uses first 4)
   55 |     std::vector<double>                      lumped_mass;     ///< mass per node [kg]
   56 |     std::vector<std::size_t> element_material_index;          ///< index into config.materials per element
   57 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:50:8: note: use "__attribute__((aligned(128)))" to align struct 'Outputs' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/preprocess.hpp:54:42: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   54 |     std::vector<std::array<common::Vec3, 8>> shape_gradients; ///< grad Ni per element (tet uses first 4)
      |                                          ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:5:1: error: #includes are not sorted properly [llvm-include-order,-warnings-as-errors]
    5 | #include <cstdlib>
      | ^
note: this fix will not be applied because it overlaps with another fix
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:5:1: error: included header cstdlib is not used directly [misc-include-cleaner,-warnings-as-errors]
    5 | #include <cstdlib>
      | ^~~~~~~~~~~~~~~~~~
    6 | #include <filesystem>
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:26:18: error: invalid case style for variable 'kTol' [readability-identifier-naming,-warnings-as-errors]
   26 | constexpr double kTol = 1.0e-9;
      |                  ^~~~
      |                  k_tol
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:28:20: error: function 'load_fixture_mesh' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   28 | [[nodiscard]] auto load_fixture_mesh() -> cwf::mesh::Mesh
      |                    ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:28:20: error: invalid case style for function 'load_fixture_mesh' [readability-identifier-naming,-warnings-as-errors]
   28 | [[nodiscard]] auto load_fixture_mesh() -> cwf::mesh::Mesh
      |                    ^~~~~~~~~~~~~~~~~
      |                    loadFixtureMesh
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:37:9: error: cannot use 'throw' with exceptions disabled [clang-diagnostic-error]
   37 |         throw std::runtime_error("cantilever mesh fixture failed to load");
      |         ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:42:20: error: function 'load_config' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   42 | [[nodiscard]] auto load_config(const cwf::test_support::ConfigBuilderOptions &options = {})
      |                    ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:42:20: error: invalid case style for function 'load_config' [readability-identifier-naming,-warnings-as-errors]
   42 | [[nodiscard]] auto load_config(const cwf::test_support::ConfigBuilderOptions &options = {})
      |                    ^~~~~~~~~~~
      |                    loadConfig
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:48:9: error: cannot use 'throw' with exceptions disabled [clang-diagnostic-error]
   48 |         throw std::runtime_error("builder options produced invalid config unexpectedly");
      |         ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:53:20: error: function 'load_mesh_from_string' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   53 | [[nodiscard]] auto load_mesh_from_string(const std::string &gmsh) -> cwf::mesh::Mesh
      |                    ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:53:20: error: invalid case style for function 'load_mesh_from_string' [readability-identifier-naming,-warnings-as-errors]
   53 | [[nodiscard]] auto load_mesh_from_string(const std::string &gmsh) -> cwf::mesh::Mesh
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadMeshFromString
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:58:9: error: cannot use 'throw' with exceptions disabled [clang-diagnostic-error]
   58 |         throw std::runtime_error(mesh_result.error().message);
      |         ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:65:1: error: function 'TestBody' has cognitive complexity of 63 (threshold 25) [readability-function-cognitive-complexity,-warnings-as-errors]
   65 | TEST(PreprocessPipeline, ProducesExpectedOutputsForCantileverFixture)
      | ^
 2192 | #define TEST(test_suite_name, test_name) GTEST_TEST(test_suite_name, test_name)
      |                                          ^
 2186 |   GTEST_TEST_(test_suite_name, test_name, ::testing::Test, \
      |   ^
 1519 |   void GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::TestBody()
      |                                                            ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:70:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   70 |     ASSERT_TRUE(preprocess.has_value()) << preprocess.error().message;
      |     ^
 1831 | #define ASSERT_TRUE(condition) GTEST_ASSERT_TRUE(condition)
      |                                ^
 1814 |   GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_FATAL_FAILURE_)
      |   ^
 1451 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                       \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:70:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   70 |     ASSERT_TRUE(preprocess.has_value()) << preprocess.error().message;
      |     ^
 1831 | #define ASSERT_TRUE(condition) GTEST_ASSERT_TRUE(condition)
      |                                ^
 1814 |   GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_FATAL_FAILURE_)
      |   ^
 1452 |   if (const ::testing::AssertionResult gtest_ar_ =                    \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:70:5: note: +1, nesting level increased to 2
   70 |     ASSERT_TRUE(preprocess.has_value()) << preprocess.error().message;
      |     ^
 1831 | #define ASSERT_TRUE(condition) GTEST_ASSERT_TRUE(condition)
      |                                ^
 1814 |   GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_FATAL_FAILURE_)
      |   ^
 1455 |   else                                                                \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:73:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   73 |     ASSERT_EQ(outputs.element_volumes.size(), 1U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:73:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   73 |     ASSERT_EQ(outputs.element_volumes.size(), 1U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:73:5: note: +1, nesting level increased to 2
   73 |     ASSERT_EQ(outputs.element_volumes.size(), 1U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:74:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   74 |     EXPECT_NEAR(outputs.element_volumes.front(), 1.0 / 6.0, kTol);
      |     ^
 2002 |   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \
      |   ^
  183 |   GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)
      |   ^
  172 |   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:74:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   74 |     EXPECT_NEAR(outputs.element_volumes.front(), 1.0 / 6.0, kTol);
      |     ^
 2002 |   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \
      |   ^
  183 |   GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)
      |   ^
  172 |   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:74:5: note: +1, nesting level increased to 2
   74 |     EXPECT_NEAR(outputs.element_volumes.front(), 1.0 / 6.0, kTol);
      |     ^
 2002 |   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \
      |   ^
  183 |   GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)
      |   ^
  172 |   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:76:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   76 |     ASSERT_EQ(outputs.shape_gradients.size(), 1U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:76:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   76 |     ASSERT_EQ(outputs.shape_gradients.size(), 1U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:76:5: note: +1, nesting level increased to 2
   76 |     ASSERT_EQ(outputs.shape_gradients.size(), 1U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:78:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   78 |     EXPECT_THAT(grads[0], ElementsAre(-1.0, -1.0, -1.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:78:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   78 |     EXPECT_THAT(grads[0], ElementsAre(-1.0, -1.0, -1.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:78:5: note: +1, nesting level increased to 2
   78 |     EXPECT_THAT(grads[0], ElementsAre(-1.0, -1.0, -1.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:79:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   79 |     EXPECT_THAT(grads[1], ElementsAre(1.0, 0.0, 0.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:79:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   79 |     EXPECT_THAT(grads[1], ElementsAre(1.0, 0.0, 0.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:79:5: note: +1, nesting level increased to 2
   79 |     EXPECT_THAT(grads[1], ElementsAre(1.0, 0.0, 0.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:80:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   80 |     EXPECT_THAT(grads[2], ElementsAre(0.0, 1.0, 0.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:80:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   80 |     EXPECT_THAT(grads[2], ElementsAre(0.0, 1.0, 0.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:80:5: note: +1, nesting level increased to 2
   80 |     EXPECT_THAT(grads[2], ElementsAre(0.0, 1.0, 0.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:81:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   81 |     EXPECT_THAT(grads[3], ElementsAre(0.0, 0.0, 1.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:81:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   81 |     EXPECT_THAT(grads[3], ElementsAre(0.0, 0.0, 1.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:81:5: note: +1, nesting level increased to 2
   81 |     EXPECT_THAT(grads[3], ElementsAre(0.0, 0.0, 1.0));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:84:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   84 |     ASSERT_EQ(outputs.lumped_mass.size(), 4U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:84:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   84 |     ASSERT_EQ(outputs.lumped_mass.size(), 4U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:84:5: note: +1, nesting level increased to 2
   84 |     ASSERT_EQ(outputs.lumped_mass.size(), 4U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:85:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   85 |     for (double mass : outputs.lumped_mass)
      |     ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:87:9: note: +2, including nesting penalty of 1, nesting level increased to 2
   87 |         EXPECT_NEAR(mass, expected_mass, kTol);
      |         ^
 2002 |   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \
      |   ^
  183 |   GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)
      |   ^
  172 |   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:87:9: note: +3, including nesting penalty of 2, nesting level increased to 3
   87 |         EXPECT_NEAR(mass, expected_mass, kTol);
      |         ^
 2002 |   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \
      |   ^
  183 |   GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)
      |   ^
  172 |   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:87:9: note: +1, nesting level increased to 3
   87 |         EXPECT_NEAR(mass, expected_mass, kTol);
      |         ^
 2002 |   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \
      |   ^
  183 |   GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)
      |   ^
  172 |   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:90:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   90 |     EXPECT_THAT(outputs.element_material_index, ElementsAre(0U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:90:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   90 |     EXPECT_THAT(outputs.element_material_index, ElementsAre(0U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:90:5: note: +1, nesting level increased to 2
   90 |     EXPECT_THAT(outputs.element_material_index, ElementsAre(0U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:92:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   92 |     ASSERT_EQ(outputs.adjacency.offsets.size(), 5U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:92:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   92 |     ASSERT_EQ(outputs.adjacency.offsets.size(), 5U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:92:5: note: +1, nesting level increased to 2
   92 |     ASSERT_EQ(outputs.adjacency.offsets.size(), 5U);
      |     ^
 1914 | #define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)
      |                               ^
 1898 |   ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |   ^
  148 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)
      |   ^
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:93:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   93 |     EXPECT_THAT(outputs.adjacency.offsets, ElementsAre(0U, 1U, 2U, 3U, 4U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:93:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   93 |     EXPECT_THAT(outputs.adjacency.offsets, ElementsAre(0U, 1U, 2U, 3U, 4U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:93:5: note: +1, nesting level increased to 2
   93 |     EXPECT_THAT(outputs.adjacency.offsets, ElementsAre(0U, 1U, 2U, 3U, 4U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:94:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   94 |     EXPECT_THAT(outputs.adjacency.element_indices, ElementsAre(0U, 0U, 0U, 0U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:94:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   94 |     EXPECT_THAT(outputs.adjacency.element_indices, ElementsAre(0U, 0U, 0U, 0U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:94:5: note: +1, nesting level increased to 2
   94 |     EXPECT_THAT(outputs.adjacency.element_indices, ElementsAre(0U, 0U, 0U, 0U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:95:5: note: +1, including nesting penalty of 0, nesting level increased to 1
   95 |     EXPECT_THAT(outputs.adjacency.local_indices, ElementsAre(0U, 1U, 2U, 3U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   78 |   GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
      |   ^
  730 |   switch (0)                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:95:5: note: +2, including nesting penalty of 1, nesting level increased to 2
   95 |     EXPECT_THAT(outputs.adjacency.local_indices, ElementsAre(0U, 1U, 2U, 3U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:95:5: note: +1, nesting level increased to 2
   95 |     EXPECT_THAT(outputs.adjacency.local_indices, ElementsAre(0U, 1U, 2U, 3U));
      |     ^
 5444 |   EXPECT_PRED_FORMAT1(              \
      |   ^
  109 |   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)
      |   ^
  100 |   GTEST_ASSERT_(pred_format(#v1, v1), on_failure)
      |   ^
   81 |   else                                                          \
      |   ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:85:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   85 |     for (double mass : outputs.lumped_mass)
      |     ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:85:10: error: variable 'mass' of type 'double' can be declared 'const' [misc-const-correctness,-warnings-as-errors]
   85 |     for (double mass : outputs.lumped_mass)
      |          ^
      |                 const 
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:113:16: error: the const qualified variable 'config' is copy-constructed from a const reference; consider making it a const reference [performance-unnecessary-copy-initialization,-warnings-as-errors]
  113 |     const auto config     = config_result.value();
      |                ^
      |               &
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:152:16: error: the const qualified variable 'config' is copy-constructed from a const reference; consider making it a const reference [performance-unnecessary-copy-initialization,-warnings-as-errors]
  152 |     const auto config     = config_result.value();
      |                ^
      |               &
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:202:9: error: use designated initializer list to initialize 'DirichletSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  202 |         {"NONEXISTENT_GROUP", {true, true, true}, {std::nullopt, std::nullopt, std::nullopt}}};
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |          .group=              .constrain=         .values=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:56:1: note: aggregate type is defined here
   56 | struct DirichletSpec
      | ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:202:57: error: no header providing "std::nullopt" is directly included [misc-include-cleaner,-warnings-as-errors]
    9 |         {"NONEXISTENT_GROUP", {true, true, true}, {std::nullopt, std::nullopt, std::nullopt}}};
      |                                                         ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:205:16: error: the const qualified variable 'config' is copy-constructed from a const reference; consider making it a const reference [performance-unnecessary-copy-initialization,-warnings-as-errors]
  205 |     const auto config = config_result.value();
      |                ^
      |               &
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:226:33: error: use designated initializer list to initialize 'TractionSpec' [modernize-use-designated-initializers,-warnings-as-errors]
  226 |     options.tractions        = {{"NONEXISTENT_GROUP", {1.0, 0.0, 0.0}, ""}};
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                                  .group=              .value=          .scale_curve=
C:\Dev\CiviWave-FEM\tests\support/config_builder.hpp:49:1: note: aggregate type is defined here
   49 | struct TractionSpec
      | ^
C:\Dev\CiviWave-FEM\tests\preprocess_test.cpp:229:16: error: the const qualified variable 'config' is copy-constructed from a const reference; consider making it a const reference [performance-unnecessary-copy-initialization,-warnings-as-errors]
  229 |     const auto config = config_result.value();
      |                ^
      |               &
Suppressed 129275 warnings (129061 in non-user code, 214 NOLINT).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
61 warnings treated as errors

File: .\tests\test_sample.cpp
111740 warnings and 3 errors generated.
Error while processing C:\Dev\CiviWave-FEM\tests\test_sample.cpp.
error: unknown argument: '-fdeps-format=p1689r5' [clang-diagnostic-error]
error: unknown argument: '-fmodule-mapper=tests\CMakeFiles\cwf_core_tests.dir\test_sample.cpp.obj.modmap' [clang-diagnostic-error]
error: unknown argument: '-fmodules-ts' [clang-diagnostic-error]
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:36:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   36 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:11: error: invalid case style for namespace 'cwf' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |           ^~~
      |           Cwf
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:16: error: invalid case style for namespace 'common' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |                ^~~~~~
      |                Common
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:181:27: error: invalid case style for function 'safe_normalize' [readability-identifier-naming,-warnings-as-errors]
  181 | [[nodiscard]] inline auto safe_normalize(const Vec3 &value) noexcept -> Vec3
      |                           ^~~~~~~~~~~~~~
      |                           safeNormalize
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:183:22: error: invalid case style for variable 'kThreshold' [readability-identifier-naming,-warnings-as-errors]
  183 |     constexpr double kThreshold = 1.0e-12;
      |                      ^~~~~~~~~~
      |                      k_threshold
  184 |     const auto       mag        = magnitude(value);
  185 |     if (mag < kThreshold || !std::isfinite(mag))
      |               ~~~~~~~~~~
      |               k_threshold
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:1:1: error: #includes are not sorted properly [llvm-include-order,-warnings-as-errors]
    1 | #include <array>
      | ^
note: this fix will not be applied because it overlaps with another fix
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:1:1: error: included header array is not used directly [misc-include-cleaner,-warnings-as-errors]
    1 | #include <array>
      | ^~~~~~~~~~~~~~~~
    2 | #include <cmath>
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:10:16: error: using decl 'DoubleNear' is unused [misc-unused-using-decls,-warnings-as-errors]
   10 | using testing::DoubleNear;
      |                ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:10:16: note: remove the using
   10 | using testing::DoubleNear;
      | ~~~~~~~~~~~~~~~^~~~~~~~~~~
   11 | using testing::ElementsAreArray;
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:16:18: error: invalid case style for variable 'kEps' [readability-identifier-naming,-warnings-as-errors]
   16 | constexpr double kEps = 1.0e-12;
      |                  ^~~~
      |                  k_eps
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:18:20: error: function 'make_basis_vectors' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   18 | [[nodiscard]] auto make_basis_vectors() -> std::vector<cwf::common::Vec3>
      |                    ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:18:20: error: invalid case style for function 'make_basis_vectors' [readability-identifier-naming,-warnings-as-errors]
   18 | [[nodiscard]] auto make_basis_vectors() -> std::vector<cwf::common::Vec3>
      |                    ^~~~~~~~~~~~~~~~~~
      |                    makeBasisVectors
   19 | {
   20 |     return {cwf::common::Vec3{0.0, 0.0, 0.0},  cwf::common::Vec3{1.0, 0.0, 0.0},
   21 |             cwf::common::Vec3{0.0, 1.0, 0.0},  cwf::common::Vec3{0.0, 0.0, 1.0},
   22 |             cwf::common::Vec3{1.0, 1.0, 1.0},  cwf::common::Vec3{-1.0, -1.0, -1.0},
   23 |             cwf::common::Vec3{2.5, -3.0, 4.0}, cwf::common::Vec3{-4.0, 2.0, -1.5}};
   24 | }
   25 | 
   26 | } // namespace
   27 | 
   28 | /**
   29 |  * @test verifies dot product symmetry for a chunky dataset of vectors
   30 |  */
   31 | TEST(CommonMathDot, SymmetryForAllPairs)
   32 | {
   33 |     const auto vectors = make_basis_vectors();
      |                          ~~~~~~~~~~~~~~~~~~
      |                          makeBasisVectors
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:23:31: error: 2.5 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   23 |             cwf::common::Vec3{2.5, -3.0, 4.0}, cwf::common::Vec3{-4.0, 2.0, -1.5}};
      |                               ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:23:37: error: 3.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   23 |             cwf::common::Vec3{2.5, -3.0, 4.0}, cwf::common::Vec3{-4.0, 2.0, -1.5}};
      |                                     ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:23:42: error: 4.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   23 |             cwf::common::Vec3{2.5, -3.0, 4.0}, cwf::common::Vec3{-4.0, 2.0, -1.5}};
      |                                          ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:23:67: error: 4.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   23 |             cwf::common::Vec3{2.5, -3.0, 4.0}, cwf::common::Vec3{-4.0, 2.0, -1.5}};
      |                                                                   ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:23:72: error: 2.0 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   23 |             cwf::common::Vec3{2.5, -3.0, 4.0}, cwf::common::Vec3{-4.0, 2.0, -1.5}};
      |                                                                        ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:23:78: error: 1.5 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   23 |             cwf::common::Vec3{2.5, -3.0, 4.0}, cwf::common::Vec3{-4.0, 2.0, -1.5}};
      |                                                                              ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:36:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   36 |         for (const auto &rhs : vectors)
      |         ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:39:34: error: 1st argument 'rhs' (passed to 'lhs') looks like it might be swapped with the 2nd, 'lhs' (passed to 'rhs') [readability-suspicious-call-argument,-warnings-as-errors]
   39 |             const auto rhs_lhs = cwf::common::dot(rhs, lhs);
      |                                  ^                ~~~  ~~~
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:89:30: note: in the call to 'dot', declared here
   89 | [[nodiscard]] constexpr auto dot(const Vec3 &lhs, const Vec3 &rhs) noexcept -> double
      |                              ^               ~~~              ~~~
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:52:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   52 |     for (const auto &candidate : vectors)
      |     ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:64:16: error: variable name 'i' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   64 |     const auto i = cwf::common::Vec3{1.0, 0.0, 0.0};
      |                ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:65:16: error: variable name 'j' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   65 |     const auto j = cwf::common::Vec3{0.0, 1.0, 0.0};
      |                ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:66:16: error: variable name 'k' is too short, expected at least 3 characters [readability-identifier-length,-warnings-as-errors]
   66 |     const auto k = cwf::common::Vec3{0.0, 0.0, 1.0};
      |                ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:79:15: error: no header providing "std::size_t" is directly included [misc-include-cleaner,-warnings-as-errors]
    3 |     for (std::size_t lhs = 1; lhs < vectors.size(); ++lhs)
      |               ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:81:9: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   81 |         for (std::size_t rhs = lhs + 1; rhs < vectors.size(); ++rhs)
      |         ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:81:41: error: backward branch (for loop) is ID-dependent due to variable reference to 'rhs' and may cause performance degradation [altera-id-dependent-backward-branch,-warnings-as-errors]
   81 |         for (std::size_t rhs = lhs + 1; rhs < vectors.size(); ++rhs)
      |                                         ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:81:14: note: inferred assignment of ID-dependent value from ID-dependent 
   81 |         for (std::size_t rhs = lhs + 1; rhs < vectors.size(); ++rhs)
      |              ^
C:\Dev\CiviWave-FEM\tests\test_sample.cpp:130:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
  130 |     for (const auto &vec : vectors)
      |     ^
Suppressed 111855 warnings (111671 in non-user code, 184 NOLINT).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
27 warnings treated as errors

File: .\tests\mesh_loader_test.cpp
127289 warnings and 3 errors generated.
Error while processing C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp.
error: unknown argument: '-fdeps-format=p1689r5' [clang-diagnostic-error]
error: unknown argument: '-fmodule-mapper=tests\CMakeFiles\cwf_core_tests.dir\mesh_loader_test.cpp.obj.modmap' [clang-diagnostic-error]
error: unknown argument: '-fmodules-ts' [clang-diagnostic-error]
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:36:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   36 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:11: error: invalid case style for namespace 'cwf' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |           ^~~
      |           Cwf
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:44:16: error: invalid case style for namespace 'common' [readability-identifier-naming,-warnings-as-errors]
   44 | namespace cwf::common
      |                ^~~~~~
      |                Common
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:181:27: error: invalid case style for function 'safe_normalize' [readability-identifier-naming,-warnings-as-errors]
  181 | [[nodiscard]] inline auto safe_normalize(const Vec3 &value) noexcept -> Vec3
      |                           ^~~~~~~~~~~~~~
      |                           safeNormalize
C:/Dev/CiviWave-FEM/include\cwf/common/math.hpp:183:22: error: invalid case style for variable 'kThreshold' [readability-identifier-naming,-warnings-as-errors]
  183 |     constexpr double kThreshold = 1.0e-12;
      |                      ^~~~~~~~~~
      |                      k_threshold
  184 |     const auto       mag        = magnitude(value);
  185 |     if (mag < kThreshold || !std::isfinite(mag))
      |               ~~~~~~~~~~
      |               k_threshold
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:38:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   38 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:56:16: error: invalid case style for namespace 'config' [readability-identifier-naming,-warnings-as-errors]
   56 | namespace cwf::config
      |                ^~~~~~
      |                Config
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: error: accessing fields in struct 'ConfigError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   83 | struct ConfigError
      |        ^
   84 | {
   85 |     std::string              message; ///< spicy human-readable error message uwu
   86 |     std::vector<std::string> context; ///< breadcrumb trail showing where things derailed
   87 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:83:8: note: use "__attribute__((aligned(64)))" to align struct 'ConfigError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: error: accessing fields in struct 'Material' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   97 | struct Material
      |        ^
   98 | {
   99 |     std::string name;           ///< unique material nickname, referenced in assignments
  100 |     double      youngs_modulus; ///< E [Pa], must be > 0
  101 |     double      poisson_ratio;  ///< nu [-], typically 0 < nu < 0.5
  102 |     double      density;        ///< rho [kg/m^3], must be > 0
  103 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:97:8: note: use "__attribute__((aligned(64)))" to align struct 'Material' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: error: accessing fields in struct 'Assignment' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  108 | struct Assignment
      |        ^
  109 | {
  110 |     std::string group;    ///< physical group name from mesh (e.g., "SOLID")
  111 |     std::string material; ///< material name defined in materials list
  112 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:108:8: note: use "__attribute__((aligned(64)))" to align struct 'Assignment' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: error: accessing fields in struct 'Damping' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  119 | struct Damping
      |        ^
  120 | {
  121 |     double xi; ///< damping ratio target (0.0 - 1.0 typically)
  122 |     double w1; ///< lower angular frequency for Rayleigh fit [rad/s]
  123 |     double w2; ///< upper angular frequency [rad/s]
  124 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:119:8: note: use "__attribute__((aligned(32)))" to align struct 'Damping' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: error: accessing fields in struct 'TimeSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  129 | struct TimeSettings
      |        ^
  130 | {
  131 |     double initial_dt; ///< starting timestep [s]
  132 |     bool   adaptive;   ///< enable adaptive dt policies per spec
  133 |     double min_dt;     ///< optional safety clamp (0 if unspecified)
  134 |     double max_dt;     ///< optional safety clamp (> initial dt for safety)
  135 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:129:8: note: use "__attribute__((aligned(32)))" to align struct 'TimeSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to padding; only needs 84 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'SolverSettings'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: error: accessing fields in struct 'SolverSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  140 | struct SolverSettings
      |        ^
  141 | {
  142 |     std::string   type;              ///< e.g., "pcg"
  143 |     std::string   preconditioner;    ///< e.g., "block_jacobi"
  144 |     double        runtime_tolerance; ///< tol while sim running (looser)
  145 |     double        pause_tolerance;   ///< tol when paused (tighter)
  146 |     std::uint32_t max_iterations;    ///< iteration cap per step (>= 1)
  147 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:140:8: note: use "__attribute__((aligned(128)))" to align struct 'SolverSettings' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: error: accessing fields in struct 'PrecisionSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  152 | struct PrecisionSettings
      |        ^
  153 | {
  154 |     std::string vector_precision;    ///< e.g., "fp32"
  155 |     std::string reduction_precision; ///< e.g., "fp64"
  156 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:152:8: note: use "__attribute__((aligned(64)))" to align struct 'PrecisionSettings' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: error: accessing fields in struct 'Curve' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  161 | struct Curve
      |        ^
  162 | {
  163 |     std::vector<std::pair<double, double>> points; ///< (time, value) pairs sorted by time
  164 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:161:8: note: use "__attribute__((aligned(32)))" to align struct 'Curve' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: error: accessing fields in struct 'SurfaceTraction' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  169 | struct SurfaceTraction
      |        ^
  170 | {
  171 |     std::string           group;       ///< surface physical group name
  172 |     std::array<double, 3> value;       ///< traction direction + magnitude [Pa]
  173 |     std::string           scale_curve; ///< optional curve id ("" if constant)
  174 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:169:8: note: use "__attribute__((aligned(128)))" to align struct 'SurfaceTraction' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: error: accessing fields in struct 'Loads' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
  179 | struct Loads
      |        ^
  180 | {
  181 |     std::array<double, 3>        gravity;   ///< global gravity vector [m/s^2]
  182 |     std::vector<SurfaceTraction> tractions; ///< list of surface loads
  183 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:179:8: note: use "__attribute__((aligned(64)))" to align struct 'Loads' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to padding; only needs 83 bytes but is using 88 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'DirichletFix'
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: error: accessing fields in struct 'DirichletFix' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  188 | struct DirichletFix
      |        ^
  189 | {
  190 |     std::string                          group;          ///< named group from mesh (usually surfaces)
  191 |     std::array<bool, 3>                  constrain_axis; ///< which dofs are locked (xyz)
  192 |     std::array<std::optional<double>, 3> value;          ///< optional displacement targets per axis
  193 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:188:8: note: use "__attribute__((aligned(128)))" to align struct 'DirichletFix' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: error: accessing fields in struct 'OutputSettings' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
  198 | struct OutputSettings
      |        ^
  199 | {
  200 |     std::uint32_t              vtu_stride; ///< write VTU every N frames (>= 1)
  201 |     std::vector<std::uint32_t> probes;     ///< node indices to track
  202 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:198:8: note: use "__attribute__((aligned(32)))" to align struct 'OutputSettings' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: error: accessing fields in struct 'Config' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
  207 | struct Config
      |        ^
  208 | {
  209 |     std::filesystem::path                  mesh_path;   ///< path to mesh (relative allowed)
  210 |     std::vector<Material>                  materials;   ///< materials registry
  211 |     std::vector<Assignment>                assignments; ///< physical group  material mapping
  212 |     Damping                                damping;     ///< Rayleigh damping spec
  213 |     TimeSettings                           time;        ///< time stepping configuration
  214 |     SolverSettings                         solver;      ///< solver knobs (PCG etc.)
  215 |     PrecisionSettings                      precision;   ///< precision toggles
  216 |     Loads                                  loads;       ///< body + surface loads
  217 |     std::unordered_map<std::string, Curve> curves;      ///< time history curves
  218 |     std::vector<DirichletFix>              dirichlet;   ///< locked DoFs definitions
  219 |     OutputSettings                         output;      ///< post-processing preferences
  220 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:207:8: note: use "__attribute__((aligned(128)))" to align struct 'Config' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:255:20: error: invalid case style for function 'load_config_from_file' [readability-identifier-naming,-warnings-as-errors]
  255 | [[nodiscard]] auto load_config_from_file(const std::filesystem::path &path) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromFile
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:268:20: error: invalid case style for function 'load_config_from_string' [readability-identifier-naming,-warnings-as-errors]
  268 | [[nodiscard]] auto load_config_from_string(std::string_view yaml_text) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~~~
      |                    loadConfigFromString
C:/Dev/CiviWave-FEM/include\cwf/config/config.hpp:281:20: error: invalid case style for function 'parse_config_node' [readability-identifier-naming,-warnings-as-errors]
  281 | [[nodiscard]] auto parse_config_node(const YAML::Node &root) -> ConfigResult;
      |                    ^~~~~~~~~~~~~~~~~
      |                    parseConfigNode
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:30:1: error: avoid 'pragma once' directive; use include guards instead [portability-avoid-pragma-once,-warnings-as-errors]
   30 | #pragma once
      | ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:42:16: error: invalid case style for namespace 'mesh' [readability-identifier-naming,-warnings-as-errors]
   42 | namespace cwf::mesh
      |                ^~~~
      |                Mesh
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:8: error: accessing fields in struct 'MeshError' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   48 | struct MeshError
      |        ^
   49 | {
   50 |     std::string              message; ///< human-friendly vibe check for what failed
   51 |     std::vector<std::string> context; ///< structured breadcrumbs (e.g., "Elements[12]")
   52 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:48:8: note: use "__attribute__((aligned(64)))" to align struct 'MeshError' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: error: accessing fields in struct 'PhysicalGroup' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   66 | struct PhysicalGroup
      |        ^
   67 | {
   68 |     std::uint32_t dimension; ///< topological dimension (2 surface, 3 volume)
   69 |     std::uint32_t id;        ///< numeric identifier from Gmsh $PhysicalNames
   70 |     std::string   name;      ///< optional user name ("SOLID", "FIXED_BASE", ...)
   71 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:66:8: note: use "__attribute__((aligned(64)))" to align struct 'PhysicalGroup' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:8: error: accessing fields in struct 'Node' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 32 bytes [altera-struct-pack-align,-warnings-as-errors]
   76 | struct Node
      |        ^
   77 | {
   78 |     std::uint32_t original_id; ///< id from Gmsh file (1-indexed)
   79 |     common::Vec3  position;    ///< xyz coordinates in meters
   80 | };
      |  
      |   __attribute__((aligned(32)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:76:8: note: use "__attribute__((aligned(32)))" to align struct 'Node' to 32 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: accessing fields in struct 'Element' is inefficient due to padding; only needs 41 bytes but is using 44 bytes [altera-struct-pack-align,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
   91 | };
      |  
      |   __attribute__((packed))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: note: use "__attribute__((packed))" to reduce the amount of padding applied to struct 'Element'
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: accessing fields in struct 'Element' is inefficient due to poor alignment; currently aligned to 4 bytes, but recommended alignment is 64 bytes [altera-struct-pack-align,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
   91 | };
      |  
      |   __attribute__((aligned(64)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: note: use "__attribute__((aligned(64)))" to align struct 'Element' to 64 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:85:8: error: constructor does not initialize these fields: original_id, geometry, physical_group [cppcoreguidelines-pro-type-member-init,hicpp-member-init,-warnings-as-errors]
   85 | struct Element
      |        ^
   86 | {
   87 |     std::uint32_t                original_id;    ///< id from Gmsh file (1-indexed)
      |                                             
      |                                             {}
   88 |     ElementGeometry              geometry;       ///< element topology
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
   90 |     std::uint32_t                physical_group; ///< group id (links to PhysicalGroup.id)
      |                                                
      |                                                {}
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:89:31: error: 8 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   89 |     std::array<std::uint32_t, 8> nodes{};        ///< node indices (unused entries set to UINT32_MAX)
      |                               ^
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:96:8: error: accessing fields in struct 'Mesh' is inefficient due to poor alignment; currently aligned to 8 bytes, but recommended alignment is 128 bytes [altera-struct-pack-align,-warnings-as-errors]
   96 | struct Mesh
      |        ^
   97 | {
   98 |     std::vector<Node>                              nodes;           ///< contiguous node buffer (id-sorted)
   99 |     std::vector<Element>                           elements;        ///< supported volume elements (tet/hexa)
  100 |     std::vector<PhysicalGroup>                     physical_groups; ///< physical metadata
  101 |     std::unordered_map<std::uint32_t, std::size_t> group_lookup;    ///< id  index map for fast lookup
  102 | };
      |  
      |   __attribute__((aligned(128)))
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:96:8: note: use "__attribute__((aligned(128)))" to align struct 'Mesh' to 128 bytes
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:121:20: error: invalid case style for function 'load_gmsh_file' [readability-identifier-naming,-warnings-as-errors]
  121 | [[nodiscard]] auto load_gmsh_file(const std::filesystem::path &path) -> MeshResult;
      |                    ^~~~~~~~~~~~~~
      |                    loadGmshFile
C:/Dev/CiviWave-FEM/include\cwf/mesh/mesh.hpp:131:20: error: invalid case style for function 'load_gmsh_from_string' [readability-identifier-naming,-warnings-as-errors]
  131 | [[nodiscard]] auto load_gmsh_from_string(std::string_view ascii_contents) -> MeshResult;
      |                    ^~~~~~~~~~~~~~~~~~~~~
      |                    loadGmshFromString
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:5:1: error: #includes are not sorted properly [llvm-include-order,-warnings-as-errors]
    5 | #include <filesystem>
      | ^        ~~~~~~~~~~~~
    6 | #include <gmock/gmock.h>
      |          ~~~~~~~~~~~~~~~
    7 | #include <gtest/gtest.h>
      |          ~~~~~~~~~~~~~~~
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:11:1: error: included header config_builder.hpp is not used directly [misc-include-cleaner,-warnings-as-errors]
   11 | #include "support/config_builder.hpp"
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   12 | #include "test_config.hpp"
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:20:20: error: function 'test_data_path' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   20 | [[nodiscard]] auto test_data_path(std::string_view file) -> std::filesystem::path
      |                    ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:20:20: error: invalid case style for function 'test_data_path' [readability-identifier-naming,-warnings-as-errors]
   20 | [[nodiscard]] auto test_data_path(std::string_view file) -> std::filesystem::path
      |                    ^~~~~~~~~~~~~~
      |                    testDataPath
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:20:40: error: no header providing "std::string_view" is directly included [misc-include-cleaner,-warnings-as-errors]
    9 | 
   10 | #include "cwf/mesh/mesh.hpp"
   11 | #include "support/config_builder.hpp"
   12 | #include "test_config.hpp"
   13 | 
   14 | using testing::ElementsAre;
   15 | using testing::HasSubstr;
   16 | 
   17 | namespace
   18 | {
   19 | 
   20 | [[nodiscard]] auto test_data_path(std::string_view file) -> std::filesystem::path
      |                                        ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:25:20: error: function 'basic_gmsh_header' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   25 | [[nodiscard]] auto basic_gmsh_header() -> std::string
      |                    ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:25:20: error: invalid case style for function 'basic_gmsh_header' [readability-identifier-naming,-warnings-as-errors]
   25 | [[nodiscard]] auto basic_gmsh_header() -> std::string
      |                    ^~~~~~~~~~~~~~~~~
      |                    basicGmshHeader
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:32:20: error: function 'basic_tet_elements_block' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   32 | [[nodiscard]] auto basic_tet_elements_block(std::string element_payload) -> std::string
      |                    ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:32:20: error: invalid case style for function 'basic_tet_elements_block' [readability-identifier-naming,-warnings-as-errors]
   32 | [[nodiscard]] auto basic_tet_elements_block(std::string element_payload) -> std::string
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~
      |                    basicTetElementsBlock
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:34:55: error: no header providing "std::move" is directly included [misc-include-cleaner,-warnings-as-errors]
    9 |     return std::string{"$Elements\n1 1 1 1\n"} + std::move(element_payload) + "$EndElements\n";
      |                                                       ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:37:20: error: function 'tet_block_for_nodes' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace,-warnings-as-errors]
   37 | [[nodiscard]] auto tet_block_for_nodes(std::initializer_list<int> node_ids, std::uint32_t element_type = 4U)
      |                    ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:37:20: error: invalid case style for function 'tet_block_for_nodes' [readability-identifier-naming,-warnings-as-errors]
   37 | [[nodiscard]] auto tet_block_for_nodes(std::initializer_list<int> node_ids, std::uint32_t element_type = 4U)
      |                    ^~~~~~~~~~~~~~~~~~~
      |                    tetBlockForNodes
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:37:45: error: no header providing "std::initializer_list" is directly included [misc-include-cleaner,-warnings-as-errors]
    8 | [[nodiscard]] auto tet_block_for_nodes(std::initializer_list<int> node_ids, std::uint32_t element_type = 4U)
      |                                             ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:37:82: error: no header providing "std::uint32_t" is directly included [misc-include-cleaner,-warnings-as-errors]
    5 | [[nodiscard]] auto tet_block_for_nodes(std::initializer_list<int> node_ids, std::uint32_t element_type = 4U)
      |                                                                                  ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:41:5: error: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops,-warnings-as-errors]
   41 |     for (const auto node : node_ids)
      |     ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:93:68: error: 99 is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
   93 |     gmsh += basic_tet_elements_block(tet_block_for_nodes({1, 2, 3, 99}));
      |                                                                    ^
C:\Dev\CiviWave-FEM\tests\mesh_loader_test.cpp:102:72: error: 6U is a magic number; consider replacing it with a named constant [cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers,-warnings-as-errors]
  102 |     gmsh += basic_tet_elements_block(tet_block_for_nodes({1, 2, 3, 4}, 6U));
      |                                                                        ^
Suppressed 127426 warnings (127229 in non-user code, 197 NOLINT).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
54 warnings treated as errors

============================================================
 Summary
============================================================
Total files analyzed: 7
Files with issues: 7
Clean files: 0

Run with -Fix to automatically apply fixes.
